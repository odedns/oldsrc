/*
 * Created on: 15/10/2003
 * Author: yifat har-nof
 * @version $Id: FlowImpl.java,v 1.11 2005/05/04 12:15:03 yifat Exp $
 */
package com.ness.fw.flower.core;

import com.ness.fw.flower.common.MenuItem;
import com.ness.fw.flower.common.MenuItemList;
import com.ness.fw.flower.factory.*;
import com.ness.fw.flower.util.*;
import com.ness.fw.common.auth.MenuAuthManager;
import com.ness.fw.common.exceptions.AuthorizationException;
import com.ness.fw.common.exceptions.FatalException;
import com.ness.fw.common.exceptions.ResourceException;
import com.ness.fw.common.logger.*;

import java.util.*;

public abstract class FlowImpl implements Flow
{
	public static final String LOGGER_CONTEXT = FLOWERConstants.LOGGER_CONTEXT + "FLOW";

	/**
	 * logger context extention
	 */
	private String loggerContextExt = "";

	/**
	 * Instance of object that provides all flow configuration.
	 */
	private FlowDefinition flowDefinition;

	/**
	 * reference to current state instance
	 */
	private FlowState currentState;

	/**
	 * current flow context
	 */
	private Context flowContext;

	/**
	 * context of current state
	 */
	private Context currentStateContext;

	/**
	 * context of parent flow
	 */
	private Context parentFlowContext;

	/**
	 * The flow path indicating the place of current flow in the flow hierarhy
	 */
	private String flowPathString;

	/**
	 * map holding all subflows references
	 */
	SubFlowRegistry subFlowRegistry;

	/**
	 * sequence used for generation id for subflow
	 */
	private int subFlowIdGenerator;

	/**
	 * reference to parent flow
	 */
	private Flow parentFlow;

	/**
	 * Global transitions supplier as defined for menu flow
	 */
	private ExtendedTransitionSupplier globalTransitionsuSupplier;

	/**
	 * Transitions supplier as defined for state (menu)
	 */
	private ExtendedTransitionSupplierList stateTransitionSupplierList;

	/**
	 * Transitions supplier as defined for flow (menu)
	 */
	private ExtendedTransitionSupplierList flowTransitionSupplierList;

	/**
	 * Formatter defined as input formatter for the flow
	 */
	private Formatter inFormatter;

	/**
	 * Formatter defined as output formatter for the flow
	 */
	private Formatter outFormatter;

	/**
	 * List of final state name, engaging of each will instruct flow to
	 * format its context to parent flow context.
	 */
	private StringList goodFinalStates;

	/**
	 * Indicates whether to format parameters from the flow context to the parent 
	 * flow context, when the current flow is being killed.
	 */
	private boolean formatContextOnInterrupt;

	/**
	 * Indicates if the flow is running in online / batch mode.
	 */
	private boolean interactiveMode;
	
	/**
	 * The state of the last displayed page.
	 */
	private String lastPageState;

	/**
	 * The authorization level determined for the current flow. 
	 */
	private int flowAuthLevel; 

	/**
	 * The authorization level determined for the current state. 
	 */
	private int currentStateAuthLevel; 

	/**
	 * The dynamic global objects loaded for the current session.
	 */
	private DynamicGlobals dynamicGlobals;

	/**
	 * A List with the authorized events in the current request.
	 */
	private List authorizedEvents;

	/**
	 * The menu item list contains the menu tree of the current state, 
	 * from the flow hierarchy above and from all the subflows.
	 */
	private MenuItemList currentMenuItemList;
	
	/**
	 * Creates new FlowImpl object. 
	 * @param flowDefinition The flow definition.
	 */
	public FlowImpl(FlowDefinition flowDefinition)
	{
		this.flowDefinition = flowDefinition;

		subFlowRegistry = new SubFlowRegistry();
		subFlowIdGenerator = 1;

		loggerContextExt = " flow: " + flowDefinition.getName();
	}

	/**
	 * Called by parent flow or by <code>ControllerServlet</code> to initiate flow. By initializing flow moves to its
	 * initial state and performs initial state's entry actions
	 *
	 * @param parentFlow the initiator flow
	 * @param parentFlowContext the context of initiator flow
	 * @param flowPathString the flow path string of initiator flow concatenated with id generated by initiator flow specially for the flow.
	 * @param subFlowData The sub flow data attributes from the openning flow.
	 * @param dynamicGlobals The dynamic global objects loaded for the current session.
	 * @param interactiveMode Indicates if the flow is running in online / batch mode.
	 * @return result event with reference to the flow and errors occured while initiating.
	 */
	public ResultEvent initiate(Flow parentFlow, Context parentFlowContext, String flowPathString, SubFlowData subFlowData, DynamicGlobals dynamicGlobals, boolean interactiveMode)
	{
		this.parentFlow         = parentFlow;
		this.flowPathString     = flowPathString;
		this.parentFlowContext  = parentFlowContext;
		this.interactiveMode    = interactiveMode;
		this.dynamicGlobals = dynamicGlobals;

		if(subFlowData != null)
		{
			inFormatter        = subFlowData.getInFormatter();
			outFormatter       = subFlowData.getOutFormatter();
			goodFinalStates    = subFlowData.getGoodFinalStates();
			formatContextOnInterrupt = subFlowData.isFormatContextOnInterrupt();
		}

		loggerContextExt = "SessionId [" + dynamicGlobals.getSessionId() + "] " + loggerContextExt + " path [" + flowPathString + "] : ";

		ResultEvent resultEvent = null;
		try
		{
			currentState = flowDefinition.getFlowState(flowDefinition.getInitialStateName());

			// save last page of the flow from the state, if needed
			setLastPageState();

			Logger.info(LOGGER_CONTEXT, loggerContextExt + "Starting flow at state [" + currentState.getName() + "]");

			//create context for the flow instance
			createContext(parentFlowContext);

			//Determine the authorization level of the flow.
			setFlowAuthorizationLevel();

			//create context for current state of the flow
			createCurrentStateContext();

			//Determine the authorization level of the initial state.
			currentStateAuthLevel = getStateAuthLevel(currentState);

			//copy (formatting) parameters from flow's context to current state context
			formatFlowContextToCurrentStateConetxt();

			//run validator on current context
			validateCurrentStateContext();

			//performinf state's entry actions
			performCurrentStateEntryActions();

//			//Creates the MenuItemList with the menues of the current state
//			handleStateMenuIds();

//			//create global transitions supplier
//			globalTransitionsuSupplier = createGlobalTransitionSupplier();
//
//			//init flow transitions supplier
//			flowTransitionSupplierList = createExtendedTransitionSupplierList(flowDefinition.getMenuIds(), flowContext);
//
//			//init state transitions supplier
//			stateTransitionSupplierList = createExtendedTransitionSupplierList(currentState.getMenuIds(), currentStateContext);

			// if state type is copmlex, processing the ActivityImpl or subflow
			if (currentState.getType() == FlowState.STATE_TYPE_COMPLEX)
			{
				ComplexFlowState complexFlowState = (ComplexFlowState)currentState; 
				
				// cannot run activity & sub flow together !!
				
				// perform the activity that linked to the current state.
				if (shouldPerformActivity())
				{
					Activity activity = complexFlowState.getActivity();
					ActivityCompletionEvent activityCompletionEvent = activity.executeActivity(currentStateContext, getAuthLevel());
					resultEvent = processEventForState(activityCompletionEvent);
				}
				//if the current state is of subflow kind - running the subflow
				else if (complexFlowState.getSubFlowData() != null)
				{
					resultEvent = runSubFlow();
				}
			}
			
			//if state type is simple, processing simple event (event name is null)
			else if (currentState.getType() == FlowState.STATE_TYPE_SIMPLE)
			{
				resultEvent = processEventForState(new SimpleStateEvent());
			}

			if(resultEvent == null)
			{
				resultEvent = new ResultEvent();
			}
		}
		catch (ValidationException ex)
		{
			Logger.debug(LOGGER_CONTEXT, loggerContextExt, ex);
			resultEvent = new ResultEvent();
			resultEvent.setValidationExceptionThrown();
		}
		catch (Throwable ex)
		{
			Logger.fatal(LOGGER_CONTEXT, loggerContextExt, ex);
			resultEvent = new ResultEvent();
			resultEvent.addException(ex);
		}
		finally
		{
			// if there weren't errors the independent flow should write to the result event
			if (resultEvent.getExceptionsCount() == 0)
			{
				//set itself as topmost level (if independent)
				if (flowDefinition.isIndependent())
				{
					if (resultEvent.getFlow() == null)
					{
						ApplicationUtil.writeFlowInResultEvent(this, resultEvent, true);
					}
				}
			}
		}
		return resultEvent;
	}

	/**
	 * Check if should perform the activity that linked to the current state.
	 * activating the {@link ActivityImpl} in non-interactive mode 
	 * or when the state does not contain a declaration of a page.
	 * @return boolean
	 */
	private boolean shouldPerformActivity ()
	{
		return currentState.isStateContainsActivity() && (!interactiveMode || !currentState.isStateContainsPage());
	}

	/**
	 * Used by parent flow or by <code>ControllerServlet</code> to pass event to flow.
	 * @param event
	 */
	public ResultEvent processEvent(Event event)
	{
		ResultEvent resultEvent = null;
		try{
			//determine is the flow is last int the flow path of event
			String nextLevel = event.getFlowPath().getNextLevel();
			if (nextLevel != null) //this is not the last - passing event to subflow
			{
				//lokup for subflow
				Flow subflow = subFlowRegistry.getSubFlowById(nextLevel);
				if (subflow == null)
				{
					throw new SubflowNotFoundException("Unable to pass event to subflow at flow [" + flowDefinition.getName() + "]. The subflow with id [" + nextLevel + "] does not exist. SessionId [" + dynamicGlobals.getSessionId() + "]");
				}
				else
				{
					//passing event to subflow
					resultEvent = subflow.processEvent(event);

					//if subflow finished its run and no errors occured processing subflow completion event
					if ((!resultEvent.hasErrors()) && subflow.isFinished())
					{
						subFlowRegistry.unregisterFlow(nextLevel);

						resultEvent = processEventInternal(new FlowCompletionEvent(subflow.getCurrentState().getName()));
					}
				}
			}
			else //this is the last flow (according to flowPath parameter of event) processing event
			{

				Logger.info(LOGGER_CONTEXT, loggerContextExt + "Authorized events for flow " + flowDefinition.getName() + " flow path  "+  getFlowPathString() + " before check is [" + authorizedEvents + "].");

				//check event authorization
				if(!isEventAuthorized(event.getEventName()))
				{
					throw new FlowAuthorizationException("The event [" + event.getEventName() + "] is not authorized for flow [" + flowDefinition.getName() + "]. SessionId [" + dynamicGlobals.getSessionId() + "]");
				}

				// process the event
				resultEvent = processEventInternal(event);
			}
		}
		catch (ValidationException ex)
		{
			Logger.debug(LOGGER_CONTEXT, loggerContextExt, ex);
			resultEvent = new ResultEvent();
			resultEvent.setValidationExceptionThrown();
		}
		catch (Throwable ex)
		{
			resultEvent = new ResultEvent();
			Logger.fatal(LOGGER_CONTEXT, loggerContextExt, ex);
			resultEvent.addException(ex);
		}
		finally
		{
			// if there weren't errors the independent flow should write to the result event
			if (resultEvent.getExceptionsCount() == 0)
			{
				//set itself as topmost level (if independent)
				if (flowDefinition.isIndependent())
				{
					if (resultEvent.getFlow() == null)
					{
						ApplicationUtil.writeFlowInResultEvent(this, resultEvent, true);
					}
				}
			}
		}
		return resultEvent;
	}

	/**
	 * Indicates is the flow reached its final state
	 * @return boolean
	 */
	public boolean isFinished()
	{
		return currentState.getType() == FlowState.STATE_TYPE_FINAL;
	}

	/**
	 * Returns the name of the flow.
	 * @return String flow name
	 */
	public String getName()
	{
		return flowDefinition.getName();
	}

	/**
	 * Used to get subflow by its name.
	 *
	 * @param name name of subflow to find
	 * @return <code>Flow</code> instance
	 */
	// do not use the method inside the class to prevent call recurssion. 
	// if getCurrentStateFlow uses the method it will cause to infinite loop.
	public Flow getSubflowByName(String name)
	{
		return subFlowRegistry.getSubFlowByName(name);
	}

	/**
	 * Return the IDs of the sub flows in the hierarchy of the current flow, 
	 * without independent sub flows that was opened under the current flow.  
	 * @return Iterator An iterator over the sub flows IDs.
	 */
	public Iterator getHierarchySubFlowIdsIterator()
	{
		return subFlowRegistry.getHierarchySubFlowIdsIterator();
	}

	/**
	 * Return the IDs of all the sub flows of the current flow.
	 * @return Iterator An iterator over the sub flows IDs.
	 */
	public Iterator getSubFlowIdsIterator()
	{
		return subFlowRegistry.getSubFlowIdsIterator();
	}

	/**
	 * Return a subflow under the current flow with a specific id.
	 * @return Flow
	 */
	public Flow getSubFlowById(String id)
	{
		return subFlowRegistry.getSubFlowById(id);
	}

	/**
	 * Used to kill flow. Runs recursievely over all child flows and kill them
	 * @throws FormatterException thrown when there are some problems formating 
	 * flow context to parent flow context
	 */
	public void kill() throws ContextException, FormatterException, FatalException, AuthorizationException, FlowException
	{
		Logger.debug(LOGGER_CONTEXT, loggerContextExt + "About to be killed, flow path [" + flowPathString + "], Parent flow [" + parentFlow + "]");

		// clears the authorized events 
		clearAuthorizedEvents();

		//clear the menu items & transitions that was added for the current state menu ids.
		clearStateMenuIds();

		//run over list of subflows and kill them
		killSubflows();

		//if formatContextOnInterrupt is set for the flow - copy (formatting) parameters from the flow context to the parent flow context
		if (formatContextOnInterrupt)
		{
            formatFlowContextToParentFlowContext();
		}
	}

	/**
	 * Returns the current flow definition object.
	 * @return FlowDefinition 
	 */ 
	public FlowDefinition getFlowDefinition()
	{
		return flowDefinition;
	}

	/**
	 * Returns the page element (from the flow / current state), 
	 * contains the page & his authorizations.
	 * @return PageElementAuthLevel
	 */
	public PageElementAuthLevel getPageElement()
	{
		PageElementAuthLevel pageElement = null;
		PageElementAuthLevel flowPageElement = getFlowPageElement();
		if(flowPageElement.isContainsPage())
		{
			pageElement = flowPageElement;
		}
		else
		{
			PageElementAuthLevel statePageElement = getCurrentStatePageElement();
			if(statePageElement.isContainsPage())
			{
				pageElement = statePageElement;
			}
		}
		return pageElement;
	}

	/**
	 * Returns the current state page element, contains the page & his authorizations.
	 * @return PageElementAuthLevel
	 */
	public PageElementAuthLevel getCurrentStatePageElement()
	{
		return new PageElementAuthLevel(getAuthLevel(), false, currentState.getPage());
	}

	/**
	 * Returns the flow page element, contains the page & his authorizations.
	 * @return PageElementAuthLevel
	 */
	public PageElementAuthLevel getFlowPageElement()
	{
		return new PageElementAuthLevel(getFlowAuthLevel(), false, flowDefinition.getPage());
	}

	/**
	 * Check if the current state is of type complex & contains subflow to run.
	 * @return boolean
	 */
	public boolean isCurrentStateOfTypeSubFlow ()
	{
		return currentState.getType() == FlowState.STATE_TYPE_COMPLEX 
			&& ((ComplexFlowState)currentState).getSubFlowData() != null;		
	}
	
	/**
	 * Check if the current state is of type complex & contains page to display.
	 * @return boolean
	 */
	public boolean isCurrentStateOfTypePage ()
	{
		return currentState.getType() == FlowState.STATE_TYPE_COMPLEX 
			&& currentState.isStateContainsPage();		
	}

	/**
	 * Returns The flow path indicating the place of current flow in the flow hierarhy.
	 * @return String
	 */
	public String getFlowPathString()
	{
		return flowPathString;
	}

	/**
	 * Returns the current flow state.
	 * @return FlowState
	 */
	public FlowState getCurrentState()
	{
		return currentState;
	}

	/**
	 * Returns the context of the current state.
	 * @return Context 
	 */
	public Context getCurrentStateContext()
	{
		return currentStateContext;
	}

	/**
	 * indicates is the flow defined as independent. 
	 * (Topmost level of GUI presentation)
	 * @return boolean
	 */
	public boolean isIndependent()
	{
		return flowDefinition.isIndependent();
	}

	public String toString()
	{
		return "Flow name [" + flowDefinition.getName() + "] path [" + flowPathString + "]";
	}

	protected abstract ExtendedTransitionSupplier createGlobalTransitionSupplier();
	
	/**
	 * Indicates whether the type is menu.
	 * @return boolean
	 */
	public abstract boolean isMenuFlow ();


	/**
	 * Indicates whether the current flow is the main flow.
	 * @return boolean
	 */
	public boolean isMainFlow ()
	{
		return flowPathString.equals(FlowPath.MAIN_FLOW_ID);
	}

	/**
	 * Returns the sub flow that was opened when reached to the current state. 
	 * @return Flow
	 */
	private Flow getCurrentStateFlow()
	{
		return subFlowRegistry.getSubFlowByName(((ComplexFlowState)currentState).getSubFlowData().getFlowName());
	}

	/**
	 * Creates an ExtendedTransitionSupplierList according to the given transitionSupplierName.
	 * @param transitionSupplierName
	 * @param context
	 * @return ExtendedTransitionSupplierList
	 */
	private ExtendedTransitionSupplierList createExtendedTransitionSupplierList(List transitionSupplierNames, Context context)
	{
		
		if (transitionSupplierNames != null)
		{
			ExtendedTransitionSupplierList transitionSupplierList = new ExtendedTransitionSupplierList();
			ExtendedTransitionSupplierFactory factory = ExtendedTransitionSupplierFactory.getInstance();

			for(int i = 0 ; i < transitionSupplierNames.size() ; i++)
			{
				ExtendedTransitionSupplier supplier = factory.getTransitionSupplier((String)transitionSupplierNames.get(i));
				if(supplier != null)
				{
					transitionSupplierList.addExtendedTransitionSupplier(supplier);
				}
			}

			return transitionSupplierList;
		}

		return null;
	}

	/**
	 * called when desired that event is targeted to current flow
	 * @param event
	 */
	private ResultEvent processEventInternal(Event event) throws GuardException, ValidationException, ActionException, FlowElementsFactoryException, FlowException, ValidationProcessException, ContextException, FormatterException, ActivityException, ResourceException, FatalException, AuthorizationException
	{
		//if the arrived event is targeted to current state process it
        if (event.getFlowState() == null || currentState.getName().equals(event.getFlowState()))
        {
			return processEventForState(event);
        }
        //else if event arrived for state that is different from current but allow such event to state misscorresponding -
		//move to state that event arived for and process the event
		else
        {
	        FlowState tempState = flowDefinition.getFlowState(event.getFlowState());
	        if (tempState == null)
	        {
                throw new FlowException("Unable to process event[" + event.getEventName() + "] at flow [" + flowDefinition.getName() + "]. Wrong state [" + event.getFlowState() + " != " + currentState.getName() +"] and target state is not defined at flow. SessionId [" + dynamicGlobals.getSessionId() + "]");
	        }
	        else
	        {
		        if (tempState.isReachableByFlowOnly())
		        {
		            throw new FlowException("Unable to process event[" + event.getEventName() + "] at flow [" + flowDefinition.getName() + "]. Wrong state [" + event.getFlowState() + " != " + currentState.getName() +"] and target state is defined as reachable by flow only. SessionId [" + dynamicGlobals.getSessionId() + "]");
		        }
		        else
		        {
			        moveToState(event.getFlowState());
			        return processEventForState(event);
		        }
	        }
        }
	}

	/**
	 * Used to process event when the state is determined finally
	 * @param event
	 */
	public ResultEvent processEventForState(Event event) throws GuardException,  ActivityException, ValidationException, ActionException, FlowElementsFactoryException, FlowException, ValidationProcessException, ResourceException, ContextException, FormatterException, FatalException, AuthorizationException
	{
		// choose a transition
		Transition transition = chooseTransition(event);

		//if the default transition is null throw exception
		if (transition == null)
		{
			throw new FlowException("Unable to process event at flow [" + flowDefinition.getName() + "]. No transition found for event [" + event.getEventName() + "] at state [" + currentState.getName() + "]. SessionId [" + dynamicGlobals.getSessionId() + "]");
		}

		Logger.debug(LOGGER_CONTEXT, loggerContextExt + "Transition choosen [" + transition.toString() + "] at state [" + currentState.toString() + "] flow [" + this.toString() + "]");

		//create transition context - if defined specific one
		Context transitionContext = currentStateContext;
		if (transition.getContextName() != null)
		{
			//creating context for transition
			transitionContext = FlowElementsFactory.getInstance().createContext(transition.getContextName(), currentStateContext);
		}

		//formatting transition context (copy parameters from current state context to transition's context)
		if (transition.getInFormatter() != null)
		{
			transition.getInFormatter().format(currentStateContext,  transitionContext);
		}

		try
		{
			//filling parameters from event into context (HTML parameters)
			if(event.isContainsParameters())
			{
				EventParametersHandler.fillParametersToContext(transitionContext, event);
			}

//			//validating transition context
//			if (transition.getValidator() != null)
//			{
//				transition.getValidator().validate(transitionContext);
//			}

			// validating transition context
			validateTransition(transition, transitionContext);

			//performing transition actions
			performActions(transition.getActions(), transitionContext);

			//copying parameters from transition context to current state context (formatting)
			if (transition.getOutFormatter() != null)
			{
				transition.getOutFormatter().format(transitionContext, currentStateContext);
			}

			//destroy transition context
			if (transitionContext != currentStateContext)
			{
				transitionContext.destroy();
			}
		}
		catch (ValidationException ex)
		{
			Logger.debug(LOGGER_CONTEXT, loggerContextExt, ex);
			handleEventValidationException(transition, transitionContext, ex);
		}

		//if transition is not internal transition, moving to next state 
		// (even in case of self transition)
		if (!transition.isInternal())
		{
			moveToState(transition.getTargetState());
		}

		//if the transition contains sub flows declarations, run them now.
		if (transition.getSubFlowDataList() != null)
		{
			ResultEvent resultEvent = runSubFlow(transition, event);
			if (resultEvent.hasErrors() 
			|| currentState.getType() != FlowState.STATE_TYPE_COMPLEX
			|| currentState.isStateWaitingForEvent())
			{
				return resultEvent;
			}
		}

		if (currentState.getType() == FlowState.STATE_TYPE_COMPLEX)
		{
			if (!interactiveMode && !shouldPerformActivity() && !isCurrentStateOfTypeSubFlow())
			{
				throw new FlowException("Attempt to use state [" + currentState.getName() + "] of flow [" + flowDefinition.getName() + "] with no activity defined in non interactive mode. SessionId [" + dynamicGlobals.getSessionId() + "]");
			}

			if (shouldPerformActivity())
			{
				Activity activity = ((ComplexFlowState)currentState).getActivity();
				ActivityCompletionEvent activityCompletionEvent = activity.executeActivity(currentStateContext, getAuthLevel());
				return processEventForState(activityCompletionEvent);
			}

			if (isCurrentStateOfTypeSubFlow() && !transition.isInternal())
			{
				return runSubFlow();
			}
		}

		//if the state is simple, processing simple event (event name is null)
		else if (currentState.getType() == FlowState.STATE_TYPE_SIMPLE)
		{
			return processEventForState(new SimpleStateEvent());
		}
		//for final state processing ....
		else if (currentState.getType() == FlowState.STATE_TYPE_FINAL)
		{
			//executing current state exit actions
			try
			{
				performCurrentStateExitActions();
			}
			catch (ValidationException ex)
			{
				throw new FlowException("Validation exception is thrown. SessionId [" + dynamicGlobals.getSessionId() + "]", ex);
			}

			//formatting state context to flow context
			formatCurrentStateContextToFlowContext();

			//destroy current state context
			if (currentStateContext != flowContext)
			{
				currentStateContext.destroy();
			}

			//formatting flow context to parent flow context
			if (goodFinalStates != null && goodFinalStates.contains(currentState.getName()))
			{
				formatFlowContextToParentFlowContext();
			}

			//destroy flow context
			if (flowContext != parentFlowContext)
			{
				flowContext.destroy();
			}
		}

		return new ResultEvent();
	}

	/**
	 * Validate the transition with the Validator declaration & validation actions.
	 * @param transition
	 * @param transitionContext
	 * @throws ValidationProcessException
	 * @throws ActionException
	 * @throws ValidationException
	 */
	private void validateTransition (Transition transition, Context transitionContext) throws ValidationProcessException, ActionException, ValidationException
	{
		ValidationException validationException = null;
		
		//validating transition context by the validation declaration
		try
		{
			if (transition.getValidator() != null)
			{
				transition.getValidator().validate(transitionContext);
			}
		}
		catch (ValidationException e)
		{
			validationException = e;
		}
		
		//validating transition context by the validation actions declaration
		if(!(validationException != null && validationException.isSevereErrorFound()))
		{
			try
			{
				performValidationActions(transition.getValidationActions(), transitionContext);
			}
			catch (ValidationException e)
			{
				validationException = e;
			}
		}
		
		if(validationException != null)
		{
			throw validationException;
		}
		
	}

	/**
	 * Choose the transition according to the event.
	 * @param event 
	 * @return Transition
	 * @throws GuardException
	 */
	private Transition chooseTransition (Event event) throws GuardException
	{
		Transition transition = null;

		// lookup for list of transitions by event name
		TransitionList transitionList = currentState.getTransitions().getTransitionList(event.getEventName());

		if (transitionList != null)
		{
			//run on list of potential suitable transitions and checking 
			// their guard conditions
			transition = findTransitionInList(transitionList);
		}

		// look for menu transitions from state
		if (transition == null && isMenuFlow())
		{
			transition = getAuthLevelsManager().getMenuTransition(event.getEventName());
		}

		// look for extended transitions from state
		if (transition == null && stateTransitionSupplierList != null)
		{
			for (int i = 0; i < stateTransitionSupplierList.getExtendedTransitionSuppliersCount() && transition == null; i++)
			{
				transition = findTransitionInSupplier(stateTransitionSupplierList.getExtendedTransitionSupplier(i), event);
			}
		}

		//look for extended transitions from flow
		if (transition == null && flowTransitionSupplierList != null)
		{
			for (int i = 0; i < flowTransitionSupplierList.getExtendedTransitionSuppliersCount() && transition == null; i++)
			{
				transition = findTransitionInSupplier(flowTransitionSupplierList.getExtendedTransitionSupplier(i), event);
			}
		}

		//look for global extended transitions 
		if (transition == null && globalTransitionsuSupplier != null)
		{
			transition = findTransitionInSupplier(globalTransitionsuSupplier, event);
		}

		//if transition was not found, look for default transition
		if (transition == null)
		{
			transition = currentState.getDefaultTransition();
		}
		
		return transition;		
	}

	/**
	 * Handle the validation exception from event processing.
	 * @param transition
	 * @param transitionContext
	 * @param validationException
	 */
	private void handleEventValidationException (Transition transition, Context transitionContext, ValidationException validationException) throws ValidationException, ActionException, FlowElementsFactoryException, FlowException, ValidationProcessException, ContextException, FormatterException, ResourceException, FatalException, AuthorizationException
	{
		
		//performing transition ValidationException actions
		performActions(transition.getValidationExceptionActions(), transitionContext);
		
		// should move to the alternativeTargetState
		if (transition.getAlternativeTargetState() != null)
		{
			FlowState alternativeTargetState = flowDefinition.getFlowState(transition.getAlternativeTargetState());
			if (alternativeTargetState == null)
			{
				throw new FlowException("Unable to move to alternative state [" + transition.getAlternativeTargetState() + "]. No state with such name is found. SessionId [" + dynamicGlobals.getSessionId() + "]");
			}
			
			if (alternativeTargetState.getType() == FlowState.STATE_TYPE_COMPLEX)
			{
				// can move to alternativeTargetState only in non interactive mode 
				// or when the state contains page to display
				if (!interactiveMode || alternativeTargetState.isStateContainsPage())
				{
					moveToState(transition.getAlternativeTargetState());
				}
				else
				{
					throw new FlowException("Unable to move to alternative target state[" + alternativeTargetState.getName() + "]: " +
											"Alternative target state should have page defined if interactive mode is selected. SessionId [" + dynamicGlobals.getSessionId() + "]");
				}
			}
			else
			{
				throw new FlowException("Unable to move to alternative target state[" + alternativeTargetState.getName() + "]: " +
										"Alternative target state should be of complex type and if interactive mode is selected should have page defined. SessionId [" + dynamicGlobals.getSessionId() + "]");
			}
		}
		else if (isCurrentStateOfTypePage())
		{
			//do nothing
		}
		else if (isCurrentStateOfTypeSubFlow())
		{
			//do nothing
		}
		else if (!transition.isHandleValidationError())
		{
			throw new FlowException("ValidationException thrown and handleValidationError flag set to false. SessionId [" + dynamicGlobals.getSessionId() + "]", validationException);
		}
		else
		{
			// display the last shown page from the current flow
			if (lastPageState != null)
			{
				moveToState(lastPageState);
			}
		}

		throw validationException;
	}

	/**
	 * Find a match transition in the ExtendedTransitionSupplier.
	 * @param transitionSupplier
	 * @param event
	 * @return Transition
	 * @throws GuardException
	 */
	private Transition findTransitionInSupplier(ExtendedTransitionSupplier transitionSupplier, Event event) throws GuardException
	{
		TransitionList transitionList = transitionSupplier.getTransitionList(event.getEventName());

		if (transitionList != null)
		{
			return findTransitionInList(transitionList);
		}

		return null;
	}

	/**
	 * Find a match transition in the TransitionList.
	 * @param transitionList
	 * @return Transition
	 * @throws GuardException
	 */
	private Transition findTransitionInList(TransitionList transitionList) throws GuardException
	{
		for (int i = 0; i < transitionList.getTransitionsCount(); i++)
		{
			Transition tr = transitionList.getTransition(i);
			if (tr.getGuard() == null || tr.getGuard().check(currentStateContext))
			{
				//transition found
				return tr;
			}
		}

		return null;
	}

	/**
	 * Used to run the subflows on the transition.
	 * The subflows always running from current state context (not transition's context).
	 * @param transition
	 * @param event
	 * @return ResultEvent
	 */
	private ResultEvent runSubFlow(Transition transition, Event event) throws GuardException, ValidationException, ActionException, FlowElementsFactoryException, FlowException, ValidationProcessException, ContextException, FormatterException, ActivityException, ResourceException, FatalException, AuthorizationException
	{
		ResultEvent resultEvent = null;
		SubFlowDataList subFlowDataList = transition.getSubFlowDataList();
		if (subFlowDataList.getSubFlowDataCount() > 1 && transition.isTraverse())
		{
			throw new FlowException("Traversive transition can not contain more than one subflow. SessionId [" + dynamicGlobals.getSessionId() + "]");
		}

		for (int i = 0; i < subFlowDataList.getSubFlowDataCount(); i++)
		{
			resultEvent = runSubFlow(subFlowDataList.getSubFlowData(i), transition.isTraverse(), event);
			if (resultEvent.hasErrors())
			{
				return resultEvent;
			}
		}

		return resultEvent;
	}

	/**
	 * Used to run the subflow of the current state.
	 * @return ResultEvent
     */
	private ResultEvent runSubFlow() throws GuardException, ValidationException, ActionException, FlowElementsFactoryException, FlowException, ValidationProcessException, ContextException, FormatterException, ActivityException, ResourceException, FatalException, AuthorizationException
	{
		return runSubFlow(((ComplexFlowState)currentState).getSubFlowData(), false, null);
	}

	/**
	 * Used to run the a specific subflow.
	 * @param subFlowData
	 * @param traverse
	 * @param event
	 * @return ResultEvent
	 */
	private ResultEvent runSubFlow(SubFlowData subFlowData, boolean traverse, Event event) throws GuardException, ValidationException, ActionException, FlowElementsFactoryException, FlowException, ValidationProcessException, ContextException, FormatterException, ActivityException, ResourceException, FatalException, AuthorizationException
	{
		
		Logger.debug(LOGGER_CONTEXT, loggerContextExt + "run subFlow [" +  subFlowData.getFlowName() + "] under flow [" + flowDefinition.getName() + "]");
		
		//create flow instance
		Flow flow = FlowElementsFactory.getInstance().createFlow(subFlowData.getFlowName());

		//generating new flow id
		String flowId = String.valueOf(subFlowIdGenerator++);

		//registering newly created subflow in the fubflows map
		subFlowRegistry.registerFlow(flowId, flow);

		//initiating subflow
		ResultEvent resultEvent = flow.initiate(this, currentStateContext, flowPathString + FlowPath.FLOW_ID_LEVEL_DELIMITER + flowId, subFlowData, dynamicGlobals, interactiveMode);

		//checking is subflow is finished it's run (reached its final state)
		if (flow.getCurrentState().getType() == FlowState.STATE_TYPE_FINAL && (!resultEvent.hasErrors()))
		{
			//unregistering subflow from subflows map
			subFlowRegistry.unregisterFlow(flowId);

			//generation flow completion event
			FlowCompletionEvent flowCompletionEvent = new FlowCompletionEvent(flow.getCurrentState().getName());

			//processing flow completion event
			return processEventForState(flowCompletionEvent);
		}
		else
		{
			if (traverse)
			{
				flow.addAuthorizedEvent(event.getEventName(), "Traverse event from [" + flowDefinition.getName() + "] path [" + flowPathString + "]");
				return flow.processEvent(event);
			}

			return resultEvent;
		}
	}

	/**
	 * Used to execute the list of actions.
	 * @param actionsList
	 * @param context
	 */
	private void performActions(ActionList actionsList, Context context) throws ActionException, ValidationException
	{
		if (actionsList != null)
		{
			//run over list of actions and execute them
			for (int i = 0; i < actionsList.getActionsCount(); i++)
			{
				Action action = actionsList.getAction(i); 
				action.execute(context, getAuthLevel());
			}
		}
	}

	/**
	 * Used to execute the list of validation actions.
	 * @param actionsList
	 * @param context
	 */
	private void performValidationActions(ActionList actionsList, Context context) throws ActionException, ValidationException
	{
		ValidationException validationException = null;
		boolean stop = false;
		
		if (actionsList != null)
		{
			//run over list of actions and execute them
			for (int i = 0; i < actionsList.getActionsCount() && !stop ; i++)
			{
				Action action = actionsList.getAction(i); 
				try
				{
					action.execute(context, getAuthLevel());
				}
				catch (ValidationException e)
				{
					validationException = e;
					if(((ValidationOperationAction)action).isStopValidationOnError())
					{
						stop = true;
					}
				}
			}
		}
		
		if(validationException != null)
			throw validationException;
	}


	/**
	 * save the state of the last displayed page.
	 */
	private void setLastPageState()
	{
		if (currentState.isStateContainsPage() && interactiveMode)
		{
			lastPageState = currentState.getName();
		}
	}

	/**
	 * Used to change current state
	 * @param targetStateName
	 */
	private void moveToState(String targetStateName) throws ActionException, FlowElementsFactoryException, FlowException, ValidationProcessException, ResourceException, ContextException, FormatterException, FatalException, AuthorizationException
	{
		try
		{
			// check state authorization
			FlowState targetState = currentState;
			int targetStateAuthLevel = currentStateAuthLevel;
			if(targetStateName != null)
			{
				targetState = flowDefinition.getFlowState(targetStateName);
				if (targetState == null)
				{
					throw new FlowException("Unable to move to state [" + targetStateName + "]. No state with such name is found. SessionId [" + dynamicGlobals.getSessionId() + "]");
				}
			
				targetStateAuthLevel = getStateAuthLevel(targetState);
				if(targetStateAuthLevel == AuthLevelsManager.AUTH_LEVEL_NONE)
				{
					throw new FlowAuthorizationException("The state " + targetStateName + " in flow " + getName() + " is not authorized to perform the action. SessionId [" + dynamicGlobals.getSessionId() + "]");
				}
			}
			
			//executing current state exit actions
			performCurrentStateExitActions();

			//formatting state context to flow context
			formatCurrentStateContextToFlowContext();

			//clear the menu items & transitions that was added for the current state menu ids.
			clearStateMenuIds();

			//killing subflows
			killSubflows();
			
			//destroy current state context
			if (currentStateContext != flowContext)
			{
				currentStateContext.destroy();
			}

			//switching state
			currentState = targetState;
			currentStateAuthLevel = targetStateAuthLevel;

			// save last page of the flow from the state, if needed
			setLastPageState();

			//debug print
			Logger.debug(LOGGER_CONTEXT, loggerContextExt + "Moved to state [" + currentState.getName() + "] authorization level [" + currentStateAuthLevel + "]" );

			//creating context for current state
			createCurrentStateContext();

			//formatting flow context to current state context
			formatFlowContextToCurrentStateConetxt();

			//validating current context
			validateCurrentStateContext();

			//create state Transition Supplier
//			stateTransitionSupplierList = createExtendedTransitionSupplierList(currentState.getMenuIds(), currentStateContext);

			//execute current state entry actions
			performCurrentStateEntryActions();
			

		}
		catch (ValidationException ex)
		{
			throw new FlowException("Validation Exception is thrown. SessionId [" + dynamicGlobals.getSessionId() + "]", ex);
		}
	}

	/**
	 * Used to kill all sub flows instances that was opened inside the current flow.
	 */
	private void killSubflows() throws FormatterException, ContextException, FlowException, FatalException, AuthorizationException
	{
		Logger.debug(LOGGER_CONTEXT, loggerContextExt + "Kill sub flows at state [" + currentState.getName() + "]" );
		Iterator iterator = subFlowRegistry.getSubFlowIdsIterator();

		//run over map of subflows
		while (iterator.hasNext())
		{
			String flowId = (String) iterator.next();
			Flow subFlow = subFlowRegistry.getSubFlowById(flowId);

			//instructs the subflow to do the same
			subFlow.kill();
		}

		subFlowRegistry = new SubFlowRegistry();
	}

	private void formatFlowContextToParentFlowContext() throws ContextException, FormatterException, FatalException, AuthorizationException
	{
		if (parentFlowContext != null && outFormatter != null)
		{
			outFormatter.format(flowContext, parentFlowContext);
		}
	}

	private void formatFlowContextToCurrentStateConetxt() throws ContextException, FormatterException, FatalException, AuthorizationException
	{
		if (currentState.getContextName() != null && currentState.getInFormatter() != null)
		{
			currentState.getInFormatter().format(flowContext, currentStateContext);
		}
	}

	private void formatCurrentStateContextToFlowContext() throws ContextException, FormatterException, FatalException, AuthorizationException
	{
		if (currentState.getContextName() != null && currentState.getOutFormatter() != null)
		{
			currentState.getOutFormatter().format(currentStateContext, flowContext);
		}
	}

	private void performCurrentStateExitActions() throws ActionException, ValidationException
	{
		ActionList actionsList = currentState.getExitActions();
		performActions(actionsList, currentStateContext);
	}

	private void performCurrentStateEntryActions() throws ActionException, ValidationException
	{
		ActionList actionsList = currentState.getEntryActions();
		performActions(actionsList, currentStateContext);
	}


	/**
	 * Used to create flow's context
	 * @param parentContext The parent context to chain with the flow's context.
	 */
	private void createContext(Context parentContext) throws FlowElementsFactoryException, ValidationException, ValidationProcessException, ContextException, FormatterException, FatalException, AuthorizationException
	{
		//create new context instance
		if (flowDefinition.getContextName() != null)
		{
			flowContext = FlowElementsFactory.getInstance().createContext(flowDefinition.getContextName(), parentContext, dynamicGlobals);
		}
		else
		{
			flowContext = parentContext;
		}

		//perform formatting (copy parameters from parent flow's context to the flow context)
		if (inFormatter != null)
		{
			if (parentContext != null)
			{
				inFormatter.format(parentContext, flowContext);
			}
		}

		//validating context
		if (flowDefinition.getValidator() != null)
		{
			flowDefinition.getValidator().validate(flowContext);
		}
	}

	private void validateCurrentStateContext() throws ValidationException, ValidationProcessException
	{
		if (currentState.getValidator() != null)
		{
			currentState.getValidator().validate(currentStateContext);
		}
	}

	/**
	 * Used to create context for current state
	 */
	private void createCurrentStateContext() throws FlowElementsFactoryException
	{
		//if context is not defined for current state
        if(currentState.getContextName() == null)
        {
	        currentStateContext = flowContext;
        }
        //otherwise
		else
        {
	        //create new context instance
	        currentStateContext = FlowElementsFactory.getInstance().createContext(currentState.getContextName(), flowContext);
        }
	}

	/**
	 * sets the authorization level of the flow.
	 * @throws FlowAuthorizationException
	 * @throws ResourceException
	 */	
	private void setFlowAuthorizationLevel () throws FlowAuthorizationException, ResourceException
	{
		int parentAuthLevel = AuthLevelsManager.AUTH_LEVEL_NOT_INITIALIZED;
		if(flowDefinition.getAuthId() == null && parentFlow != null)
		{
			parentAuthLevel = parentFlow.getAuthLevel();
		}
		
		AuthLevelsManager authLevelsManager = getAuthLevelsManager();
		flowAuthLevel = authLevelsManager.determineFlowAuthLevel(flowDefinition.getAuthId(), parentAuthLevel, dynamicGlobals);
		
		Logger.debug(LOGGER_CONTEXT, loggerContextExt + "set authorization level [" + flowAuthLevel + "] to flow [" + flowDefinition.getName() + "] authId [" + flowDefinition.getAuthId() + "]");

		if(flowAuthLevel == AuthLevelsManager.AUTH_LEVEL_NONE)
		{
			throw new FlowAuthorizationException("The flow " + flowDefinition.getName() + " is not authorized to perform the action. SessionId [" + dynamicGlobals.getSessionId() + "]");
		}
	}

	private AuthLevelsManager getAuthLevelsManager()
	{
		return dynamicGlobals.getAuthLevelsManager();
	}

	/**
	 * Returns the authorization level of the given state. 
	 * @param state The {@link FlowState} to check.
	 * @return int The authorization level of the state. 
	 * @throws FlowAuthorizationException
	 * @throws ResourceException
	 */
	private int getStateAuthLevel (FlowState state) throws FlowAuthorizationException, ResourceException
	{
		AuthLevelsManager authLevelsManager = getAuthLevelsManager();
		int stateAuthLevel = authLevelsManager.determineFlowAuthLevel(state.getAuthId(), getFlowAuthLevel(), dynamicGlobals);
		
		Logger.debug(LOGGER_CONTEXT, loggerContextExt + "set authorization level [" + stateAuthLevel + "] to state [" + state.getName() + "] in flow [" + flowDefinition.getName() + "]");

		if(stateAuthLevel == AuthLevelsManager.AUTH_LEVEL_NONE)
		{
			throw new FlowAuthorizationException("The state [" + state.getName() + "] in flow [" + flowDefinition.getName() + "] is not authorized to perform the action. SessionId [" + dynamicGlobals.getSessionId() + "]");
		}
		return stateAuthLevel;
	}

	/**
	 * Returns the authorization level determined for the flow.
	 */
	public int getFlowAuthLevel()
	{
		return flowAuthLevel;
	}

	/**
	 * Returns the authorization level determined for the current state.
	 */
	public int getAuthLevel()
	{
		return currentStateAuthLevel;
	}

	/**
	 * Returns a list of visible {@link FlowState}s. 
	 * @return FlowStatesList
	 * @throws ResourceException
	 */
	public FlowStatesList getVisibleFlowStatesList() throws ResourceException
	{
		return flowDefinition.getVisibleFlowStatesList();
	}

	/**
	 * clears the authorized events of the flow.
	 */
	public void clearAuthorizedEvents ()
	{
		Logger.info(LOGGER_CONTEXT, loggerContextExt + "clear authorized events to flow [" + flowDefinition.getName() + "]");
		if(authorizedEvents != null)
		{
			authorizedEvents.clear();
		}
	}

	/**
	 * Check if the event is authorized for the flow.
	 * @param clickEventName The event name to check.
	 * @return boolean True if the event is authorized.
	 */
	public boolean isEventAuthorized (String eventName)
	{
		boolean authorized = false;
		if(authorizedEvents != null)
		{
			authorized = authorizedEvents.contains(eventName); 
		}
		
		if(!authorized && (isMenuFlow() || isMainFlow() ))
		{
			Transition transition = getAuthLevelsManager().getMenuTransition(eventName);
			if(transition != null)
			{
				authorized = true;
			}
		}
		return authorized;
	}

	/**
	 * Indicates whether the flow contains page
	 * @return boolean
	 */
	public boolean isContainsPage()
	{
		return flowDefinition.getPage() != null || isCurrentStateOfTypePage();
	}

	/**
	 * Indicates whether the current state is visible
	 * @return boolean
	 */
	public boolean isCurrentStateVisible()
	{
		return currentState.isVisible();
	}

	
	/**
	 * Add an event to the authorizedEvents list.
	 * @param eventName The event name to add.
	 * @param componentDescription The component that registers the event.
	 */
	public void addAuthorizedEvent(String eventName, String componentDescription)
	{
		if(authorizedEvents == null)
		{
			authorizedEvents = new ArrayList(1);
		}
		
		if(! authorizedEvents.contains(eventName))
		{
			authorizedEvents.add(eventName);
			Logger.info(LOGGER_CONTEXT, loggerContextExt + "add authorized event [" + eventName + "] from component [" + componentDescription + "] to flow [" + flowDefinition.getName() + "]" + " flow path  "+  flowPathString);
		}
	}

	/**
	 * remove the event from the authorizedEvents list.
	 * @param eventName The event name to add.
	 */
	public void removeAuthorizedEvent(String eventName)
	{
		if(authorizedEvents != null)
		{
			if(authorizedEvents.remove(eventName))
			{
				Logger.debug(LOGGER_CONTEXT, loggerContextExt + "remove authorized event [" + eventName + "] from flow [" + flowDefinition.getName() + "]" + " flow path  "+  flowPathString);
			}
		}
	}

	/**
	 * Returns the menu item list contains the menu tree of the current state,  
	 * from the flow hierarchy above and from all the subflows.
	 * @return MenuItemList
	 * @throws FlowerException
	 */
	public MenuItemList getMenuItemList () throws FlowerException
	{
		//Creates the MenuItemList with the menues of the current state
		handleStateMenuIds();
		return currentMenuItemList;
	}

	/**
	 * Creates the MenuItemList with the menus of the current state and the states above in the hierarchy.
	 * @throws FlowException
	 */
	private void handleStateMenuIds () throws FlowException  
	{ 
		currentMenuItemList = null;
		
		if(interactiveMode)
		{
			MenuIdList menuIdList = new MenuIdList();
	
			addParentMenuIds(menuIdList, false);
			addCurrentMenuIds(menuIdList);
			addChildrenMenuIds(menuIdList, false);
			
			MenuAuthManager menuAuthManager = 
				getAuthLevelsManager().getMenuAuthManager();
			
			MenuItem currentMenuItem;
			MenuItem child;
			String currentMenuId;
			String currentMenuIdFlowPath = null;
			
			Flow mainFlow = null;
			Flow menuFlow = null;
			if(menuIdList.size() > 0)
			{
				currentMenuItemList = new MenuItemList();
				
				mainFlow = getFirstFlow();
				menuFlow = getMenuFlow(mainFlow);
				
				if(menuFlow != null)
				{
					for(int i = 0 ; i < menuIdList.size() ; i++)
					{
						currentMenuId = menuIdList.getMenuId(i);
						currentMenuIdFlowPath = menuIdList.getMenuIdFlow(i).getFlowPathString();
						
						currentMenuItem = menuAuthManager.getMenuItem(currentMenuId);
						if(currentMenuItem != null)
						{
			 				// skip the first level, it is for dynamically managing the menu main level.
							if(currentMenuItem.hasChildren())
							{
								Iterator children = currentMenuItem.getChildren().values().iterator();
								while (children.hasNext())
								{
									child = (MenuItem)children.next();
									handleMenuItemEvent(child, mainFlow, menuFlow, currentMenuIdFlowPath);
									currentMenuItemList.addMenuItem(child, currentMenuIdFlowPath);
								}
							}
							else
							{
								handleMenuItemEvent(currentMenuItem, mainFlow, menuFlow, currentMenuIdFlowPath);
								currentMenuItemList.addMenuItem(currentMenuItem, currentMenuIdFlowPath);
							}
						}
						else
						{
							Logger.debug(LOGGER_CONTEXT, "menu id [" + currentMenuId + "] not found in menu auth manager.");
						}
					}
				}
			}
			Logger.debug(LOGGER_CONTEXT, "current MenuItemList is: " + (currentMenuItemList==null ? "empty" : currentMenuItemList.toString()) );
		}
	}

	private void handleMenuItemEvent(MenuItem menuItem, Flow mainFlow, Flow  menuFlow, String currentMenuIdFlowPath) throws FlowException
	{
		// set the event data in the menu item
		menuItem.setEventData(menuFlow.getFlowPathString(), menuFlow.getCurrentState().getName(), mainFlow.getFlowPathString(), mainFlow.getCurrentState().getName(), currentMenuIdFlowPath);
	}

	/**
	 * clear the menu items & transitions that was added for the current state menu ids.
	 * @throws FlowException
	 */
	private void clearStateMenuIds () throws FlowException  
	{
		currentMenuItemList = null;
	}
	
	/**
	 * Returns the menu flow from the current flow hierarchy.
	 * @param mainFlow
	 * @return Flow the menu flow
	 * @throws FlowerException
	 */
	private Flow getMenuFlow (Flow mainFlow) throws FlowException 
	{
		try
		{
			FlowPath flowPath = FlowPath.newInstance();
			flowPath.parseFlowIdString(getFlowPathString());
			// skip the path of the main flow
			flowPath.getNextLevel();
			
			Flow menuFlow = null;
			if(isMenuFlow())
			{
				menuFlow = this;
			}
			else
			{
				menuFlow = mainFlow.getMenuFlow(flowPath);
			}
			return menuFlow;
		} 
		catch (MalformedFlowIdException ex)
		{
			throw new FlowException("error parsing flow path [" + getFlowPathString() + "]. SessionId [" + dynamicGlobals.getSessionId() + "]", ex);
		}
	}

	/**
	 * Returns the menu flow from the current flow hierarchy.
	 * @param flowPath
	 * @return Flow the menu flow
	 * @throws FlowerException
	 */
	public Flow getMenuFlow (FlowPath flowPath)
	{
		Flow subFlow = getSubFlowById(flowPath.getNextLevel());
		if(subFlow != null)
		{
			if(subFlow.isMenuFlow())
			{
				return subFlow;
			}
			else
			{
				return subFlow.getMenuFlow(flowPath);
			}
		}
		return null;
	}

	/**
	 * Returns the first flow in the hierarchy.
	 * @return Flow
	 */
	public Flow getFirstFlow()
	{
		if(parentFlow != null)
		{
			return parentFlow.getFirstFlow();
		}
		else
		{
			return this;
		}
	}

	/**
	 * Creates the ButtonExtraDataList with the buttons of the current state and the states above & under in the hierarchy.
	 * @param groupId
	 * @throws FlowException
	 */
	public ButtonExtraDataList getButtonExtraDataList (String groupId) throws FlowException  
	{ 
		ButtonExtraDataList buttonExtraDataList = null;
		if(interactiveMode)
		{
			buttonExtraDataList = new ButtonExtraDataList();
	
			addChildrenButtons(groupId, buttonExtraDataList, false);
			addCurrentStateButtons(groupId, buttonExtraDataList);
		}
		return buttonExtraDataList;
	}
	
	private void addCurrentStateButtons (String groupId, ButtonExtraDataList buttonExtraDataList)
	{
		if (currentState.getType() == FlowState.STATE_TYPE_COMPLEX)
		{
			ButtonSet buttonSet = ((ComplexFlowState)currentState).getButtonSet(groupId);
			if (buttonSet != null && buttonSet.getCount() > 0)
			{
				PageElementAuthLevel pageElement = getCurrentStatePageElement();
				for (int index = 0 ; index < buttonSet.getCount() ; index++)
				{
					buttonExtraDataList.addButtonExtraData(new ButtonExtraData
						(buttonSet.getButtonData(index), pageElement, this));
				}
			}
		}
	}

	public void addChildrenButtons (String groupId, ButtonExtraDataList buttonExtraDataList, boolean addCurrent)
	{
		if(addCurrent)
		{
			addCurrentStateButtons(groupId, buttonExtraDataList);
		}
		
		Iterator iterator = getSubFlowIdsIterator();
		Flow subFlow;
		while (iterator.hasNext())
		{
			subFlow = getSubFlowById((String)iterator.next());
			subFlow.addChildrenButtons(groupId, buttonExtraDataList, true);
		}
	}


	/**
	 * Add the menu ids of the parent flow to the given list.
	 * add the menu ids of the current flow if argument "addCurrent" is set to true.
	 * @param menuList The menuList to add the menu items. 
	 * @param addCurrent Indicates whether to add the current flow menu ids or just 
	 * to call to the parent flow method.
	 */
	public void addParentMenuIds (MenuIdList menuIdList, boolean addCurrent)
	{
		if(parentFlow != null)
		{
			parentFlow.addParentMenuIds(menuIdList, true);
		}
		
		if(addCurrent)
		{
			addCurrentMenuIds(menuIdList);
		} 
	}

	/**
	 * Add the menu ids of the sub flows to the given list.
	 * add the menu ids of the current flow if argument "addCurrent" is set to true.
	 * @param menuList The menuList to add the menu items 
	 * @param addCurrent Indicates whether to add the current flow menu ids or just 
	 * to call to the child sub flows method.
	 */
	public void addChildrenMenuIds (MenuIdList menuIdList, boolean addCurrent)
	{
		if(addCurrent)
		{
			addCurrentMenuIds(menuIdList);
		}
		
		Iterator iterator = getSubFlowIdsIterator();
		Flow subFlow;
		while (iterator.hasNext())
		{
			subFlow = getSubFlowById((String)iterator.next());
			subFlow.addChildrenMenuIds(menuIdList, true);
		}
	}

	/**
	 * Add the menu ids of the current flow & state to the given list.
	 * @param menuList The menuList to add the menu items 
	 */
	private void addCurrentMenuIds (MenuIdList menuIdList)
	{
		menuIdList.add(currentState.getMenuIds(), this);
		menuIdList.add(flowDefinition.getMenuIds(), this);
	}

	/**
	 * A registry of the sub flows instances that was opened inside the current flow.
	 */
	private static class SubFlowRegistry
	{
		private HashMap subFlowMapById;
		private HashMap subFlowMapByName;

		public SubFlowRegistry()
		{
			subFlowMapById = new HashMap();
			subFlowMapByName = new HashMap();
		}

		public void registerFlow(String flowId, Flow flow)
		{
			subFlowMapById.put(flowId, flow);
			subFlowMapByName.put(flow.getName(), flow);
		}

		public void unregisterFlow(String flowId)
		{
			Flow flow = (Flow) subFlowMapById.remove(flowId);
			subFlowMapByName.remove(flow.getName());
		}

		public Flow getSubFlowById(String id)
		{
			return (Flow) subFlowMapById.get(id);
		}

		public Iterator getSubFlowIdsIterator()
		{
			return subFlowMapById.keySet().iterator();
		}

		public Iterator getHierarchySubFlowIdsIterator()
		{
			HashMap subFlowIdsWithoutIndependent = new HashMap();
			Iterator subFlowIdsIterator = getSubFlowIdsIterator();
		
			Flow subFlow;
			String flowId;
			while (subFlowIdsIterator.hasNext())
			{
				flowId = (String)subFlowIdsIterator.next();
				subFlow = getSubFlowById(flowId);
				if (!subFlow.isIndependent())
				{
					subFlowIdsWithoutIndependent.put(flowId, subFlow);
				}
			}
		
			return subFlowIdsWithoutIndependent.keySet().iterator();
		}

		public Flow getSubFlowByName(String name)
		{
			return (Flow) subFlowMapByName.get(name);
		}
		
	}

	
}
