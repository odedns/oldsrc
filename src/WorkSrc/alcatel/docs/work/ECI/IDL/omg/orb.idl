// File: orb.idl

#ifndef _ORB_IDL_
#define _ORB_IDL_

// @Copyright 1997 IONA Technologies, Plc. All Rights Reserved.
//

#pragma IT_SystemSpecification

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch -xAbstractInterfaces -xHelpers -xHolders"

#pragma IT_BeginCBESpecific AllJava                                     "@@\
@module CORBA=org.omg"

#pragma IT_CplusplusNoSystemIncludes

#pragma IT_BeginCBESpecific Cplusplus					"@@\
@include <orbix_sys/orb_base.h>						@@\
@include <orbix_sys/corba_it_mem_base.h>				@@\
@include <orbix_sys/corba_it_releaseable.h>"

//
// This file contains the IDL definition of the CORBA module,
// including many pseudo-interfaces that are part of the C++ mapping.
//

#pragma prefix "omg.org"

//
// These global definitions are needed so that the C++ types used to
// support all the CORBA types can use them. These are later
// typedef'ed into the CORBA module.
//
#pragma IT_BeginCBESpecific Cplusplus					"@@\
class IT_FWString;							@@\
typedef IT_Short	CORBA_Short;					@@\
typedef IT_Long		CORBA_Long;					@@\
typedef IT_UShort	CORBA_UShort;					@@\
typedef IT_ULong	CORBA_ULong;					@@\
typedef float		CORBA_Float;					@@\
typedef double		CORBA_Double;					@@\
typedef char		CORBA_Char;					@@\
typedef IT_Bool		CORBA_Boolean;					@@\
typedef IT_Octet	CORBA_Octet;					@@\
typedef IT_WChar	CORBA_WChar;					@@\
typedef IT_LongLong	CORBA_LongLong;					@@\
typedef IT_ULongLong	CORBA_ULongLong;				@@\
typedef IT_LongDouble	CORBA_LongDouble;				@@\
									@@\
struct IT_TC_Vtable;							@@\
typedef CORBA_ULong IT_TC_Kind;						@@\
									@@\
enum IT_MemPolicy { IT_SHALLOW_COPY, IT_DEEP_COPY, IT_ADOPT };		@@\
									@@\
@include <orbix_sys/string_support.h>					@@\
@include <orbix_sys/wstring_support.h>					@@\
@include <orbix_sys/sequence.h>						@@\
@include <orbix_sys/array_varT.h>					@@\
@include <it_dsa/fixed_point.h>"

module CORBA
{
#pragma IT_BeginCBESpecific Cplusplus					"@@\
@switch -xTypeCodes -xStreamables -xProxies -xAMICallbacks -xAnyFuncs -xDispatch"

#pragma IT_BeginCBESpecific POACxx					"@@\
@switch -xDispatch -xPOAInterfaces"

    interface TypeCode;

#pragma IT_BeginCBESpecific Cplusplus					"@@\
@switch +xTypeCodes +xStreamables +xProxies +xAMICallbacks +xAnyFuncs +xDispatch"

#pragma IT_BeginCBESpecific POACxx					"@@\
@switch +xDispatch +xPOAInterfaces"


    local interface NamedValue;
    local interface NVList;
    local interface Request;
    local interface ExceptionList;
    local interface ContextList;
    local interface ServerRequest;
    local interface ORB;

#ifdef _JAVA_  // Need a separate mechanisms for Java for now
    native IT_Context;
    native IT_ORB;
    native IT_InStream;
    native IT_OutStream;

#pragma IT_BeginNativeDecl IT_Context Java            "@@\
@declare org.omg.CORBA.Context"

#pragma IT_BeginNativeDecl IT_ORB Java            "@@\
@declare org.omg.CORBA.ORB"

#pragma IT_BeginNativeDecl IT_InStream Java            "@@\
@declare com.iona.corba.IT_CORBA.InStream"

#pragma IT_BeginNativeDecl IT_OutStream Java            "@@\
@declare com.iona.corba.IT_CORBA.OutStream"

#else
    local interface IT_ORB;
    local interface IT_ServerRequest;
    local interface IT_InStream;
    local interface IT_OutStream;
    local interface IT_Context;
#endif

#pragma IT_BeginCBESpecific Cplusplus					"@@\
@include <orbix_sys/basic_types.h>					@@\
									@@\
    class Any;"

#pragma prefix "iona.com/CORBA"

    // IT_Streamable internal native type
    //
    native IT_Streamable;
#pragma IT_BeginNativeDecl IT_Streamable Java            "@@\
@declare org.omg.CORBA.portable.Streamable"

#pragma IT_BeginNativeDecl IT_Streamable Cplusplus			"@@\
@in CORBA::IT_Streamable*						@@\
@inout CORBA::IT_Streamable*&						@@\
@out CORBA::IT_Streamable*&						@@\
@return CORBA::IT_Streamable*						@@\
                                                                        @@\
    class IT_ART_API IT_Streamable : public virtual CORBA_IT_MemBase	@@\
    {									@@\
      public:								@@\
	virtual ~IT_Streamable();					@@\
									@@\
	virtual void							@@\
	read(								@@\
	    IT_InStream_ptr is						@@\
	) = 0;								@@\
									@@\
	virtual void							@@\
	write(								@@\
	    IT_OutStream_ptr os						@@\
	) const = 0;							@@\
									@@\
	virtual TypeCode_ptr						@@\
	get_type_nc() const = 0;					@@\
									@@\
	virtual void							@@\
	set_type(							@@\
	    TypeCode_ptr tc						@@\
	) = 0;								@@\
									@@\
	virtual IT_ORB_ptr						@@\
	get_orb_nc() const = 0;						@@\
									@@\
	virtual void							@@\
	set_orb(							@@\
	    IT_ORB_ptr orb						@@\
	) = 0;								@@\
									@@\
	virtual IT_Bool							@@\
	can_share_arg() const = 0;					@@\
									@@\
	virtual void							@@\
	prepare_nonshareable_arg(					@@\
	    IT_OutStream_ptr os,					@@\
	    unsigned long    direction					@@\
	) = 0;								@@\
									@@\
	virtual void							@@\
	replace_nonshareable_arg(					@@\
	    IT_InStream_ptr is,						@@\
	    unsigned long   direction					@@\
	) = 0;								@@\
									@@\
	virtual IT_Streamable*						@@\
	clone(								@@\
	    TypeCode_ptr type = 0					@@\
	) const = 0;							@@\
									@@\
	virtual IT_InStream_ptr						@@\
	as_instream() = 0;						@@\
									@@\
	virtual IT_OutStream_ptr					@@\
	as_outstream() = 0;						@@\
									@@\
	ART_DECL_ABSTRACT_LOCAL_NARROW					@@\
									@@\
      protected:							@@\
	IT_Streamable() {}						@@\
									@@\
      private:								@@\
                                                                        @@\
        IT_DUMMY_DATA_MEMBER                                            @@\
                                                                        @@\
	// private and unimplemented to prevent copying			@@\
	IT_Streamable(const IT_Streamable&);				@@\
	void operator=(const IT_Streamable&);				@@\
    };"

#pragma IT_BeginCBESpecific Cplusplus					"@@\
@include <orbix_sys/streamables.h>"


#pragma prefix "omg.org/CORBA"

    // Types used by CORBA::Object
    //

    // from CORBA V2.1(Pre-release) June 1997 page 4-2
    //
    typedef unsigned long Flags;
    const Flags ARG_IN    = 1;
    const Flags ARG_OUT   = 2;
    const Flags ARG_INOUT = 3;
    const Flags CTX_RESTRICT_SCOPE = 15;

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch +xHelpers +xHolders"

    typedef unsigned long PolicyType;

    interface Policy;
    typedef sequence<Policy> PolicyList;

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch -xHelpers -xHolders"

    // from CORBA messaging draft
    //
    typedef sequence<PolicyType> PolicyTypeSeq;

    enum SetOverrideType
    {
	SET_OVERRIDE,
	ADD_OVERRIDE
    };

    interface InterfaceDef;

    // CORBA::Object definition
    //
#pragma IT_BeginCBESpecific Cplusplus					"@@\
									@@\
    class IT_ART_API Object : public virtual CORBA_IT_Releaseable	@@\
    {									@@\
      public:								@@\
	typedef Object_ptr _ptr_type;					@@\
	typedef Object_var _var_type;					@@\
									@@\
	virtual InterfaceDef_ptr					@@\
	_get_interface() = 0;						@@\
									@@\
	virtual void							@@\
	_create_request(						@@\
	    IT_Context_ptr ctx,						@@\
	    const char* operation,					@@\
	    NVList_ptr arg_list,					@@\
	    NamedValue_ptr result,					@@\
	    Request_out request,					@@\
	    Flags req_flags						@@\
	) = 0;								@@\
									@@\
	virtual void							@@\
	_create_request(						@@\
	    IT_Context_ptr ctx,						@@\
	    const char* operation,					@@\
	    NVList_ptr arg_list,					@@\
	    NamedValue_ptr result,					@@\
	    ExceptionList_ptr,						@@\
	    ContextList_ptr,						@@\
	    Request_out request,					@@\
	    Flags req_flags						@@\
	) = 0;								@@\
									@@\
	virtual Request_ptr						@@\
	_request(							@@\
	    const char* operation					@@\
	) = 0;								@@\
									@@\
	static Object_ptr						@@\
	_narrow(							@@\
	    Object_ptr obj						@@\
	);								@@\
									@@\
	static Object_ptr						@@\
	_duplicate(							@@\
	    Object_ptr obj						@@\
	);								@@\
									@@\
	static Object_ptr						@@\
	_nil();								@@\
									@@\
	virtual Boolean							@@\
	_is_a(								@@\
	    const char* logical_type_id					@@\
	) = 0;								@@\
									@@\
	virtual Boolean							@@\
	_non_existent() = 0;						@@\
									@@\
	virtual Boolean							@@\
	_is_equivalent(							@@\
	    Object_ptr other_object					@@\
	) = 0;								@@\
									@@\
	virtual ULong							@@\
	_hash(								@@\
	    ULong maximum						@@\
	) = 0;								@@\
									@@\
	// from CORBA Messaging draft 4/23/98 with updates:		@@\
	//								@@\
	virtual Policy_ptr						@@\
	_get_policy(							@@\
	    PolicyType type						@@\
	) = 0;								@@\
									@@\
	virtual Policy_ptr						@@\
	_get_client_policy(						@@\
	    PolicyType type						@@\
	) = 0;								@@\
									@@\
	virtual Object_ptr						@@\
	_set_policy_overrides(						@@\
	    const PolicyList &policies,					@@\
	    SetOverrideType set_add					@@\
	) = 0;			// REVISIT kukura 5/4/98: raises???	@@\
									@@\
	virtual PolicyList *						@@\
	_get_policy_overrides(						@@\
	    const PolicyTypeSeq & types					@@\
	) = 0;								@@\
									@@\
	virtual Boolean							@@\
	_validate_connection(						@@\
	    PolicyList &inconsistent_policies				@@\
	) = 0;								@@\
									@@\
	//								@@\
	// Non-CORBA-standard pseudo-operations.			@@\
	//								@@\
									@@\
	virtual IT_ORB_ptr						@@\
	_it_get_orb() = 0;						@@\
									@@\
	virtual IT_ORB_ptr						@@\
	_it_get_orb_nc() = 0;						@@\
									@@\
	virtual Object_ptr						@@\
	_it_proxy_for() = 0;						@@\
									@@\
	virtual void							@@\
	_it_marshal(							@@\
	    IT_OutStream_ptr os,					@@\
	    IT_ORB_ptr       orb					@@\
	) = 0;								@@\
									@@\
        virtual char*                                                   @@\
	_it_get_type_id() = 0;		       				@@\
									@@\
	virtual Object_ptr						@@\
	_it_unshare() = 0;						@@\
									@@\
	ART_DECL_LOCAL_NARROW						@@\
									@@\
      protected:							@@\
	void								@@\
	operator=(							@@\
	    const Object& orig						@@\
	);								@@\
									@@\
        virtual void          						@@\
        dummy_method(); // Workaround for vtbl bugs in Sun CC 4.2  	@@\
    };									@@\
									@@\
    IT_NAMESPACE_STATIC_INLINE void					@@\
    release(								@@\
	CORBA_IT_Releaseable* obj					@@\
    )									@@\
    {									@@\
	if (obj != 0)							@@\
	{								@@\
	    obj->_remove_ref();					        @@\
	}								@@\
    }									@@\
									@@\
    IT_NAMESPACE_STATIC_INLINE Boolean					@@\
    is_nil(								@@\
	const void* p							@@\
    )									@@\
    {									@@\
	return p == 0;							@@\
    }"
    
    // CORBA::LocalObject definitions
    //
    native LocalObject;

#pragma IT_BeginNativeDecl LocalObject Cplusplus			"@@\
@in CORBA::LocalObject*							@@\
@inout CORBA::LocalObject*&						@@\
@out CORBA::LocalObject*&						@@\
@return CORBA::LocalObject*						@@\
									@@\
    class IT_ART_API LocalObject : public virtual Object		@@\
    {									@@\
      public:								@@\
        LocalObject() {}                                                @@\
									@@\
	InterfaceDef_ptr					        @@\
	_get_interface();						@@\
									@@\
	void   							        @@\
	_create_request(						@@\
	    IT_Context_ptr ctx,						@@\
	    const char* operation,					@@\
	    NVList_ptr arg_list,					@@\
	    NamedValue_ptr result,					@@\
	    Request_out request,					@@\
	    Flags req_flags						@@\
	);								@@\
									@@\
	virtual void							@@\
	_create_request(						@@\
	    IT_Context_ptr ctx,						@@\
	    const char* operation,					@@\
	    NVList_ptr arg_list,					@@\
	    NamedValue_ptr result,					@@\
	    ExceptionList_ptr,						@@\
	    ContextList_ptr,						@@\
	    Request_out request,					@@\
	    Flags req_flags						@@\
	);								@@\
									@@\
	virtual Request_ptr						@@\
	_request(							@@\
	    const char* operation					@@\
	);								@@\
									@@\
	virtual Boolean							@@\
	_is_a(								@@\
	    const char* logical_type_id					@@\
	);								@@\
									@@\
	virtual Boolean							@@\
	_non_existent();						@@\
									@@\
	virtual Boolean							@@\
	_is_equivalent(							@@\
	    Object_ptr other_object					@@\
	);								@@\
									@@\
	virtual ULong							@@\
	_hash(								@@\
	    ULong maximum						@@\
	);								@@\
									@@\
	// from CORBA Messaging draft 4/23/98 with updates:		@@\
	//								@@\
	virtual Policy_ptr						@@\
	_get_policy(							@@\
	    PolicyType type						@@\
	);								@@\
									@@\
	virtual Policy_ptr						@@\
	_get_client_policy(						@@\
	    PolicyType type						@@\
	);								@@\
									@@\
	virtual Object_ptr						@@\
	_set_policy_overrides(						@@\
	    const PolicyList &policies,					@@\
	    SetOverrideType set_add					@@\
	);			// REVISIT kukura 5/4/98: raises???	@@\
									@@\
	virtual PolicyList *						@@\
	_get_policy_overrides(						@@\
	    const PolicyTypeSeq & types					@@\
	);								@@\
									@@\
	virtual Boolean							@@\
	_validate_connection(						@@\
	    PolicyList &inconsistent_policies				@@\
	);								@@\
									@@\
	virtual void							@@\
	_add_ref();						        @@\
									@@\
	virtual void							@@\
	_remove_ref();						        @@\
									@@\
	//								@@\
	// Non-CORBA-standard pseudo-operations.			@@\
	//								@@\
	virtual IT_ORB_ptr						@@\
	_it_get_orb();						        @@\
									@@\
	virtual IT_ORB_ptr						@@\
	_it_get_orb_nc();						@@\
									@@\
	virtual Object_ptr						@@\
	_it_proxy_for();						@@\
									@@\
	virtual void							@@\
	_it_marshal(							@@\
	    IT_OutStream_ptr os,					@@\
	    IT_ORB_ptr       orb					@@\
	);								@@\
									@@\
        virtual char*                                                   @@\
        _it_get_type_id();                                              @@\
									@@\
	Object_ptr							@@\
	_it_unshare();							@@\
									@@\
      private:                                                          @@\
	void								@@\
	operator=(							@@\
	    const LocalObject& orig					@@\
	);								@@\
									@@\
        LocalObject(                                                    @@\
	    const LocalObject& orig					@@\
	);								@@\
									@@\
    };									@@\
"

    //
    // C++ definition of ValueBase
    //

#pragma IT_BeginCBESpecific Cplusplus				       "@@\
    class IT_ART_API ValueBase : public virtual CORBA_IT_Releaseable	@@\
    {									@@\
      public:								@@\
	virtual void						        @@\
	_add_ref() = 0;							@@\
									@@\
	virtual void							@@\
	_remove_ref() = 0;						@@\
									@@\
	virtual ValueBase*						@@\
	_copy_value() = 0;						@@\
									@@\
	virtual ULong							@@\
	_refcount_value() = 0;						@@\
									@@\
	static ValueBase*						@@\
	_downcast(							@@\
	    ValueBase*							@@\
	);								@@\
									@@\
	//								@@\
	// Responsible for reading/writing the value			@@\
	// members to a stream						@@\
	//								@@\
	virtual void							@@\
	_it_marshal_value(						@@\
	    IT_OutStream_ptr os,					@@\
	    IT_ORB_ptr orb						@@\
	) = 0;								@@\
									@@\
	virtual void							@@\
	_it_demarshal_value(						@@\
	    IT_InStream_ptr is,						@@\
	    IT_ORB_ptr orb						@@\
	) = 0;								@@\
									@@\
	virtual const char**						@@\
	_it_get_safe_bases() const = 0;					@@\
									@@\
	virtual TypeCode_ptr						@@\
	_it_type() const = 0;						@@\
									@@\
	ART_DECL_LOCAL_NARROW						@@\
									@@\
      protected:							@@\
	ValueBase();							@@\
	ValueBase(							@@\
	    const ValueBase&						@@\
	);								@@\
	virtual ~ValueBase();						@@\
									@@\
	static const IT_FWString&					@@\
	_it_get_fw_type_id();						@@\
									@@\
      private:								@@\
	void operator=(const ValueBase&);				@@\
    };									@@\
									@@\
    IT_NAMESPACE_STATIC_INLINE void					@@\
    add_ref(								@@\
	ValueBase* vb							@@\
    )									@@\
    {									@@\
	if (vb != 0)							@@\
	{								@@\
	    vb->_add_ref();						@@\
	}								@@\
    }									@@\
									@@\
    IT_NAMESPACE_STATIC_INLINE void					@@\
    remove_ref(								@@\
	ValueBase* vb							@@\
    )									@@\
    {									@@\
	if (vb != 0)							@@\
	{								@@\
	    vb->_remove_ref();						@@\
	}								@@\
    }									@@\
									@@\
    // Mixin for providing reference counting to the ValueBase		@@\
    //									@@\
    class IT_ART_API DefaultValueRefCountBase : public virtual ValueBase @@\
    {									@@\
      public:								@@\
	virtual void _add_ref();					@@\
	virtual void _remove_ref();					@@\
	virtual ULong _refcount_value();				@@\
									@@\
      protected:							@@\
	DefaultValueRefCountBase();					@@\
	DefaultValueRefCountBase(const DefaultValueRefCountBase& vb);	@@\
	virtual ~DefaultValueRefCountBase();				@@\
									@@\
      private:								@@\
	ULong m_refcount;						@@\
    };"

    native ValueFactory;

#pragma IT_BeginNativeDecl ValueFactory Cplusplus			"@@\
@in CORBA::ValueFactory							@@\
@out CORBA::ValueFactory&						@@\
@inout CORBA::ValueFactory&						@@\
@return CORBA::ValueFactory						@@\
									@@\
    class IT_ART_API ValueFactoryBase;					@@\
    typedef ValueFactoryBase* ValueFactory;				@@\
									@@\
    class IT_ART_API ValueFactoryBase : public CORBA_IT_MemBase		@@\
    {									@@\
      public:								@@\
	virtual ~ValueFactoryBase();					@@\
	static ValueFactory _downcast(ValueFactory vf);			@@\
									@@\
	virtual void _add_ref();					@@\
	virtual void _remove_ref();					@@\
									@@\
	ART_DECL_LOCAL_NARROW						@@\
	ValueBase* _it_create_for_unmarshal();				@@\
									@@\
      protected:							@@\
	ValueFactoryBase();						@@\
									@@\
      private:								@@\
	virtual ValueBase*						@@\
	create_for_unmarshal() = 0;					@@\
	friend class IT_InStream;					@@\
	CORBA::ULong m_refcount;					@@\
    };									@@\
    typedef IT_Cxx_SimpleVarT<ValueFactoryBase> ValueFactoryBase_var;"

    //
    // C++ definition of AbstractBase
    //

#pragma IT_BeginCBESpecific Cplusplus				       "@@\
                                                                        @@\
    class IT_ART_API AbstractBase : public virtual CORBA_IT_Releaseable	@@\
    {									@@\
      public:								@@\
	typedef AbstractBase_ptr _ptr_type;				@@\
	typedef AbstractBase_var _var_type;				@@\
									@@\
	static AbstractBase_ptr						@@\
	_duplicate(							@@\
            AbstractBase_ptr p						@@\
        );								@@\
									@@\
	static AbstractBase_ptr						@@\
	_narrow(							@@\
            AbstractBase_ptr p						@@\
        );								@@\
									@@\
	static AbstractBase_ptr						@@\
	_nil();								@@\
									@@\
	Object_ptr							@@\
	_to_object();							@@\
									@@\
	ValueBase*							@@\
	_to_value();							@@\
									@@\
	ART_DECL_LOCAL_NARROW						@@\
									@@\
      protected:							@@\
	AbstractBase();							@@\
	AbstractBase(							@@\
	    const AbstractBase&						@@\
	);								@@\
	virtual ~AbstractBase();					@@\
									@@\
	static const IT_FWString&					@@\
	_it_get_fw_type_id();						@@\
									@@\
      private:								@@\
	void operator=(const AbstractBase&);				@@\
    };"

    //
    // C++ definition of Any
    //

#pragma IT_BeginCBESpecific Cplusplus					"@@\
									@@\
    class IT_ART_API Any : public CORBA_IT_MemBase		       	@@\
    {									@@\
      public:								@@\
	Any();								@@\
	Any(								@@\
	    const Any& any						@@\
	);								@@\
	Any(								@@\
	    TypeCode_ptr tc,						@@\
	    void*        value,						@@\
	    Boolean      release = 0					@@\
	);								@@\
        Any(								@@\
	    IT_Streamable* strm,					@@\
	    IT_MemPolicy   policy					@@\
        );								@@\
	~Any();								@@\
									@@\
	Any&								@@\
	operator=(							@@\
	    const Any&							@@\
	);								@@\
									@@\
	//								@@\
	// type-unsafe operations					@@\
	//								@@\
	void								@@\
	replace(							@@\
	    TypeCode_ptr tc,						@@\
	    void*        value,						@@\
	    Boolean      release = 0					@@\
	);								@@\
									@@\
	TypeCode_ptr							@@\
	type() const;							@@\
									@@\
	void								@@\
	type(								@@\
	    TypeCode_ptr new_type					@@\
	);								@@\
									@@\
	const void*							@@\
	value() const;							@@\
									@@\
	struct from_boolean						@@\
	{								@@\
	    from_boolean(						@@\
		Boolean b						@@\
	    );								@@\
	    Boolean m_val;						@@\
	};								@@\
									@@\
	struct from_octet						@@\
	{								@@\
	    from_octet(							@@\
		Octet octet						@@\
	    );								@@\
	    Octet m_val;						@@\
	};								@@\
									@@\
	struct from_char						@@\
	{								@@\
	    from_char(							@@\
		Char c							@@\
	    );								@@\
	    Char m_val;							@@\
	};								@@\
									@@\
	struct from_wchar						@@\
	{								@@\
	    from_wchar(							@@\
		WChar c							@@\
	    );								@@\
	    WChar m_val;						@@\
	};								@@\
									@@\
	struct from_string						@@\
	{								@@\
	    from_string(						@@\
		char* s,						@@\
		ULong b,						@@\
		Boolean nocopy = 0					@@\
	    );								@@\
	    from_string(						@@\
		const char* s,						@@\
		ULong b							@@\
	    );								@@\
	    char* m_val;						@@\
	    ULong m_bound;						@@\
	    Boolean m_nocopy;						@@\
	};								@@\
									@@\
	struct from_wstring						@@\
	{								@@\
	    from_wstring(						@@\
		WChar* s,						@@\
		ULong b,						@@\
		Boolean nocopy = 0					@@\
	    );								@@\
	    from_wstring(						@@\
		const WChar* s,						@@\
		ULong b							@@\
	    );								@@\
	    WChar* m_val;						@@\
	    ULong m_bound;						@@\
	    Boolean m_nocopy;						@@\
	};								@@\
									@@\
	struct from_fixed						@@\
	{								@@\
	    from_fixed(							@@\
		const Fixed& f,						@@\
		UShort digits,						@@\
		Short scale						@@\
	    );								@@\
	    const Fixed& m_val;						@@\
	    UShort m_digits;						@@\
	    Short m_scale;						@@\
	};								@@\
									@@\
	struct to_boolean						@@\
	{								@@\
	    to_boolean(							@@\
		Boolean& b						@@\
	    );								@@\
	    Boolean& m_ref;						@@\
	};								@@\
									@@\
	struct to_char							@@\
	{								@@\
	    to_char(							@@\
		Char& c							@@\
	    );								@@\
	    Char& m_ref;						@@\
	};								@@\
									@@\
	struct to_wchar							@@\
	{								@@\
	    to_wchar(							@@\
		WChar& c						@@\
	    );								@@\
	    WChar& m_ref;						@@\
	};								@@\
									@@\
	struct to_octet							@@\
	{								@@\
	    to_octet(							@@\
		Octet& o						@@\
	    );								@@\
	    Octet& m_ref;						@@\
	};								@@\
									@@\
	struct to_object						@@\
	{								@@\
	    to_object(							@@\
		Object_ptr& obj						@@\
	    );								@@\
	    Object_ptr& m_ref;						@@\
	};								@@\
									@@\
	struct to_abstract_base						@@\
	{								@@\
	    to_abstract_base(						@@\
		AbstractBase_ptr& obj					@@\
	    );								@@\
	    AbstractBase_ptr& m_ref;					@@\
	};								@@\
									@@\
	struct to_value							@@\
	{								@@\
	    to_value(							@@\
		ValueBase*& base					@@\
	    );								@@\
	    ValueBase*& m_ref;						@@\
	};								@@\
									@@\
	struct to_string						@@\
	{								@@\
	    to_string(							@@\
		const char*& s,						@@\
		ULong  b						@@\
	    );								@@\
	    to_string(							@@\
		char*& s,						@@\
		ULong  b						@@\
	    );								@@\
	    const char*& m_ref;						@@\
	    ULong  m_bound;						@@\
	};								@@\
									@@\
	struct to_wstring						@@\
	{								@@\
	    to_wstring(							@@\
		const WChar*& s,					@@\
		ULong  b						@@\
	    );								@@\
	    to_wstring(							@@\
		WChar*& s,						@@\
		ULong  b						@@\
	    );								@@\
	    const WChar*& m_ref;					@@\
	    ULong  m_bound;						@@\
	};								@@\
									@@\
	struct to_fixed							@@\
	{								@@\
	    to_fixed(							@@\
		Fixed& f,						@@\
		UShort digits,						@@\
		Short scale						@@\
	    );								@@\
	    Fixed& m_ref;						@@\
	    UShort m_digits;						@@\
	    Short m_scale;						@@\
	};								@@\
									@@\
	IT_Streamable*							@@\
	it_get_streamable(						@@\
	    Boolean make_copy = 0					@@\
	) const;							@@\
									@@\
	Boolean								@@\
	it_take_streamable(						@@\
	    IT_Streamable* &strm					@@\
	);								@@\
									@@\
	void								@@\
	it_set_streamable(						@@\
	    IT_Streamable* strm,					@@\
	    IT_MemPolicy   policy					@@\
	);								@@\
									@@\
      private:								@@\
	IT_Streamable* m_body;						@@\
	IT_MemPolicy   m_policy;					@@\
	IT_Bool	       m_is_void;					@@\
									@@\
									@@\
	//								@@\
	// As required by the OMG C++ language mapping, these are       @@\
	// hidden and should not be implemented so as to catch		@@\
	// erroneous attempts to insert or extract multiple IDL types   @@\
	// mapped to unsigned char.					@@\
	//								@@\
	void operator<<=(unsigned char);				@@\
	Boolean operator>>=(unsigned char&) const;			@@\
									@@\
	//								@@\
	// Hide the following to prevent illegal _var extraction.	@@\
	//								@@\
	Boolean operator>>=(const IT_Cxx_Auto&) const;			@@\
	Boolean operator>>=(const CORBA_String_var&) const;		@@\
	Boolean operator>>=(const CORBA_IT_Cxx_String_mgr&) const;	@@\
	Boolean operator>>=(const IT_Cxx_String_se&) const;		@@\
	Boolean operator>>=(const IT_Cxx_ConstString_se&) const;	@@\
	Boolean operator>>=(const CORBA_WString_var&) const;		@@\
	Boolean operator>>=(const CORBA_IT_Cxx_WString_mgr&) const;	@@\
	Boolean operator>>=(const IT_Cxx_WString_se&) const;		@@\
	Boolean operator>>=(const IT_Cxx_ConstWString_se&) const;	@@\
    };									@@\
									@@\
    typedef IT_Cxx_VarLenConstr_var<Any> Any_var;			@@\
    typedef IT_Cxx_VarLenConstr_out<Any> Any_out;"

    //
    // IDL-defined basic type (deprecated).
    //
    typedef sequence<octet> Principal;

    //
    // common definitions
    //

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch +xHelpers +xHolders"

    typedef string Identifier;
    typedef string ScopedName;
    typedef string RepositoryId;

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch -xHelpers -xHolders"

    //
    // CORBA exception types
    //
    enum completion_status
    {
	COMPLETED_YES,
	COMPLETED_NO,
	COMPLETED_MAYBE
    };

    enum exception_type
    {
	NO_EXCEPTION,
	USER_EXCEPTION,
	SYSTEM_EXCEPTION
    };

    // From CORBA 2.3 Objects By Value specification

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch +xHelpers +xHolders"

    typedef short Visibility;
    const Visibility PRIVATE_MEMBER = 0;
    const Visibility PUBLIC_MEMBER  = 1;

    typedef short ValueModifier;
    const ValueModifier VM_NONE        = 0;
    const ValueModifier VM_CUSTOM      = 1;
    const ValueModifier VM_ABSTRACT    = 2;
    const ValueModifier VM_TRUNCATABLE = 3;

    //
    // Include C++ definitions for system and user exceptions.
    //
#pragma IT_BeginCBESpecific Cplusplus					"@@\
    typedef completion_status CompletionStatus;				@@\
@include <orbix_sys/exception.h>"

    exception Bounds {};

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch -xHelpers -xHolders"

    //
    // the Environment pseudo-interface
    //
    //
    // from ORB Portability Joint Submission 97-05-15 page 17-4
    //
    //    interface Environment
    //    {
    //        attribute exception exception;
    //        void clear();
    //    };
    //
    // can't use IDL for the attribute because exception is a keyword
    //

    local interface Environment;

#ifndef _JAVA_

    local interface Environment
    {
#pragma IT_BeginCBESpecific Cplusplus					"@@\
	virtual void							@@\
	exception(							@@\
	    Exception*							@@\
	) = 0;								@@\
									@@\
	virtual Exception*						@@\
	exception() const = 0;"

	void clear();
    };

#endif // _JAVA_

    //
    // the NVList pseudo-interface
    //

    // from ORB Portability Joint Submission 97-05-15 page 17-5

    local interface NamedValue
    {
	readonly attribute Identifier name;
#pragma IT_BeginNodeSpecific name Cplusplus				"@@\
@const_member_func							@@\
@return_type const char*"

	readonly attribute any value;
#pragma IT_BeginNodeSpecific value Cplusplus				"@@\
@const_member_func"

	readonly attribute CORBA::Flags flags;
#pragma IT_BeginNodeSpecific flags Cplusplus				"@@\
@const_member_func"
    };

    // from ORB Portability Joint Submission 97-05-15 page 17-6

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch +xHolders +xHelpers"

    local interface NVList
    {
	readonly attribute unsigned long count;
#pragma IT_BeginNodeSpecific count Cplusplus				"@@\
@const_member_func"

	NamedValue
	add(
	    in Flags flgs
	);

	NamedValue
	add_item(
	    in Identifier item_name,
	    in Flags flgs
	);

	NamedValue
	add_value(
	    in Identifier item_name,
	    in any val,
	    in Flags flgs
	);

	NamedValue
	item(
	    in unsigned long index
	) raises (Bounds);

	void
	remove(
	    in unsigned long index
	) raises (Bounds);

#pragma IT_BeginCBESpecific Cplusplus					"@@\
	virtual NamedValue_ptr						@@\
	add_item_consume(						@@\
	    char*,							@@\
	    Flags							@@\
	) = 0;								@@\
									@@\
	virtual NamedValue_ptr						@@\
	add_value_consume(						@@\
	    char*,							@@\
	    Any*,							@@\
	    Flags							@@\
	) = 0;"
    };

    //
    // the Context pseudo-interface
    //

    // from ORB Portability Joint Submission 97-05-15 page 17-12

    // renamed to IT_Context to avoid IDL keyword

#ifndef _JAVA_  // Need a separate mechanisms for Java for now
    local interface IT_Context
    {
	readonly attribute Identifier context_name;
#pragma IT_BeginNodeSpecific context_name Cplusplus			"@@\
@const_member_func							@@\
@return_type const char*"

	readonly attribute IT_Context parent;
#pragma IT_BeginNodeSpecific parent Cplusplus				"@@\
@const_member_func"

	void
	create_child(
	    in Identifier child_ctx_name,
	    out IT_Context child_ctx
	);

	void
	set_one_value(
	    in Identifier propname,
	    in any propvalue
	);

	void
	set_values(
	    in NVList values
	);

	void
	delete_values(
	    in Identifier propname
	);

	void
	get_values(
	    in Identifier start_scope,
	    in Flags op_flags,
	    in Identifier pattern,
	    out NVList values
	);
    };
#endif

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch -xHolders -xHelpers"

#pragma IT_BeginCBESpecific Cplusplus					"@@\
    typedef IT_Context Context;						@@\
    typedef IT_Context_ptr Context_ptr;					@@\
    typedef IT_Context_var Context_var;					@@\
    typedef IT_Context_out Context_out;"

    enum TCKind
    {
	tk_null, tk_void,
	tk_short, tk_long, tk_ushort, tk_ulong,
	tk_float, tk_double, tk_boolean, tk_char,
	tk_octet, tk_any, tk_TypeCode, tk_Principal, tk_objref,
	tk_struct, tk_union, tk_enum, tk_string,
	tk_sequence, tk_array, tk_alias, tk_except,
	tk_longlong, tk_ulonglong, tk_longdouble,
	tk_wchar, tk_wstring, tk_fixed,
	tk_value, tk_value_box,
	tk_native,
	tk_abstract_interface
    };

    //
    // the TypeCode transmissible pseudo-interface
    //

#pragma IT_BeginCBESpecific Cplusplus					"@@\
@switch -xTypeCodes -xStreamables -xProxies -xAMICallbacks -xAnyFuncs -xDispatch"

#pragma IT_BeginCBESpecific POACxx					"@@\
@switch -xDispatch -xPOAInterfaces"

#pragma IT_BeginCBESpecific AllJava                                        "@@\
@switch -xSuppressCodeGeneration "

    interface TypeCode
    {
#pragma IT_BeginCBESpecific Cplusplus					"@@\
@switch +xTypeCodes +xStreamables"

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch +xHelpers +xHolders"

	exception Bounds {};
	exception BadKind {};

	// for all TypeCode kinds

	boolean
	equal(
	    in TypeCode tc
	);

	boolean
	equivalent(
	    in TypeCode tc
	);

	TCKind
	kind();

	TypeCode
	get_compact_typecode();

	// for tk_objref, tk_struct, tk_union, tk_enum, tk_alias,
	// tk_except, tk_value, and tk_value_box

	RepositoryId
	id() raises (BadKind);

	Identifier
	name() raises (BadKind);

	// for tk_struct, tk_union, tk_enum, tk_except, and tk_value

	unsigned long
	member_count() raises (BadKind);

	Identifier
	member_name(
	    in unsigned long index
	) raises (BadKind, Bounds);

	// for tk_struct, tk_union, tk_except, and tk_value

	TypeCode
	member_type(
	    in unsigned long index
	) raises (BadKind, Bounds);

	// for tk_union

	any
	member_label(
	    in unsigned long index
	) raises (BadKind, Bounds);

	TypeCode
	discriminator_type() raises (BadKind);

	long
	default_index() raises (BadKind);

	// for tk_string, tk_sequence, and tk_array

	unsigned long
	length() raises (BadKind);

	// for tk_sequence, tk_array, and tk_alias

	TypeCode
	content_type() raises (BadKind);

	// for tk_fixed

	unsigned short
	fixed_digits() raises(BadKind);

	short
	fixed_scale() raises(BadKind);

	// for tk_value

	ValueModifier
	type_modifier() raises(BadKind);

	TypeCode
	concrete_base_type() raises(BadKind);

	Visibility
	member_visibility(
	    in unsigned long index
	) raises(BadKind, Bounds);

#pragma IT_BeginCBESpecific Cplusplus					"@@\
@switch -xTypeCodes -xStreamables"

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch -xHelpers -xHolders"
    };

#pragma IT_BeginCBESpecific AllJava                                        "@@\
@switch +xSuppressCodeGeneration "


#pragma IT_BeginCBESpecific Cplusplus					"@@\
@switch +xTypeCodes +xStreamables +xProxies +xAMICallbacks +xAnyFuncs +xDispatch"

#pragma IT_BeginCBESpecific POACxx					"@@\
@switch +xDispatch +xPOAInterfaces"

#pragma IT_BeginNodeSpecific TypeCode Cplusplus				"@@\
@no_interface_class"

#pragma IT_BeginCBESpecific Cplusplus					"@@\
									@@\
    class IT_ART_API TypeCode						@@\
    {									@@\
      public:								@@\
	typedef TypeCode_ptr _ptr_type;					@@\
	typedef TypeCode_var _var_type;					@@\
									@@\
	static TypeCode_ptr						@@\
	_duplicate(							@@\
	    TypeCode_ptr tc						@@\
	);								@@\
									@@\
	static TypeCode_ptr						@@\
	_nil();								@@\
									@@\
	class IT_ART_API Bounds : public UserException			@@\
	{								@@\
	  public:							@@\
	    Bounds();							@@\
	    ~Bounds();							@@\
									@@\
	    void							@@\
	    operator=(							@@\
		const Bounds&						@@\
	    );								@@\
									@@\
	    ART_DECL_LOCAL_NARROW					@@\
									@@\
	    static Bounds*						@@\
	    _downcast(							@@\
		Exception* exc						@@\
	    );								@@\
	    static const Bounds*					@@\
	    _downcast(							@@\
		const Exception* exc					@@\
	    );								@@\
									@@\
	    static Bounds*						@@\
	    _narrow(							@@\
		Exception* exc						@@\
	    );								@@\
	    static const Bounds*					@@\
	    _narrow(							@@\
		const Exception* exc					@@\
	    );								@@\
									@@\
	    virtual void						@@\
	    _raise() const;						@@\
									@@\
	    virtual TypeCode_ptr					@@\
	    _it_get_typecode() const;					@@\
									@@\
	    virtual Exception*						@@\
	    _it_copy() const;						@@\
									@@\
	    virtual void						@@\
	    _it_insert(							@@\
		Any&	any,						@@\
		Boolean consume						@@\
	    );								@@\
	};								@@\
	static IT_TYPECODE_CONST CORBA::TypeCode_ptr _tc_Bounds;       	@@\
									@@\
	class IT_ART_API BadKind : public UserException			@@\
	{								@@\
	  public:							@@\
	    BadKind();							@@\
	    ~BadKind();							@@\
									@@\
	    void							@@\
	    operator=(							@@\
		const BadKind&						@@\
	    );								@@\
									@@\
	    ART_DECL_LOCAL_NARROW					@@\
									@@\
	    static BadKind*						@@\
	    _downcast(							@@\
		Exception* exc						@@\
	    );								@@\
	    static const BadKind*					@@\
	    _downcast(							@@\
		const Exception* exc					@@\
	    );								@@\
									@@\
	    static BadKind*						@@\
	    _narrow(							@@\
		Exception* exc						@@\
	    );								@@\
	    static const BadKind*					@@\
	    _narrow(							@@\
		const Exception* exc					@@\
	    );								@@\
									@@\
	    virtual void						@@\
	    _raise() const;						@@\
									@@\
	    virtual TypeCode_ptr					@@\
	    _it_get_typecode() const;					@@\
									@@\
	    virtual Exception*						@@\
	    _it_copy() const;						@@\
									@@\
	    virtual void						@@\
	    _it_insert(							@@\
		Any&	any,						@@\
		Boolean consume						@@\
	    );								@@\
	};								@@\
	static IT_TYPECODE_CONST CORBA::TypeCode_ptr _tc_BadKind;      	@@\
									@@\
	Boolean								@@\
	equal(								@@\
	    TypeCode_ptr tc						@@\
	) const IT_THROW_DECL((SystemException));			@@\
									@@\
	Boolean								@@\
	equivalent(							@@\
	    TypeCode_ptr tc						@@\
	) const IT_THROW_DECL((SystemException));			@@\
									@@\
	TCKind								@@\
	kind() const IT_THROW_DECL((SystemException));			@@\
                                                                        @@\
        IT_TC_Kind                                                      @@\
        it_kind() const IT_THROW_DECL(());                              @@\
									@@\
	TypeCode_ptr							@@\
	get_compact_typecode() const IT_THROW_DECL((SystemException));	@@\
									@@\
	const char*							@@\
	id() const IT_THROW_DECL((SystemException, BadKind));		@@\
									@@\
	const char*							@@\
	name() const IT_THROW_DECL((SystemException, BadKind));		@@\
									@@\
	ULong								@@\
	member_count() const IT_THROW_DECL((SystemException, BadKind));	@@\
									@@\
	const char*							@@\
	member_name(							@@\
	    ULong index							@@\
	) const IT_THROW_DECL((SystemException, BadKind, Bounds));	@@\
									@@\
	TypeCode_ptr							@@\
	member_type(							@@\
	    ULong index							@@\
	) const IT_THROW_DECL((SystemException, BadKind, Bounds));	@@\
									@@\
	Any*								@@\
	member_label(							@@\
	    ULong index							@@\
	) const IT_THROW_DECL((SystemException, BadKind, Bounds));	@@\
									@@\
	TypeCode_ptr							@@\
	discriminator_type() const IT_THROW_DECL((SystemException,	@@\
						  BadKind));		@@\
									@@\
	Long								@@\
	default_index() const IT_THROW_DECL((SystemException, BadKind));@@\
									@@\
	ULong								@@\
	length() const IT_THROW_DECL((SystemException, BadKind));	@@\
									@@\
	TypeCode_ptr							@@\
	content_type() const IT_THROW_DECL((SystemException, BadKind));	@@\
									@@\
	UShort								@@\
	fixed_digits() const IT_THROW_DECL((SystemException, BadKind));	@@\
									@@\
	Short								@@\
	fixed_scale() const IT_THROW_DECL((SystemException, BadKind));	@@\
									@@\
	ValueModifier							@@\
	type_modifier() const IT_THROW_DECL((SystemException, BadKind));@@\
									@@\
	TypeCode_ptr							@@\
	concrete_base_type() const IT_THROW_DECL((SystemException,	@@\
						  BadKind));		@@\
									@@\
	Visibility							@@\
	member_visibility(						@@\
	    ULong index							@@\
	) const IT_THROW_DECL((SystemException, BadKind, Bounds));	@@\
                                                                        @@\
	void								@@\
	_add_ref();							@@\
									@@\
	void								@@\
	_remove_ref();						        @@\
									@@\
        const IT_TC_Vtable* m_vtable;               	       		@@\
        Boolean             m_releasable;				@@\
    };									@@\
									@@\
    IT_NAMESPACE_STATIC_INLINE void					@@\
    release(								@@\
	TypeCode_ptr tc							@@\
    )									@@\
    {									@@\
	if (tc != 0 && tc->m_releasable)         		       	@@\
	{								@@\
	    tc->_remove_ref();					        @@\
	}								@@\
    }"

    //
    // the DII
    //

    // from ORB Portability Joint Submission 97-05-15 page 17-10

    local interface ExceptionList
    {
	readonly attribute unsigned long count;

	void
	add(
	    in TypeCode exc
	);

	TypeCode
	item(
	    in unsigned long index
	) raises (Bounds);

	void
	remove(
	    in unsigned long index
	) raises (Bounds);
    };

    local interface ContextList
    {
	readonly attribute unsigned long count;

	void
	add(
	    in string ctxt
	);

	string
	item(
	    in unsigned long index
	) raises (Bounds);
#pragma IT_BeginNodeSpecific item Cplusplus				"@@\
@return_type const char*"

	void
	remove(
	    in unsigned long index
	) raises (Bounds);
    };


#ifndef _JAVA_

    local interface Request
    {
	readonly attribute Object target;
#pragma IT_BeginNodeSpecific target Cplusplus				"@@\
@const_member_func"

	readonly attribute Identifier operation;
#pragma IT_BeginNodeSpecific operation Cplusplus			"@@\
@const_member_func							@@\
@return_type const char*"

	readonly attribute NVList        arguments;
	readonly attribute NamedValue    result;
	readonly attribute Environment   env;
	readonly attribute ExceptionList exceptions;
	readonly attribute ContextList   contexts;

	attribute IT_Context ctx;
#pragma IT_BeginNodeSpecific ctx Cplusplus				"@@\
@const_member_func"

	void
	invoke();

	void
	send_oneway();

	void
	send_deferred();

	void
	sendc(
	    in Object handler
	);

	Object
	sendp();

	void
        prepare(
	    in Object p
	);

	void
	get_response();

	boolean
	poll_response();

#pragma IT_BeginCBESpecific Cplusplus					"@@\
	virtual Any&							@@\
	add_in_arg() = 0;						@@\
									@@\
	virtual Any&							@@\
	add_in_arg(							@@\
	    const char* name						@@\
	) = 0;								@@\
									@@\
	virtual Any&							@@\
	add_inout_arg() = 0;						@@\
									@@\
	virtual Any&							@@\
	add_inout_arg(							@@\
	    const char* name						@@\
	) = 0;								@@\
									@@\
	virtual Any&							@@\
	add_out_arg() = 0;						@@\
									@@\
	virtual Any&							@@\
	add_out_arg(							@@\
	    const char* name						@@\
	) = 0;								@@\
									@@\
	virtual void							@@\
	set_return_type(						@@\
	    TypeCode_ptr tc						@@\
	) = 0;								@@\
									@@\
	virtual Any&							@@\
	return_value() = 0;"
    };


    local interface IT_Request : Request
    {
	// These extensions do not follow the standard C++.  Ownership
	// of the returned memory is retained by the Request.
	//
	readonly attribute string it_exception_holder_type_id;
    };

#endif // _JAVA_

    //
    // the DSI
    //

    // from CORBA 2.2:

#ifndef _JAVA_

    local interface ServerRequest
    {
	readonly attribute Identifier operation;
#pragma IT_BeginNodeSpecific operation Cplusplus			"@@\
@const_member_func							@@\
@return_type const char*"

	void
	arguments(
	    inout NVList nv
	);

	IT_Context
	ctx();

	void
	set_result(
	    in any val
	);

	void
	set_exception(
	    in any val
	);
    };

#endif // _JAVA_

#pragma IT_BeginCBESpecific AllJava                                        "@@\
@switch -xAbstractInterfaces "

#ifndef _JAVA_ // Equivalents are defined in corba.idl for Java

    // IONA specific extensions to ServerRequest
    //

    local interface IT_ServerRequest : ServerRequest
    {
 	// Do not release or free results

	readonly attribute IT_ORB it_get_orb;

	boolean
	it_setup(
	    out NVList arguments,
	    out any    result
	);

 	void
	it_respond();
    };

#endif

#pragma IT_BeginCBESpecific AllJava                                        "@@\
@switch +xAbstractInterfaces "

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch -xAbstractInterfaces"



    //
    // Custom Marshalling support for values
    //

#pragma IT_BeginCBESpecific Java                                "@@\
@switch +xHelpers +xHolders"

    typedef sequence<boolean>            BooleanSeq;
    typedef sequence<char>               CharSeq;
    typedef sequence<octet>              OctetSeq;
    typedef sequence<short>              ShortSeq;
    typedef sequence<unsigned short>     UShortSeq;
    typedef sequence<long>               LongSeq;
    typedef sequence<unsigned long>      ULongSeq;
    typedef sequence<float>              FloatSeq;
    typedef sequence<double>             DoubleSeq;
    typedef sequence<wchar>              WCharSeq;
    typedef sequence<long long>          LongLongSeq;
    typedef sequence<unsigned long long> ULongLongSeq;

    // REVISIT
    // There is no support for longdoubles in Java at the current time
#ifndef _JAVA_
    typedef sequence<long double>        LongDoubleSeq;
#endif

    typedef sequence<any>                AnySeq;
    typedef sequence<string>             StringSeq;
    typedef sequence<wstring>            WStringSeq;

    valuetype StringValue  string;
    valuetype WStringValue wstring;

    abstract valuetype DataInputStream
    {
	// The following operations demarshal and return values of the
	// primitive CORBA types.

	any
	read_any();

	boolean
	read_boolean();

	char
	read_char();

	wchar
	read_wchar();

	octet
	read_octet();

	short
	read_short();

	unsigned short
	read_ushort();

	long
	read_long();

	unsigned long
	read_ulong();

	long long
	read_longlong();

	unsigned long long
	read_ulonglong();

	float
	read_float();

	double
	read_double();

	// REVISIT
	// longdoubles are not supported in Java
#ifndef _JAVA_
	long double
	read_longdouble();
#endif

	string
	read_string();

        wstring
        read_wstring();

	// The following operations each demarshal multiple instances
	// of the same primitive CORBA type.  The demarshaled values
	// are stored in the sequence passed as the inout buf
	// parameter, beginning at the sequence index indicated by the
	// offset parameter.  The number of values is indicated by the
	// len parameter.  These operations can be used to optimize
	// demarshaling of arrays or sequences of the primitive types.
	// Calling a read_*_array() operation with a len parameter of
	// N is equivalent to calling the corresponding read_*()
	// operation N times.
	//
	void
	read_any_array(
	    inout AnySeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
        read_boolean_array(
            inout BooleanSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

	void
	read_char_array(
	    inout CharSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

        void
        read_wchar_array(
            inout WCharSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

	void
	read_octet_array(
	    inout OctetSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	read_short_array(
	    inout ShortSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	read_ushort_array(
	    inout UShortSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	read_long_array(
	    inout LongSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	read_ulong_array(
	    inout ULongSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

        void
        read_longlong_array(
            inout LongLongSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

        void
        read_ulonglong_array(
            inout ULongLongSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

	void
	read_float_array(
	    inout FloatSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	read_double_array(
	    inout DoubleSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	// REVISIT
	// longdoubles are not supported in Java
#ifndef _JAVA_
        void
        read_longdouble_array(
            inout LongDoubleSeq buf,
            in unsigned long offset,
            in unsigned long len
        );
#endif

	// These methods read potentially complex types,
	// including values, objects, and TypeCodes

	ValueBase
	read_value();

	Object
	read_objref();

	TypeCode
	read_TypeCode();
    };
    
    abstract valuetype DataOutputStream
    {
	// The following operations marshal instances of primitive
	// CORBA types.

	void
	write_any(
	    in any val
	);

	void
	write_boolean(
	    in boolean val
	);

	void
	write_char(
	    in char val
	);

        void
        write_wchar(
            in wchar val
        );

	void
	write_octet(
	    in octet val
	);

	void
	write_short(
	    in short val
	);

	void
	write_ushort(
	    in unsigned short val
	);

	void
	write_long(
	    in long val
	);

	void
	write_ulong(
	    in unsigned long val
	);

        void
        write_longlong(
            in long long val
        );

        void
	write_ulonglong(
            in unsigned long long val
        );

	void
	write_float(
	    in float val
	);

	void
	write_double(
	    in double val
	);

	// REVISIT 
	// longdoubles are not supported in Java
#ifndef _JAVA_
        void
        write_longdouble(
            in long double val
        );
#endif
	
	void
	write_string(
	    in string val
	);

        void
        write_wstring(
            in wstring val
        );

	// The following operations each marshal multiple instances of
	// the same primitive CORBA type.  The values marshaled are
	// obtained from the sequence passed as the buf parameter,
	// beginning at the sequence index indicated by the offset
	// parameter.  The number of values to be marshaled is
	// indicated by the len parameter.  These operations can be
	// used to optimize marshaling of arrays or sequences of the
	// primitive types.  Calling a write_*_array() operation with
	// a len parameter of N is equivalent to calling the
	// corresponding write_*() operation N times.

	void
	write_any_array(
	    in AnySeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_boolean_array(
	    in BooleanSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_char_array(
	    in CharSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

        void
        write_wchar_array(
            in WCharSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

	void
	write_octet_array(
	    in OctetSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_short_array(
	    in ShortSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_ushort_array(
	    in UShortSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_long_array(
	    in LongSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_ulong_array(
	    in ULongSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

        void
        write_longlong_array(
            in LongLongSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

        void
        write_ulonglong_array(
            in ULongLongSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

	void
	write_float_array(
	    in FloatSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_double_array(
	    in DoubleSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	// REVISIT
	// longdoubles not supported in Java currently
#ifndef _JAVA_
        void
        write_longdouble_array(
            in LongDoubleSeq buf,
            in unsigned long offset,
            in unsigned long len
        );
#endif

	// These operations write out potentially complex types,
	// including values, object references, and TypeCodes

        void
        write_value(
            in ValueBase vb
        );

	void
	write_objref(
	    in Object val
	);

	void
	write_TypeCode(
	    in TypeCode val
	);
    };

    abstract valuetype CustomMarshal
    {
	void
	marshal(
	    in DataOutputStream os
	);

	void
	unmarshal(
	    in DataInputStream is
	);
    };

#ifndef _JAVA_
    // These concrete valuetypes are not intended for use by
    // applications.
    //
    valuetype IT_DataInputStreamImpl : DataInputStream
    {};

    valuetype IT_DataOutputStreamImpl : DataOutputStream
    {};
#endif

#ifndef _JAVA_ // Need a separate streams mechanism for Java for now
    local interface IT_StreamBase
    {
	// The stream_index() operation returns the current offset
	// from the beginning of the stream.
	//
	long
	stream_index();
    };

    //
    // The InStream interface is a locality-constrained interface
    // exported by objects from which CORBA data types can be
    // demarshaled.  All of the read_*() operations on the InStream
    // interface demarshal and return instances of CORBA types,
    // advancing the stream so that the next read_*() operation reads
    // the following data on the stream.  It is up to the caller to
    // ensure that the read_*() operation corresponding to the type of
    // the marshaled data on the stream is called.
    //
    // InStream operations report errors by raising standard CORBA
    // exceptions.  The MARSHAL exception indicates that the requested
    // data is not available from the InStream.  Other exceptions
    // indicate underlying failures in the InStream implementation.
    // Once an exception is raised, further attempts to read from the
    // stream will also fail.
    //
    
    local interface IT_InStream : IT_StreamBase
    {
	// The following operations demarshal and return values of the
	// primitive CORBA types.

	boolean
	read_boolean();

	char
	read_char();

	wchar
	read_wchar();

	octet
	read_octet();

	short
	read_short();

	unsigned short
	read_ushort();

	long
	read_long();

	unsigned long
	read_ulong();

	long long
	read_longlong();

	unsigned long long
	read_ulonglong();

	float
	read_float();

	double
	read_double();

	long double
	read_longdouble();

	string
	read_string();

        wstring
        read_wstring();

	// IDL does not have a generic fixed type that can represent
	// fixed types with arbitrary numbers of digits and arbitrary
	// scale, so we use a string to represent a fixed value instead.
	//
	string
	read_fixed(
	    in TypeCode fixed_type
	);

	// The read_shared_string() and read_shared_string_nc() operations
	// reads strings that may be encoded as indirections to previously
	// encoded strings.  The read_shared_string_nc() operation functions
	// like read_string_nc(), returning a pointer into the actual
	// stream buffer.
	//
	string
	read_shared_string();

	string
	read_shared_string_nc();

	// The following operations each demarshal multiple instances
	// of the same primitive CORBA type.  The demarshaled values
	// are stored in the sequence passed as the inout buf
	// parameter, beginning at the sequence index indicated by the
	// offset parameter.  The number of values is indicated by the
	// len parameter.  These operations can be used to optimize
	// demarshaling of arrays or sequences of the primitive types.
	// Calling a read_*_array() operation with a len parameter of
	// N is equivalent to calling the corresponding read_*()
	// operation N times.
	//
	void
        read_boolean_array(
            inout BooleanSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

	void
	read_char_array(
	    inout CharSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

        void
        read_wchar_array(
            inout WCharSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

	void
	read_octet_array(
	    inout OctetSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	read_short_array(
	    inout ShortSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	read_ushort_array(
	    inout UShortSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	read_long_array(
	    inout LongSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	read_ulong_array(
	    inout ULongSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

        void
        read_longlong_array(
            inout LongLongSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

        void
        read_ulonglong_array(
            inout ULongLongSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

	void
	read_float_array(
	    inout FloatSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	read_double_array(
	    inout DoubleSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	// REVISIT
	// longdoubles are not supported in Java
#ifndef _JAVA_
        void
        read_longdouble_array(
            inout LongDoubleSeq buf,
            in unsigned long offset,
            in unsigned long len
        );
#endif

	TypeCode
	read_TypeCode();

	// The read_value() operation demarshals and returns a
	// valuetype.  An ORB instance and TypeCode are provided
	// to allow creation of the value using the proper ValueFactory.
	//
	ValueBase
	read_value(
	    in IT_ORB   the_orb,
	    in TypeCode formal_type
	);

	// The read_streamable() operation demarshals and returns a
	// value of a potentially complex CORBA data type.  An
	// instance of the IT_Streamable native type is passed in to
	// read_streamable() to indicate the type of the data and to
	// receive the demarshaled value of that type.  The InStream
	// will call the read() operation on the IT_Streamable,
	// passing itself in, so that the IT_Streamable can
	// demarshal the primitive types from which it is composed.
	//
	void
	read_streamable(
	    in IT_Streamable s
	);


	// The read_string_nc() operation provides a way to demarshal
	// a string without necessarily copying it.  If possible, the
	// returned string is actually just a pointer into the
	// stream's buffer.  Contrary to normal C++ mapping rules,
	// InStream retains ownership of the storage of the returned
	// string, and the caller must not free it.  The caller also
	// must not access it after any subsequent InStream operations
	// have been performed, unless the concrete InStream
	// implementation (i.e. the ART_CDR_EncapsInStream class)
	// guarantees that doing so is safe.
	//
	string
	read_string_nc();


	// The read_octet_seq_nc() operation provides a way to
	// demarshal a sequence<octet> without necessarily copying it.
	// The inout parameter is used to return the sequence length
	// and data, which, if possible, is a pointer into the
	// stream's buffer.  The caller must not access the returned
	// sequence's data after any subsequent InStream operations
	// have been performed, unless the concrete InStream
	// implementation (i.e. the ART_CDR_EncapsInStream class)
	// guarantees that doing so is safe.  It is not necessary to
	// call read_streamable() prior to read_octet_seq_nc() even if
	// the sequence being read is a top-level complex type.
	//
	void
	read_octet_seq_nc(
	    inout OctetSeq ref_seq
	);

	// The empty() operation returns TRUE if the end of the stream
	// has been reached, in which case any attempt to demarshal
	// more data would result in a CORBA::MARSHAL exception.
	//
	boolean
	empty();
    };

    //
    // The OutStream interface is a locality-constrained interface
    // exported by objects into which CORBA data types can be
    // marshaled.  All of the the write_*() operations on the
    // OutStream interface append marshaled representations of
    // instances of CORBA types to the stream.
    //
    // OutStream operations report errors by raising standard CORBA
    // exceptions.  Once an exception is raised, further attempts to
    // write to the stream will also fail.
    //

    local interface IT_OutStream : IT_StreamBase
    {
	// The following operations marshal instances of primitive
	// CORBA types.

	void
	write_boolean(
	    in boolean val
	);

	void
	write_char(
	    in char val
	);

        void
        write_wchar(
            in wchar val
        );

	void
	write_octet(
	    in octet val
	);

	void
	write_short(
	    in short val
	);

	void
	write_ushort(
	    in unsigned short val
	);

	void
	write_long(
	    in long val
	);

	void
	write_ulong(
	    in unsigned long val
	);

        void
        write_longlong(
            in long long val
        );

        void
	write_ulonglong(
            in unsigned long long val
        );

	void
	write_float(
	    in float val
	);

	void
	write_double(
	    in double val
	);

        void
        write_longdouble(
            in long double val
        );

	void
	write_string(
	    in string val
	);

        void
        write_wstring(
            in wstring val
        );

	// IDL does not have a generic fixed type that can represent
	// fixed types with arbitrary numbers of digits and arbitrary
	// scale, so we use a string to represent a fixed value instead.
	//
	void
	write_fixed(
	    in string   fixed_val,
	    in TypeCode type
	);

	// write_shared_string() writes a string that can be referenced
	// by indirection.  The first time a shared string is written,
	// it is marshalled as a normal string.  Subsequent writes
	// will marshal the string as an indirection.

	void
	write_shared_string(
	    in string val
	);

	// The following operations each marshal multiple instances of
	// the same primitive CORBA type.  The values marshaled are
	// obtained from the sequence passed as the buf parameter,
	// beginning at the sequence index indicated by the offset
	// parameter.  The number of values to be marshaled is
	// indicated by the len parameter.  These operations can be
	// used to optimize marshaling of arrays or sequences of the
	// primitive types.  Calling a write_*_array() operation with
	// a len parameter of N is equivalent to calling the
	// corresponding write_*() operation N times.

	void
	write_boolean_array(
	    in BooleanSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_char_array(
	    in CharSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

        void
        write_wchar_array(
            in WCharSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

	void
	write_octet_array(
	    in OctetSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_short_array(
	    in ShortSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_ushort_array(
	    in UShortSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_long_array(
	    in LongSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_ulong_array(
	    in ULongSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

        void
        write_longlong_array(
            in LongLongSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

        void
        write_ulonglong_array(
            in ULongLongSeq buf,
            in unsigned long offset,
            in unsigned long len
        );

	void
	write_float_array(
	    in FloatSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	void
	write_double_array(
	    in DoubleSeq buf,
	    in unsigned long offset,
	    in unsigned long len
	);

	// REVISIT
	// longdoubles are not supported in Java
#ifndef _JAVA_
        void
        write_longdouble_array(
            in LongDoubleSeq buf,
            in unsigned long offset,
            in unsigned long len
        );
#endif

	void
	write_TypeCode(
	    in TypeCode tc
	);

	// The write_streamable() operation marshals a complex CORBA
	// data type.  An instance of the IT_Streamable native type
	// is passed in to indicate the type of the data and provide
	// the value of that type to be marshaled.  The OutStream will
	// call the write() operation on the IT_Streamable, passing
	// itself in, so that the IT_Streamable can marshal the
	// primitive types from which it is composed.

	void
	write_streamable(
	    in IT_Streamable s
	);

	// The write_value() operation marshals a valuetype.  It
	// takes an ORB instance and a TypeCode representing the
	// formal argument type.  The actual type can be retrieved
	// from the value itself, allowing for potential optimizations.

	void
	write_value(
	    in ValueBase    value,
	    in IT_ORB       the_orb,
	    in TypeCode     formal_type
	);

	// The start_octet_seq() and commit_octet_seq() operations can
	// be used to marshal a sequence<octet>, assembling its
	// contents directly in the OutStream's buffer, without
	// knowing its eventual length a priori.
	//
	// First, start_octet_seq() is called to specify the expected
	// length and obtain a sequence<octet> referring into the
	// OutStream's buffer.  On return, the buf inout parameter has
	// been updated to refer into the OutStream's buffer.  The
	// offset and len out parameters indicate where data for the
	// sequence<octet> can be written.  OutStreams are not
	// required to make the amount of space requested available,
	// so may can be larger or smaller than expected_len, or even
	// zero.
	//
	// If the assembled sequence<octet> value ends up not fitting
	// into the returned buffer, the data written into the
	// returned buffer should be copied to a larger buffer and the
	// write_ulong() and write_octet_array() operations used to
	// marshal its value.  If the sequence<octet> is the top-level
	// complex type, the fact start_octet_seq() was called is
	// sufficient to notify the stream of the type being
	// marshaled, and it is not necessary to call
	// write_streamable().
	//
	// If the entire assembled sequence<octet> does end up fitting
	// in the buffer returned by start_octet_sequence(),
	// commit_octet_seq() should then be called to indicate the
	// actual length of the sequence, and cause the data written
	// to be appended to the stream.

	void
	start_octet_seq(
	    in unsigned long expected_len,
	    inout OctetSeq buf,
	    out unsigned long offset,
	    out unsigned long len
	);

	void
	commit_octet_seq(
	    in unsigned long len
	);

	// The flush() operation indicates to the stream that no more
	// data will be marshaled and any needed end-of-stream
	// processing can be performed.  An exception will be raised
	// if any write_*() operations are called after flush().
	//
	void
	flush();
    };
#endif // _JAVA_ - Need a separate streams mechanism for Java for now


#pragma IT_BeginCBESpecific Cplusplus					"@@\
@include <orbix_sys/dp_base.h>"

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch +xAbstractInterfaces "

    //
    // the Interface Repository
    //

    // added forward declarations

    interface IRObject;
    interface Contained;
    interface Container;
    interface IDLType;
    interface Repository;
    interface ModuleDef;
    interface ConstantDef;
    interface TypedefDef;
    interface StructDef;
    interface UnionDef;
    interface EnumDef;
    interface AliasDef;
    interface PrimitiveDef;
    interface StringDef;
    interface SequenceDef;
    interface ArrayDef;
    interface ExceptionDef;
    interface AttributeDef;
    interface OperationDef;
    interface InterfaceDef;
    interface LocalInterfaceDef;
    interface AbstractInterfaceDef;
    interface WstringDef;
    interface FixedDef;
    interface NativeDef;
    interface ValueDef;
    typedef sequence<ValueDef> ValueDefSeq;
    interface ValueBoxDef;

    // from CORBA V2.1(Pre-release) June 1997 page 6-8

    enum DefinitionKind
    {
	dk_none, dk_all,
	dk_Attribute, dk_Constant, dk_Exception, dk_Interface,
	dk_Module, dk_Operation, dk_Typedef,
	dk_Alias, dk_Struct, dk_Union, dk_Enum,
	dk_Primitive, dk_String, dk_Sequence, dk_Array,
	dk_Repository,
	dk_Wstring, dk_Fixed,
	dk_Value, dk_ValueBox, dk_ValueMember, dk_Native,
	dk_AbstractInterface, dk_LocalInterface
    };

    // moved:

    enum PrimitiveKind
    {
	pk_null, pk_void, pk_short, pk_long, pk_ushort, pk_ulong,
	pk_float, pk_double, pk_boolean, pk_char, pk_octet,
	pk_any, pk_TypeCode, pk_Principal, pk_string, pk_objref,
	pk_longlong, pk_ulonglong, pk_longdouble, pk_wchar, pk_wstring,
        pk_ValueBase
    };

    // moved member descriptions

    struct StructMember
    {
	Identifier name;
	TypeCode type;
	IDLType type_def;
    };
    typedef sequence<StructMember> StructMemberSeq;

    struct UnionMember
    {
	Identifier name;
	any label;
	TypeCode type;
	IDLType type_def;
    };
    typedef sequence<UnionMember> UnionMemberSeq;

    typedef sequence<Identifier> EnumMemberSeq;

    struct Initializer
    {
	StructMemberSeq members;
	Identifier name;
    };
    typedef sequence<Initializer> InitializerSeq;

    interface IRObject
    {
	// read interface

	readonly attribute DefinitionKind def_kind;

	// write interface

	void
	destroy();
    };

    // moved these sequences

    typedef sequence<InterfaceDef> InterfaceDefSeq;
    typedef sequence<AbstractInterfaceDef> AbstractInterfaceDefSeq;
    typedef sequence<RepositoryId> RepositoryIdSeq;

    typedef string VersionSpec;

    interface Contained : IRObject
    {
	// read/write interface

	attribute RepositoryId id;
	attribute Identifier name;
	attribute VersionSpec version;

	// read interface

	readonly attribute Container defined_in;
	readonly attribute ScopedName absolute_name;
	readonly attribute Repository containing_repository;

	struct Description
	{
	    DefinitionKind kind;
	    any value;
	};

	Description
	describe();

	// write interface

	void
	move(
	    in Container new_container,
	    in Identifier new_name,
	    in VersionSpec new_version
	);
    };

    typedef sequence<Contained> ContainedSeq;

    interface Container : IRObject
    {
	// read interface

	Contained
	lookup(
	    in ScopedName search_name
	);

	ContainedSeq
	contents(
	    in DefinitionKind limit_type,
	    in boolean exclude_inherited
	);

	ContainedSeq
	lookup_name (
	    in Identifier search_name,
	    in long levels_to_search,
	    in DefinitionKind limit_type,
	    in boolean exclude_inherited
	);

	struct Description
	{
	    Contained contained_object;
	    DefinitionKind kind;
	    any value;
	};
	typedef sequence<Description> DescriptionSeq;

	DescriptionSeq
	describe_contents(
	    in DefinitionKind limit_type,
	    in boolean exclude_inherited,
	    in long max_returned_objs
	);

	// write interface

	ModuleDef
	create_module(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version
	);

	ConstantDef
	create_constant(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in IDLType type,
	    in any value
	);

	StructDef
	create_struct(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in StructMemberSeq members
	);

	UnionDef
	create_union(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in IDLType discriminator_type,
	    in UnionMemberSeq members
	);

	EnumDef
	create_enum(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in EnumMemberSeq members
	);

	AliasDef
	create_alias(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in IDLType original_type
	);

	InterfaceDef
	create_interface(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in InterfaceDefSeq base_interfaces
	);

	AbstractInterfaceDef
	create_abstract_interface(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in AbstractInterfaceDefSeq base_interfaces
	);

	LocalInterfaceDef
	create_local_interface(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in InterfaceDefSeq base_interfaces
	);

        ValueDef
        create_value(
            in RepositoryId id,
            in Identifier name,
            in VersionSpec version,
            in boolean is_custom,
            in boolean is_abstract,
            in octet flags,
            in ValueDef base_value,
            in boolean has_safe_base,
            in ValueDefSeq abstract_base_values,
            in InterfaceDefSeq supported_interfaces,
            in InitializerSeq initializers
        );

        ValueBoxDef
        create_value_box(
            in RepositoryId id,
            in Identifier name,
            in VersionSpec version,
            in IDLType original_type_def
        );

	ExceptionDef
	create_exception(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in StructMemberSeq members
	);

        NativeDef
        create_native(
            in RepositoryId id,
            in Identifier name,
            in VersionSpec version
        );
    };

    interface IDLType : IRObject
    {
	readonly attribute TypeCode type;
    };

    interface Repository : Container
    {
	// read interface

	Contained
	lookup_id(
	    in RepositoryId search_id
	);

	PrimitiveDef
	get_primitive(
	    in PrimitiveKind kind
	);

	// write interface

	StringDef
	create_string(
	    in unsigned long bound
	);

	SequenceDef
	create_sequence(
	    in unsigned long bound,
	    in IDLType element_type
	);

	ArrayDef
	create_array(
	    in unsigned long length,
	    in IDLType element_type
	);

	WstringDef
	create_wstring(
	    in unsigned long bound
	);

	FixedDef
	create_fixed(
	    in unsigned short digits,
	    in short scale
	);

	TypeCode
	get_canonical_typecode(
	    in TypeCode tc
	);
    };

    interface ModuleDef : Container, Contained
    {
    };

    struct ModuleDescription
    {
	Identifier name;
	RepositoryId id;
	RepositoryId defined_in;
	VersionSpec version;
    };

    interface ConstantDef : Contained
    {
	readonly attribute TypeCode type;
	attribute IDLType type_def;
	attribute any value;
    };

    struct ConstantDescription
    {
	Identifier name;
	RepositoryId id;
	RepositoryId defined_in;
	VersionSpec version;
	TypeCode type;
	any value;
    };

    interface TypedefDef : Contained, IDLType
    {
    };

    struct TypeDescription
    {
	Identifier name;
	RepositoryId id;
	RepositoryId defined_in;
	VersionSpec version;
	TypeCode type;
    };

    interface StructDef : TypedefDef, Container
    {
	attribute StructMemberSeq members;
    };

    interface UnionDef : TypedefDef, Container
    {
	readonly attribute TypeCode discriminator_type;
	attribute IDLType discriminator_type_def;
	attribute UnionMemberSeq members;
    };

    interface EnumDef : TypedefDef
    {
	attribute EnumMemberSeq members;
    };

    interface AliasDef : TypedefDef
    {
	attribute IDLType original_type_def;
    };

    interface NativeDef : TypedefDef {};

    interface PrimitiveDef : IDLType
    {
	readonly attribute PrimitiveKind kind;
    };

    interface StringDef : IDLType
    {
	attribute unsigned long bound;
    };

    interface SequenceDef : IDLType
    {
	attribute unsigned long bound;
	readonly attribute TypeCode element_type;
	attribute IDLType element_type_def;
    };

    interface ArrayDef : IDLType
    {
	attribute unsigned long length;
	readonly attribute TypeCode element_type;
	attribute IDLType element_type_def;
    };

    interface ExceptionDef : Contained, Container
    {
	readonly attribute TypeCode type;
	attribute StructMemberSeq members;
    };
    struct ExceptionDescription
    {
	Identifier name;
	RepositoryId id;
	RepositoryId defined_in;
	VersionSpec version;
	TypeCode type;
    };

    enum AttributeMode
    {
	ATTR_NORMAL,
	ATTR_READONLY
    };

    interface AttributeDef : Contained
    {
	readonly attribute TypeCode type;
	attribute IDLType type_def;
	attribute AttributeMode mode;
    };

    struct AttributeDescription
    {
	Identifier name;
	RepositoryId id;
	RepositoryId defined_in;
	VersionSpec version;
	TypeCode type;
	AttributeMode mode;
    };

    enum OperationMode
    {
	OP_NORMAL,
	OP_ONEWAY
    };

    enum ParameterMode
    {
	PARAM_IN,
	PARAM_OUT,
	PARAM_INOUT
    };

    struct ParameterDescription
    {
	Identifier name;
	TypeCode type;
	IDLType type_def;
	ParameterMode mode;
    };
    typedef sequence<ParameterDescription> ParDescriptionSeq;

    typedef Identifier ContextIdentifier;
    typedef sequence<ContextIdentifier> ContextIdSeq;

    typedef sequence<ExceptionDef> ExceptionDefSeq;

    typedef sequence<ExceptionDescription> ExcDescriptionSeq;

    interface OperationDef : Contained
    {
	readonly attribute TypeCode result;
	attribute IDLType result_def;
	attribute ParDescriptionSeq params;
	attribute OperationMode mode;
	attribute ContextIdSeq contexts;
	attribute ExceptionDefSeq exceptions;
    };

    struct OperationDescription
    {
	Identifier name;
	RepositoryId id;
	RepositoryId defined_in;
	VersionSpec version;
	TypeCode result;
	OperationMode mode;
	ContextIdSeq contexts;
	ParDescriptionSeq parameters;
	ExcDescriptionSeq exceptions;
    };
    typedef sequence<OperationDescription> OpDescriptionSeq;

    typedef sequence<AttributeDescription> AttrDescriptionSeq;

    interface InterfaceDef : Container, Contained, IDLType
    {
	// read/write interface

	attribute InterfaceDefSeq base_interfaces;

	// read interface

	boolean
	is_a(
	    in RepositoryId interface_id
	);

	struct FullInterfaceDescription
	{
	    Identifier name;
	    RepositoryId id;
	    RepositoryId defined_in;
	    VersionSpec version;
	    OpDescriptionSeq operations;
	    AttrDescriptionSeq attributes;
	    RepositoryIdSeq base_interfaces;
	    TypeCode type;
	};

	FullInterfaceDescription
	describe_interface();

	// write interface

	AttributeDef
	create_attribute(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in IDLType type,
	    in AttributeMode mode
	);

	OperationDef
	create_operation(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in IDLType result,
	    in OperationMode mode,
	    in ParDescriptionSeq params,
	    in ExceptionDefSeq exceptions,
	    in ContextIdSeq contexts
	);
    };

    struct InterfaceDescription
    {
	Identifier name;
	RepositoryId id;
	RepositoryId defined_in;
	VersionSpec version;
	RepositoryIdSeq base_interfaces;
    };

    interface AbstractInterfaceDef : InterfaceDef
    {
	// Complete
    };

    interface LocalInterfaceDef : InterfaceDef
    {
	// Complete
    };

    interface WstringDef : IDLType
    {
	attribute unsigned long bound;
    };

    interface FixedDef : IDLType
    {
	attribute unsigned short digits;
	attribute short scale;
    };

    struct ValueMember
    {
	Identifier name;
        RepositoryId id;
        RepositoryId defined_in;
        VersionSpec version;
	TypeCode   type;
	IDLType    type_def;
	Visibility access;
    };
    typedef sequence<ValueMember> ValueMemberSeq;

    interface ValueMemberDef : Contained
    {
	readonly attribute TypeCode type;
	attribute IDLType type_def;
	attribute Visibility access;
    };

    interface ValueDef:Container, Contained, IDLType
    {
        attribute InterfaceDefSeq supported_interfaces;
        attribute InitializerSeq initializers;
        attribute ValueDef base_value;
        attribute ValueDefSeq abstract_base_values;
        attribute boolean is_abstract;
        attribute boolean is_custom;
        attribute octet flags;
        attribute boolean has_safe_base;

        boolean is_a(
            in RepositoryId value_id
        );

        struct FullValueDescription
        {
            Identifier name;
            RepositoryId id;
            boolean is_abstract;
            boolean is_custom;
            octet flags;
            RepositoryId defined_in;
            VersionSpec version;
            OpDescriptionSeq operations;
            AttrDescriptionSeq attributes;
            ValueMemberSeq members;
            InitializerSeq initializers;
            RepositoryIdSeq    supported_interfaces;
            RepositoryIdSeq abstract_base_values;
            boolean has_safe_base;
            RepositoryId base_value;
            TypeCode type;
        };

        FullValueDescription
        describe_value();

        ValueMemberDef
        create_value_member(
            in RepositoryId id,
            in Identifier name,
            in VersionSpec version,
            in IDLType type,
            in Visibility access
        );

	AttributeDef
	create_attribute(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in IDLType type,
	    in AttributeMode mode
	);

	OperationDef
	create_operation(
	    in RepositoryId id,
	    in Identifier name,
	    in VersionSpec version,
	    in IDLType result,
	    in OperationMode mode,
	    in ParDescriptionSeq params,
	    in ExceptionDefSeq exceptions,
	    in ContextIdSeq contexts
	);
    };

    struct ValueDescription
    {
	Identifier name;
	RepositoryId id;
        boolean is_abstract;
        boolean is_custom;
        octet flags;
        RepositoryId defined_in;
        VersionSpec version;
        RepositoryIdSeq supported_interfaces;
        RepositoryIdSeq abstract_base_values;
        boolean has_safe_base;
        RepositoryId base_value;
    };


    interface ValueBoxDef : TypedefDef
    {
        attribute IDLType original_type_def;
    };

#pragma IT_BeginCBESpecific AllJava                                        "@@\
@switch +xAbstractInterfaces "

    // from CORBA 2.2

    typedef unsigned short ServiceType;
    typedef unsigned long ServiceOption;
    typedef unsigned long ServiceDetailType;

    const ServiceType Security = 1;

    struct ServiceDetail
    {
	ServiceDetailType service_detail_type;
	sequence<octet> service_detail;
    };

    struct ServiceInformation
    {
	sequence<ServiceOption> service_options;
	sequence<ServiceDetail> service_details;
    };

    typedef string ORBid;
    typedef sequence<string> arg_list;

    // not IDL:
    // ORB ORB_init (inout arg_list argv, in ORBid orb_identifier);

#pragma IT_BeginCBESpecific Cplusplus					"@@\
    // from CORBA V2.1(Pre-release) June 1997 page 7-9			@@\
    // and ORB Portability Joint Submission 97-05-15 page 17-18		@@\
    //									@@\
    IT_ART_API IT_NAMESPACE_STATIC ORB_ptr				@@\
	ORB_init(							@@\
	    int& argc,							@@\
	    char** argv,						@@\
	    const char* orb_id = \@\"\@\"				@@\
	);"

    // from CORBA 2.2:
    //
    local interface Current
    {
    };

    interface Policy
    {
	readonly attribute PolicyType policy_type;

	Policy
	copy();

	void
	destroy();
    };


    // from CORBA Messaging draft 4/23/98:


    typedef short PolicyErrorCode;

    const PolicyErrorCode BAD_POLICY               = 0;
    const PolicyErrorCode UNSUPPORTED_POLICY       = 1;
    const PolicyErrorCode BAD_POLICY_TYPE          = 2;
    const PolicyErrorCode BAD_POLICY_VALUE         = 3;
    const PolicyErrorCode UNSUPPORTED_POLICY_VALUE = 4;

    exception PolicyError
    {
	PolicyErrorCode reason;
    };


    // from CORBA 2.2:
    
    local interface DomainManager
    {
	Policy
	get_domain_policy(
	    in PolicyType policy_type
	);
    };

    const PolicyType SecConstruction = 11;

    local interface ConstructionPolicy : Policy
    {
	void
	make_domain_manager(
	    in InterfaceDef object_type,
	    in boolean constr_policy
	);
    };

    typedef sequence<DomainManager> DomainManagerList;

    // from CORBA Messaging draft 4/23/98:

    exception InvalidPolicies	// in PolicyManager in 4/23/98 draft
    {
	sequence<unsigned short> indices;
    };

    local interface PolicyManager
    {
	PolicyList
	get_policy_overrides(
	    in PolicyTypeSeq ts
	);

	void
	set_policy_overrides(
	    in PolicyList policies,
	    in SetOverrideType set_add
	) raises (InvalidPolicies);
    };

    local interface PolicyCurrent : PolicyManager, Current
    {
    };

    // from CORBA 2.2:

    interface Composite
    {
	Object
	query_interface(
	    in RepositoryId whichOne
	);
    };

    interface Composable : Composite
    {
	Composite
	primary_interface();
    };

    //
    // the ORB pseudo-interface
    //

#pragma IT_BeginCBESpecific Java                                        "@@\
@switch -xHelpers -xHolders "

#pragma IT_BeginCBESpecific AllJava                                        "@@\
@switch -xAbstractInterfaces "

#pragma IT_BeginCBESpecific AllJava                                        "@@\
@switch -xSuppressCodeGeneration "

    local interface ORB
    {
	// from ORB Portability Joint Submission 97-05-15 page 2-10
	// (not in CORBA 2.2 yet):

	boolean
	work_pending();

	void
	perform_work();

	void
	shutdown(
	    in boolean wait_for_completion
	);

	void
	run();

	// from CORBA 2.3
	//

	void
	destroy();

	// from CORBA 2.2:

	string
	object_to_string(
	    in Object obj
	);

	Object
	string_to_object(
	    in string str
	);

	boolean
	get_service_information(
	    in ServiceType         service_type,
	    out ServiceInformation service_information
	);

	// get_current deprecated operation - should not be used by new code
	// new code should use resolve_initial_reference operation instead
	// Current get_current();

	typedef string ObjectId;
	typedef sequence<ObjectId> ObjectIdList;

	exception InvalidName {};

	ObjectIdList
	list_initial_services();

	Object
	resolve_initial_references(
	    in ObjectId identifier
	) raises (InvalidName);


	// from CORBA Messaging draft 4/23/98:

	Policy
	create_policy(
	    in PolicyType type,
	    in any val
	) raises (PolicyError);


	// from CORBA V2.1 August 1997 page 7-42

	TypeCode
	create_struct_tc(
	    in RepositoryId    id,
	    in Identifier      name,
	    in StructMemberSeq members
	);

	TypeCode
	create_union_tc(
	    in RepositoryId   id,
	    in Identifier     name,
	    in TypeCode       discriminator_type,
	    in UnionMemberSeq members
	);

	TypeCode
	create_enum_tc(
	    in RepositoryId  id,
	    in Identifier    name,
	    in EnumMemberSeq members
	);

	TypeCode
	create_alias_tc(
	    in RepositoryId id,
	    in Identifier   name,
	    in TypeCode     original_type
	);

	TypeCode
	create_exception_tc(
	    in RepositoryId id,
	    in Identifier name,
	    in StructMemberSeq members
	);

	TypeCode
	create_interface_tc(
	    in RepositoryId id,
	    in Identifier name
	);

	TypeCode
	create_string_tc(
	    in unsigned long bound
	);

	TypeCode
	create_wstring_tc(
	    in unsigned long bound
	);

	TypeCode
	create_fixed_tc(
	    in unsigned short digits,
	    in short scale
	);

	TypeCode
	create_sequence_tc(
	    in unsigned long bound,
	    in TypeCode element_type
	);

        //
        // (deprecated in CORBA 2.3)
        //
	TypeCode
	create_recursive_sequence_tc(
	    in unsigned long bound,
	    in unsigned long offset
	);

	TypeCode
	create_recursive_tc(
	    in RepositoryId id
	);

	TypeCode
	create_array_tc(
	    in unsigned long length,
	    in TypeCode element_type
	);

	TypeCode
	create_value_tc(
	    in RepositoryId   id,
	    in Identifier     name,
	    in ValueModifier  type_modifier,
	    in TypeCode       concrete_base,
	    in ValueMemberSeq members
	);

	TypeCode
	create_value_box_tc(
	    in RepositoryId id,
	    in Identifier   name,
	    in TypeCode     original_type
	);

        TypeCode
        create_native_tc(
	    in RepositoryId   id,
	    in Identifier     name
        );

	TypeCode
	create_abstract_interface_tc(
	    in RepositoryId id,
	    in Identifier name
	);

	// from CORBA V2.1 August 1997 page 18-77:

	typedef sequence<Request> RequestSeq;

	void
	create_list(
	    in long count,
	    out NVList new_list
	);

	void
	create_operation_list(
	    in OperationDef oper,
	    out NVList new_list
	);

	void
	create_named_value(
	    out NamedValue nmval
	);

	void
	create_exception_list(
	    out ExceptionList exclist
	);

	void
	create_context_list(
	    out ContextList ctxtlist
	);

	void
	get_default_context(
	    out IT_Context ctx
	);

	void
	create_environment(
	    out Environment new_env
	);

	void
	send_multiple_requests_oneway(
	    in RequestSeq req
	);

	void
	send_multiple_requests_deferred(
	    in RequestSeq req
	);

	boolean
	poll_next_response();

	void
	get_next_response(
	    out Request req
	);

	// from Objects By Value Joint Submission orbos/98-01-01
	ValueFactory
	register_value_factory(
	    in RepositoryId id,
	    in ValueFactory fact
	);

	void
	unregister_value_factory(
	    in RepositoryId id
	);

	ValueFactory
        lookup_value_factory(
	    in RepositoryId id
	);

    };
#pragma IT_BeginCBESpecific AllJava                                        "@@\
@switch +xSuppressCodeGeneration "

#ifndef _JAVA_ // Equivalents defined in corba.idl for Java

    // IONA specific extensions to the ORB interface
    //
    local interface IT_ORB : ORB
    {
        readonly attribute string it_orb_id;
	readonly attribute string it_orb_name;
	
	Object
	it_demarshal_object(
	    in CORBA::IT_InStream stream
	);
	
	void
	it_marshal_nil(
	    in CORBA::IT_OutStream stream
	);

	void
	it_register_initial_reference(
	    in ObjectId identifier,
	    in Object   obj,
	    in boolean  visible
	);

	void
	it_add_internal_ref();

	void
	it_remove_internal_ref();

	void
	it_add_pending_request(
	    in Request the_request
	);

	void
	it_remove_pending_request(
	    in Request the_request
	);
    };

#endif

#ifndef _JAVA_

    local interface PollableSet;

    local interface Pollable
    {
	boolean
	is_ready(
	    in unsigned long timeout
	);

	PollableSet
	create_pollable_set();
    };

    local interface DIIPollable : Pollable { };

    local interface PollableSet
    {

	exception NoPossiblePollable {};
	exception UnknownPollable {};

	DIIPollable
	create_dii_pollable();

	void
	add_pollable(
	    in Pollable potential
	);

	Pollable
	poll(
	    in unsigned long timeout
	) raises (NoPossiblePollable);

	void
	remove(
	    in Pollable potential
	) raises (UnknownPollable);

	unsigned short
	number_left();
    };

#endif

#pragma IT_BeginCBESpecific AllJava                                        "@@\
@switch +xHelpers +xHolders +xAbstractInterfaces "

    const unsigned long OMGVMCID = 0x4F4D0000;
};

#pragma IT_BeginCBESpecific Cplusplus					"@@\
typedef CORBA::IT_Cxx_DPBase CORBA_IT_Cxx_DPBase;			@@\
									@@\
@include <orbix_sys/any_funcs.h>				       	@@\
@include <orbix_sys/typeio.h>						@@\
@include <orbix_sys/fixed_operators.h>					@@\
@include <orbix_sys/sequence.h>						@@\
@include <it_tsdsa/fwstring.h>"

//
// Inline functions
//
#pragma IT_BeginCBESpecific Cplusplus					"@@\
//									@@\
// CORBA::SystemException inlines					@@\
//									@@\
inline									@@\
CORBA::SystemException::SystemException(				@@\
    const CORBA::SystemException& s					@@\
) :									@@\
    m_minor(s.m_minor),							@@\
    m_status(s.m_status)						@@\
{									@@\
    m_reason = s.m_reason;						@@\
    m_propagation_count = 0;						@@\
}									@@\
									@@\
inline									@@\
CORBA::SystemException::SystemException(				@@\
    CORBA::ULong             minor,					@@\
    CORBA::completion_status status,					@@\
    const CORBA::WChar*      reason					@@\
) :									@@\
    m_minor(minor),							@@\
    m_status(status)							@@\
{									@@\
    m_reason = reason;							@@\
    m_propagation_count = 0;						@@\
}									@@\
									@@\
inline CORBA::ULong							@@\
CORBA::SystemException::minor() const					@@\
{									@@\
    return m_minor;							@@\
}									@@\
									@@\
inline void								@@\
CORBA::SystemException::minor(						@@\
    CORBA::ULong minor							@@\
)									@@\
{									@@\
    m_minor = minor;							@@\
}									@@\
									@@\
inline CORBA::completion_status						@@\
CORBA::SystemException::completed() const				@@\
{									@@\
    return m_status;							@@\
}									@@\
									@@\
inline void								@@\
CORBA::SystemException::completed(					@@\
    CORBA::completion_status status					@@\
)									@@\
{									@@\
    m_status = status;							@@\
}									@@\
									@@\
inline CORBA::SystemException*						@@\
CORBA::SystemException::_narrow(					@@\
    CORBA::Exception* exc						@@\
)									@@\
{									@@\
    return _downcast(exc);						@@\
}									@@\
									@@\
inline const CORBA::SystemException*					@@\
CORBA::SystemException::_narrow(					@@\
    const CORBA::Exception* exc						@@\
)									@@\
{									@@\
    return _downcast(exc);						@@\
}									@@\
									@@\
inline const CORBA::SystemException*					@@\
CORBA::SystemException::_downcast(					@@\
    const CORBA::Exception* exc						@@\
)									@@\
{									@@\
    return _downcast(IT_CONST_CAST(CORBA::Exception*, exc));		@@\
}									@@\
									@@\
//									@@\
// CORBA::UserException inlines						@@\
//									@@\
inline									@@\
CORBA::UserException::UserException()					@@\
{									@@\
    // complete								@@\
}									@@\
									@@\
inline CORBA::UserException*						@@\
CORBA::UserException::_narrow(						@@\
    CORBA::Exception* exc						@@\
)									@@\
{									@@\
    return _downcast(exc);						@@\
}									@@\
									@@\
inline const CORBA::UserException*					@@\
CORBA::UserException::_narrow(						@@\
    const CORBA::Exception* exc						@@\
)									@@\
{									@@\
    return _downcast(exc);						@@\
}									@@\
									@@\
inline const CORBA::UserException*					@@\
CORBA::UserException::_downcast(					@@\
    const CORBA::Exception* exc						@@\
)									@@\
{									@@\
    return _downcast(IT_CONST_CAST(CORBA::Exception*, exc));		@@\
}									@@\
									@@\
inline CORBA::Object_ptr						@@\
CORBA::Object::_duplicate(						@@\
    CORBA::Object_ptr obj						@@\
)									@@\
{									@@\
    if (obj != 0)							@@\
    {									@@\
	obj->_add_ref();						@@\
    }									@@\
    return obj;								@@\
}									@@\
									@@\
inline CORBA::Object_ptr						@@\
CORBA::Object::_nil()							@@\
{									@@\
    return 0;								@@\
}									@@\
									@@\
inline CORBA::AbstractBase_ptr						@@\
CORBA::AbstractBase::_nil()						@@\
{									@@\
    return 0;								@@\
}									@@\
									@@\
inline void								@@\
CORBA::Object::operator=(						@@\
    const CORBA::Object&						@@\
)									@@\
{									@@\
    // complete								@@\
}                                                                       @@\
                                                                        @@\
inline CORBA::TypeCode_ptr						@@\
CORBA::TypeCode::_duplicate(						@@\
    CORBA::TypeCode_ptr tc						@@\
)									@@\
{									@@\
    if (tc != 0)							@@\
    {									@@\
	tc->_add_ref();						        @@\
    }									@@\
    return tc;								@@\
}									@@\
									@@\
inline CORBA::TypeCode_ptr						@@\
CORBA::TypeCode::_nil()							@@\
{									@@\
    return 0;								@@\
}									@@\
									@@\
inline CORBA::ValueBase*                                                @@\
CORBA::ValueFactoryBase::_it_create_for_unmarshal()                     @@\
{                                                                       @@\
    return create_for_unmarshal();                                      @@\
}									@@\
									@@\
//									@@\
// CORBA::UnknownUserException						@@\
//									@@\
inline CORBA::UnknownUserException*					@@\
CORBA::UnknownUserException::_narrow(					@@\
    CORBA::Exception* exc						@@\
)									@@\
{									@@\
    return _downcast(exc);						@@\
}									@@\
									@@\
inline const CORBA::UnknownUserException*				@@\
CORBA::UnknownUserException::_narrow(					@@\
    const CORBA::Exception* exc						@@\
)									@@\
{									@@\
    return _downcast(exc);						@@\
}									@@\
									@@\
inline const CORBA::UnknownUserException*				@@\
CORBA::UnknownUserException::_downcast(					@@\
    const CORBA::Exception* exc						@@\
)									@@\
{									@@\
    return _downcast(IT_CONST_CAST(CORBA::Exception*, exc));		@@\
}"

#pragma IT_BeginCBESpecific Cplusplus					"@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&      any,						@@\
    const CORBA::UNKNOWN*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any& any,						@@\
    CORBA::UNKNOWN*&  ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&        any,					@@\
    const CORBA::BAD_PARAM*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&  any,						@@\
    CORBA::BAD_PARAM*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&        any,					@@\
    const CORBA::NO_MEMORY*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&  any,						@@\
    CORBA::NO_MEMORY*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&        any,					@@\
    const CORBA::IMP_LIMIT*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&  any,						@@\
    CORBA::IMP_LIMIT*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&           any,					@@\
    const CORBA::COMM_FAILURE*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&     any,						@@\
    CORBA::COMM_FAILURE*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&         any,					@@\
    const CORBA::INV_OBJREF*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&   any,						@@\
    CORBA::INV_OBJREF*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&            any,					@@\
    const CORBA::NO_PERMISSION*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&      any,						@@\
    CORBA::NO_PERMISSION*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&       any,					@@\
    const CORBA::INTERNAL*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any& any,						@@\
    CORBA::INTERNAL*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&      any,						@@\
    const CORBA::MARSHAL*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any& any,						@@\
    CORBA::MARSHAL*&  ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&         any,					@@\
    const CORBA::INITIALIZE*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&   any,						@@\
    CORBA::INITIALIZE*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&           any,					@@\
    const CORBA::NO_IMPLEMENT*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&     any,						@@\
    CORBA::NO_IMPLEMENT*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&           any,					@@\
    const CORBA::BAD_TYPECODE*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&     any,						@@\
    CORBA::BAD_TYPECODE*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&            any,					@@\
    const CORBA::BAD_OPERATION*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&      any,						@@\
    CORBA::BAD_OPERATION*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&           any,					@@\
    const CORBA::NO_RESOURCES*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&     any,						@@\
    CORBA::NO_RESOURCES*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&          any,					@@\
    const CORBA::NO_RESPONSE*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&    any,						@@\
    CORBA::NO_RESPONSE*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&            any,					@@\
    const CORBA::PERSIST_STORE*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&      any,						@@\
    CORBA::PERSIST_STORE*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&            any,					@@\
    const CORBA::BAD_INV_ORDER*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&      any,						@@\
    CORBA::BAD_INV_ORDER*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&        any,					@@\
    const CORBA::TRANSIENT*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&  any,						@@\
    CORBA::TRANSIENT*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&       any,					@@\
    const CORBA::FREE_MEM*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any& any,						@@\
    CORBA::FREE_MEM*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&        any,					@@\
    const CORBA::INV_IDENT*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&  any,						@@\
    CORBA::INV_IDENT*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&       any,					@@\
    const CORBA::INV_FLAG*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any& any,						@@\
    CORBA::INV_FLAG*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&         any,					@@\
    const CORBA::INTF_REPOS*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&   any,						@@\
    CORBA::INTF_REPOS*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&          any,					@@\
    const CORBA::BAD_CONTEXT*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&    any,						@@\
    CORBA::BAD_CONTEXT*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&          any,					@@\
    const CORBA::OBJ_ADAPTER*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&    any,						@@\
    CORBA::OBJ_ADAPTER*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&              any,					@@\
    const CORBA::DATA_CONVERSION*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&        any,					@@\
    CORBA::DATA_CONVERSION*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&               any,				@@\
    const CORBA::OBJECT_NOT_EXIST*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&         any,					@@\
    CORBA::OBJECT_NOT_EXIST*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&                   any,				@@\
    const CORBA::TRANSACTION_REQUIRED*& ex				@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&             any,					@@\
    CORBA::TRANSACTION_REQUIRED*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&                     any,				@@\
    const CORBA::TRANSACTION_ROLLEDBACK*& ex				@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&               any,				@@\
    CORBA::TRANSACTION_ROLLEDBACK*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&                  any,				@@\
    const CORBA::INVALID_TRANSACTION*& ex				@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&            any,					@@\
    CORBA::INVALID_TRANSACTION*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&         any,					@@\
    const CORBA::INV_POLICY*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&   any,						@@\
    CORBA::INV_POLICY*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&     any,						@@\
    const CORBA::REBIND*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any& any,						@@\
    CORBA::REBIND*&   ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&      any,						@@\
    const CORBA::TIMEOUT*& ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any& any,						@@\
    CORBA::TIMEOUT*&  ex						@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&                      any,				@@\
    const CORBA::TRANSACTION_UNAVAILABLE*& ex				@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&                any,				@@\
    CORBA::TRANSACTION_UNAVAILABLE*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&               any,				@@\
    const CORBA::TRANSACTION_MODE*& ex					@@\
);									@@\
IT_ART_API extern CORBA::Boolean					@@\
operator>>=(								@@\
    const CORBA::Any&         any,					@@\
    CORBA::TRANSACTION_MODE*& ex					@@\
);"


#endif  /*!_ORB_IDL_*/
