#ifndef _OMG_GIOP_IDL_
#define _OMG_GIOP_IDL_

//
//	Copyright (c) 1999 IONA Technologies PLC. All Rights Reserved.
//
//   THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF IONA Technologies PLC
//	    The copyright notice above does not evidence any
//	    actual or intended publication of such source code.
//

#pragma IT_SystemSpecification

#include <omg/IOP.idl>
#include <omg/orb.idl>

#pragma IT_BeginCBESpecific AllJava                             	"@@\
@module GIOP=org.omg"

#pragma prefix "omg.org"

#if !defined(GIOP_1_0) && !defined(GIOP_1_1) && !defined(GIOP_1_2)
#define GIOP_1_2
#endif

module GIOP
{
    // from CORBA V2.1 (Pre-release) June 1997, page 12-19 thru 12-27
    // and CORBA V2.3a (REVIEW-2 Draft) Nov 1998, page 15-52 thru 15-57

    struct Version
    {
	octet major;
	octet minor;
    };

    enum MsgType_1_1
    {
	Request,
	Reply,
	CancelRequest,
	LocateRequest,
	LocateReply,
	CloseConnection,
	MessageError,
	Fragment		// GIOP 1.1 addition
    };

    typedef MsgType_1_1 MsgType_1_2;

    struct MessageHeader_1_1
    {
	char          magic [4];
	Version       GIOP_version;
	octet         flags;		// GIOP 1.1 change
	octet         message_type;
	unsigned long message_size;
    };

    typedef MessageHeader_1_1 MessageHeader_1_2;

    // Target addressing, added for GIOP 1.2
    //
    typedef short AddressingDisposition;
    const short   KeyAddr = 0;
    const short   ProfileAddr = 1;
    const short   ReferenceAddr = 2;

    struct IORAddressingInfo
    {
        unsigned long selected_profile_index;
        IOP::IOR      ior;
    };

    union TargetAddress switch (AddressingDisposition)
    {
        case KeyAddr:            sequence <octet> object_key;
        case ProfileAddr:        IOP::TaggedProfile profile;
        case ReferenceAddr:      IORAddressingInfo ior;
    };

    struct RequestHeader_1_1
    {
	IOP::ServiceContextList service_context;
	unsigned long           request_id;
	boolean                 response_expected;
	octet                   reserved[3];	// Added in GIOP 1.1
	sequence <octet>        object_key;
	string                  operation;
	CORBA::Principal        requesting_principal;
    };

    struct RequestHeader_1_2
    {
	unsigned long           request_id;
	octet                   response_flags;
	octet                   reserved[3];
	TargetAddress           target;
	string                  operation;
        // Principal not in GIOP 1.2
	IOP::ServiceContextList service_context;
    };

    // Include 1.0/1.1/1.2 values
    //
    enum ReplyStatusType
    {
	NO_EXCEPTION,
	USER_EXCEPTION,
	SYSTEM_EXCEPTION,
	LOCATION_FORWARD,
	LOCATION_FORWARD_PERM,  // Added in GIOP 1.2
	NEEDS_ADDRESSING_MODE   // Added in GIOP 1.2
    };

    struct ReplyHeader
    {
	IOP::ServiceContextList service_context;
	unsigned long           request_id;
	ReplyStatusType         reply_status;
    };

    struct ReplyHeader_1_2
    {
	unsigned long           request_id;
	ReplyStatusType         reply_status;
	IOP::ServiceContextList service_context;
    };

    struct SystemExceptionReplyBody
    {
	string        exception_id;
	unsigned long minor_code_value;
	unsigned long completion_status;
    };

    struct CancelRequestHeader
    {
	unsigned long request_id;
    };

    struct LocateRequestHeader
    {
	unsigned long    request_id;
	sequence <octet> object_key;
    };

    struct LocateRequestHeader_1_2
    {
	unsigned long request_id;
	TargetAddress target;
    };

    // This includes 1.0/1.1/1.2 values.
    //
    enum LocateStatusType
    {
	UNKNOWN_OBJECT,
	OBJECT_HERE,
	OBJECT_FORWARD,
	OBJECT_FORWARD_PERM,         // Added for GIOP 1.2
	LOC_SYSTEM_EXCEPTION,        // Added for GIOP 1.2
	LOC_NEEDS_ADDRESSING_MODE    // Added for GIOP 1.2
    };

    struct LocateReplyHeader
    {
	unsigned long    request_id;
	LocateStatusType locate_status;
    };

    // Added for 1.2
    //
    struct FragmentHeader_1_2
    {
        unsigned long request_id;
    };
};


#endif  /*!_OMG_GIOP_IDL_*/
