#ifndef         maintenanceOps_idl
#define         maintenanceOps_idl

// *************************************
// *                                   *
// * maintenanceOps.idl                *
// *                                   *
// *************************************

//Include list
#include "common.idl"
#include "transmissionParameters.idl"

#pragma prefix "mtnm.tmforum.org"

  /** 
   * <a href=supportingDocumentation/overview.html>Overview of NML-EML interface</a>
   *
   * <p>This module contains the definition of the maintenance manager and
   * CurrentMaintenanceOperationIterator_I interfaces
   * of the NML-EML interface, with related types.</p>
   *
   * <p> For details on the maintenance operation signal flow
   * <a href=supportingDocumentation/maintenanceCommands.pdf>
   * Maintenance Commands</a>.</p>
   *
   * <h5> Version 2.0. </h5>
   **/


module maintenanceOps
{
  /** 
   * <p>Maintenance operation.</p>
   * Valid values are:<dir>
   * "FACILITY_LOOPBACK"<br>
   * "TERMINAL_LOOPBACK"<br>
   * "FACILITY_FORCED_AIS"<br>
   * "TERMINAL_FORCED_AIS"<br>
   * "FORCE_RDI"<br>
   * "SET_AS_SEGMENT_END_POINT" (ATM)<br>
   * "END_TO_END_LOOPBACK_OAM_CELL" (ATM)<br>
   * "SEGMENT_LOOPBACK_OAM_CELL" (ATM)</dir>
   **/
   typedef string MaintenanceOperation_T;


  /**
   * <p>Describes the mode of the operation i.e. operate the maintenance
   * operation or release the maintenance operation.</p>
   **/
   enum  MaintenanceOperationMode_T
   {
      MOM_OPERATE,
      MOM_RELEASE
   };


  /**
   * <p>This struct is used to represent a current persistent 
   * maintenance operation that has been invoked for the given TP,
   * and layerRate if applicable.</p>
   *
   * globaldefs::NamingAttributes_T <b>tpName</b>:
   * <dir> Name of the TP to which the maintenance operation applies.
   * It is a readonly attribute.</dir>
   *
   * MaintenanceOperation_T <b>maintenanceOperation</b>:
   * <dir>Current maintenance operation that has been invoked.
   * It is a readonly attribute.</dir>
   *
   * transmissionParameters::LayerRate_T <b>layerRate</b>:
   * <dir>The layer to which the maintenance operation applies.
   * LR_Optional if not required.</dir>
   *
   * globaldefs::NVSList_T <b>additionalInfo</b>:
   * <dir>Additional information on the maintenance operation, subject to
   *  bilateral agreement.</dir>
   * <br>
   **/ 
   struct CurrentMaintenanceOperation_T
   {
      globaldefs::NamingAttributes_T tpName;
      MaintenanceOperation_T maintenanceOperation;
      transmissionParameters::LayerRate_T layerRate;
      globaldefs::NVSList_T additionalInfo;
   };

  /**
   * <p>Sequence of CurrentMaintenanceOperation_T.</p>
   **/ 
   typedef sequence<CurrentMaintenanceOperation_T> CurrentMaintenanceOperationList_T;


  /**
   * <p>In order to allow the NMS to deal with a large number of objects,
   * iterators are used.</p>
   * <p>See <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   **/

   interface CurrentMaintenanceOperationIterator_I
   {
      boolean next_n(in unsigned long how_many, 
                     out CurrentMaintenanceOperationList_T cMOList) 
         raises (globaldefs::ProcessingFailureException);

      unsigned long getLength()
         raises (globaldefs::ProcessingFailureException);

      void destroy()
         raises (globaldefs::ProcessingFailureException);
   };


  /**
   * <p>The MaintenanceMgr_I is used as a handle to gain access to the
   * maintenance operation functionalities of the NML-EML interface.</p>
   *
   * <p>A handle to an instance of this interface is gained via the
   * <a href=_emsSession.EmsSession_I.html#emsSession::EmsSession_I::getManager>
   * getManager</a> operation in Manager.</p>
   **/

   interface MaintenanceMgr_I : common::Common_I
   {
  /** 
   * <p>This operation allows the NMS to operate and release
   * the maintenance commands that are supported by a TP.</p>
   *  
   * @parm CurrentMaintenanceOperation_T maintenanceOperation:
   *  Information on the maintenance operation to perform.
   * @parm MaintenanceOperationMode_T maintenanceOperationMode:
   *  Indicates whether the maintenance operation should be operated or released.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference an TP
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references object which does not exist<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised when the operation is denied by the managed element<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void performMaintenanceOperation(
      in CurrentMaintenanceOperation_T maintenanceOperation,
      in MaintenanceOperationMode_T maintenanceOperationMode)
	 raises (globaldefs::ProcessingFailureException);

  /** 
   * <p>This operation allows the NMS to query the EMS to determine if 
   * any persistent maintenance commands have been invoked. 
   * This query is supported for the PTP, CTP, and ME objects.</p>
   *
   * @parm globaldefs::NamingAttributes_T tpOrMeName:
   * The name of the PTP, CTP, or ME object.
   * @parm unsigned long how_many: Maximum number of maintenance operations to
   * return in the first batch.
   * @parm MaintenanceOperationList_T currentMaintenanceOperationList:
   * First batch of maintenance operations.
   * @parm CurrentMaintenanceOperationIterator_I cmoIt: Iterator to access the remaining
   * maintenance operations.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS does not support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpOrMeName does not reference a valid object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpOrMeName references an object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to the managed element is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/

   void getActiveMaintenanceOperations(
      in  globaldefs::NamingAttributes_T tpOrMeName, 
      in unsigned long how_many,
      out CurrentMaintenanceOperationList_T currentMaintenanceOpeationList,
      out CurrentMaintenanceOperationIterator_I cmoIt)
        raises (globaldefs::ProcessingFailureException);

   }; // End of MaintenanceMgr_I interface

}; // end of module

#endif

