#ifndef multiLayerSubnetwork_idl
#define multiLayerSubnetwork_idl

// ********************************
// *                              *
// * multiLayerSubnetwork.idl     *
// *                              *
// ********************************

//Include list
#include "globaldefs.idl"
#include "transmissionParameters.idl"
#include "common.idl"
#include "subnetworkConnection.idl"
#include "managedElement.idl"
#include "topologicalLink.idl"
#include "terminationPoint.idl"

#pragma prefix "mtnm.tmforum.org"

  /** 
   * <a href=supportingDocumentation/overview.html>Overview of NML-EML interface</a>
   *
   * <p>This module contains the definition of the multiLayerSubnetwork structure
   * of the NML-EML interface.
   * It also contains the definition of the multi-layer subnetwork manager.</p>
   *
   * <h5> Version 2.0. </h5>
   **/

 
module multiLayerSubnetwork
{
  /**
   * <p> Topology_T is used to describe the subnetwork configuration. The EMS shall be
   * capable of providing a SubNetwork Connection through any physical 
   * termination point of any managed element that belongs to the Subnetwork.</p>
   *
   * The following values are supported:<br>
   * <dir>
   * TOPO_SINGLETON, which is used for a single NE (of any type) that is managed 
   *   independently of its Topological Link connectivity to other NEs. It may for 
   *   example be a member of a ring that is managed by a number of EMSes. It is
   *   acceptable for an EMS to represent all NEs as being in Singleton 
   *   subnetworks regardless of the actual network configuration.
   *   A singleton subnetwork does not contain internal topological links.<br>
   * TOPO_CHAIN, which is used to cover the case where two or more NEs
   *   are managed by the same EMS and are connected by Topological Links in
   *   a chain.<br>
   * TOPO_PSR, which is used to cover the case where two or more NEs
   *   are managed by the same EMS and are connected by Topological Links in
   *   a ring that is capable of supporting subnetwork connection protection.<br>
   * TOPO_OPEN_PSR, which is used to cover the case where two or more NEs
   *   of a PS ring (but not the entire ring) are managed by the same EMS.<br>
   * TOPO_SPRING, which is used to cover the case where two or more NEs
   *   are managed by the same EMS and are connected by Topological Links in
   *   a complete ring that supports Shared Line Protection.<br>
   * TOPO_OPEN_SPRING, which is used to cover cases where two or more NEs of an SP ring 
   *   (but not the entire ring) are managed by one EMS.<br>
   * TOPO_MESH, which is used to cover an arbitrary set of two or more NEs
   *   not covered by any other type.<br>
   * </dir>
   * <p>Composite subnetworks (i.e. containing other Subnetworks) are not
   * supported in this release of the interface.<p>
   **/

   enum Topology_T
   {
    TOPO_SINGLETON,
    TOPO_CHAIN,
    TOPO_PSR,
    TOPO_OPEN_PSR,
    TOPO_SPRING,
    TOPO_OPEN_SPRING,
    TOPO_MESH
   };


  /**
   * <p>Describes the NMS-specified EMS level of freedom when performing SNC operations.</p>
   * <p>EMSFL_CC_AT_SNC_LAYER: The EMS is allowed to create or delete cross-connections,
   * at the layer of the SNC <i>only</i>, that are or will be directly used by it.</p>
   * <p>EMSFL_TERMINATE_AND_MAP: In addition to EMSFL_CC_AT_SNC_LAYER, the EMS is allowed to
   * terminate and map or unmap and unterminate CTPs
   * to generate or eliminate CTPs that are or will be used by the SNC.</p>
   * <p>EMSFL_HIGHER_ORDER_SNCS: In addition to EMSFL_TERMINATE_AND_MAP, the EMS is allowed to
   * create or delete higher order SNCs that are or will be used to carry the SNC.</p> 
   * <p>EMSFL_RECONFIGURATION: The EMS is allowed to perform <i>any</i> operation that it considers
   * relevant, which includes reorganizing any SNC or CTP to allow the creation or activation
   * of the SNC or to make the subnetwork more efficient.</p> 
   **/
  enum EMSFreedomLevel_T
  {
   EMSFL_CC_AT_SNC_LAYER,
   EMSFL_TERMINATE_AND_MAP,
   EMSFL_HIGHER_ORDER_SNCS,
   EMSFL_RECONFIGURATION
  };

  /** 
   * <p>The MultiLayerSubnetwork structure is the abstraction 
   * offered by the EMS
   * to the NMS to represent a Subnetwork that is managed by the EMS system. 
   * In this document specification, Subnetwork and MultiLayerSubnetwork
   * are used interchangeably.</p>
   * <p>It represents a logical grouping or partitioning of
   * the managed elements in a way that is entirely determined by the
   * EMS.  A managed element may belong to more than one subnetwork, at
   * different layer rates (e.g. SDH & ATM). 
   * However, subnetworks cannot overlap at the same layer rate.</p>
   *
   * <p>The NMS does not create or delete Subnetworks, they are
   * managed by the EMS. The NMS has a handle to the Subnetworks
   * managed by the EMSes and can request the establishment or the
   * removal of connections within subnetworks.</p>
   *
   * <p>In this interface specification, the way the NMS requests services
   * on the Subnetworks, including establishment and removal of subnetwork connections,
   * is through the MultiLayerSubnetworkMgr_I.</p>
   * 
   * <p>For examples on how MultiLayerSubnetworks should be modelled see
   * <a href=supportingDocumentation/layers.pdf>layering</a>.</p>
   *
   * globaldefs::NamingAttributes_T <b>name</b>:
   * <dir>The name represents the name of the MultiLayerSubNetwork
   * which is assigned by the EMS upon creation.
   * The EMS is responsible for guaranteeing the uniqueness of the name
   * within the context of the MultiLayerSubnetworkMgr_I.
   * It is a readonly attribute.</dir>
   *
   * string <b>userLabel</b>:
   * <dir>The user label is seldom used on a singleton. However for rings
   * and meshes, the operator may choose to assign some logical name for the
   * subnetwork and the EMS may choose to display it on the GUI, so that the
   * operator has a consistent view of the managed network. This attribute can be set
   * by NMS through the Common_I interface service
   * <a href=_common.Common_I.html#common::Common_I::setUserLabel>setUserLabel</a>. 
   * It is a read/write attribute.</dir>
   *
   * string <b>nativeEMSName</b>:
   * <dir>This name of the subnetwork on the EMS GUI.
   * The nativeEMSName is defaulted to a NULL string. However, this could
   * be used by the EMS for its implementation dependent purpose.</dir>
   *
   * string <b>owner</b>:
   * <dir>The owner is provisionable by the NMS. This attribute can be set
   * by NMS through the Common_I interface service
   * <a href=_common.Common_I.html#common::Common_I::setOwner>setOwner</a>. 
   * It is a read/write attribute.</dir>
   *
   * Topology_T <b>subnetworkType</b>:
   * <dir>The subnetworkType gives a coarse view of the topology of the 
   * subnetwork.
   * It is a readonly attribute.</dir>
   *
   * transmissionParameters::LayerRateList_T <b>supportedRates</b>:
   * <dir>This attribute is a list (possibly empty) of potential Cross 
   * Connection Rates at which it is possible to make SNCs within the
   * subnetwork.
   * It is a readonly attribute.</dir>
   *
   * globaldefs::NVSList_T <b>additionalInfo</b>:
   * <dir>This attribute allows the communication from the EMS to the NMS of 
   * additional information which is not explicitly modelled.
   * This may be an empty list.
   * It is a readonly attribute.</dir>
   * <br>
   **/
  struct MultiLayerSubnetwork_T
  {
   globaldefs::NamingAttributes_T name;
   string userLabel;
   string nativeEMSName;
   string owner;
   Topology_T subnetworkType;
   transmissionParameters::LayerRateList_T supportedRates;
   globaldefs::NVSList_T          additionalInfo;
  };


  /**
   * <p>Sequence of MultiLayerSubnetwork_T objects.</p>
   **/
  typedef sequence<MultiLayerSubnetwork_T> SubnetworkList_T;


  /**
   * <p>In order to allow the NMS to deal with a large number of objects,
   * iterators are used.</p>
   * <p>See <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   **/

   interface SubnetworkIterator_I 
   {
      boolean next_n(in  unsigned long    how_many,
                     out SubnetworkList_T subnetworkList)
        raises (globaldefs::ProcessingFailureException);

      unsigned long getLength()
        raises (globaldefs::ProcessingFailureException);

      void destroy()
        raises (globaldefs::ProcessingFailureException);
   };


  /**
   * <p>The multiLayerSubnetworkMgr_I is used to gain access to subnetworks and
   * their operations.</p>
   *
   * <p>A handle to an instance of this interface is gained via the
   * <a href=_emsSession.EmsSession_I.html#emsSession::EmsSession_I::getManager>
   * getManager</a> operation in Manager.</p>
   **/

  interface MultiLayerSubnetworkMgr_I  : common::Common_I
  {
  /**
   * <p>This allows an NMS to request a list of the ManagedElements that
   * are associated with the specified Subnetwork.</p>
   * 
   * <p>For examples on how ManegedElements are associated with MultiLayerSubnetworks see
   * <a href=supportingDocumentation/layers.pdf>layering</a>.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   *
   * @parm globaldefs::NamingAttributes_T subnetName: Name of the subnetwork.
   * @parm unsigned long how_many: Maximum number of managed elements to return in the first batch.
   * @parm managedElement::ManagedElementList_T meList: First batch of managed elements.
   * @parm managedElement::ManagedElementIterator_I meIt: Iterator to retrieve the remaining
   * managed elements.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when subnetName does not reference a multiLayerSubnetwork
   *  object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when subnetName references an object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
   void getAllManagedElements(
         in globaldefs::NamingAttributes_T subnetName,
         in unsigned long how_many,
         out managedElement::ManagedElementList_T meList,
         out managedElement::ManagedElementIterator_I meIt) 
	     raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation has exactly the same behaviour as 
   * <a href=_multiLayerSubnetwork.MultiLayerSubnetworkMgr_I.html#multiLayerSubnetwork::MultiLayerSubnetworkMgr_I::getAllManagedElements>getAllManagedElements</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   *
   * @parm globaldefs::NamingAttributes subnetName: Name of the subnetwork.
   * @parm unsigned long how_many: Maximum number of managed element names to return
   * in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of managed element names.
   * @parm globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve the remaining
   * managed element names.
   * @raises globaldefs::ProcessingFailureException
   * As for <a href=_multiLayerSubnetwork.MultiLayerSubnetworkMgr_I.html#multiLayerSubnetwork::MultiLayerSubnetworkMgr_I::getAllManagedElements>getAllManagedElements</a>.
   **/
   void getAllManagedElementNames(
         in globaldefs::NamingAttributes_T subnetName,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This service returns a Subnetwork given a subnetwork name.</p>
   * 
   * @parm globaldefs::NamingAttributes subnetName: Name of the subnetwork to retrieve.
   * @parm MultiLayerSubnetwork_T subnetwork: Subnetwork structure returned.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when subnetName does not reference a multiLayerSubnetwork
   *  object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when subnetName references a multiLayerSubnetwork object
   *  that does not exist<br>
   * </dir>
   **/
   void getMultiLayerSubnetwork(
         in globaldefs::NamingAttributes_T subnetName,
         out MultiLayerSubnetwork_T subnetwork)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This service returns a list of TopologicalLinks which exist inside the
   * Subnetwork whose name is passed as a parameter.  For singletons, no
   * topologicalLinks will be returned.  The EMS should report topological links
   * at the "lowest" layer (i.e. closest to physical) about which it has accurate
   * knowledge.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * <p>For details on how topologicalLinks should be modelled see
   * <a href=supportingDocumentation/layers.pdf>layering</a>.</p>
   * 
   * @parm  globaldefs::NamingAttributes_T subnetName: The name of the Subnetwork.
   * @parm  unsigned long how_many: Maximum number of topological links to return in 
   * the first batch.
   * @parm  topologicalLink::TopologicalLinkList_T topoList: First batch of topological links.
   * @parm  topologicalLink::TopologicalLinkIterator_I topoIt: Iterator to retrieve the remaining
   * topological links.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when subnetName does not reference a multiLayerSubnetwork
   *  object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when subnetName references an object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
   void getAllTopologicalLinks(
         in globaldefs::NamingAttributes_T subnetName,
         in unsigned long how_many,
         out topologicalLink::TopologicalLinkList_T topoList,
         out topologicalLink::TopologicalLinkIterator_I topoIt) 
         raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation has exactly the same behaviour as 
   * getAllTopologicalLinks, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm  globaldefs::NamingAttributes_T subnetName: The name of the Subnetwork.
   * @parm unsigned long how_many: Maximum number of topological link names
   *  to return in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of topological link names.
   * @parm globaldefs::NamingAttributesListIterator_I nameIt: Iterator to retrieve the remaining
   *  topological link names.
   * @raises globaldefs::ProcessingFailureException:
   *  As for getAllTopologicalLinks.
   **/
   void getAllTopologicalLinkNames(
         in globaldefs::NamingAttributes_T subnetName,
         in  unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
         raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This service returns a subnetwork topological link given its name.</p>
   * 
   * @parm globaldefs::NamingAttributes topoLinkName: Name of the subnetwork 
   *  topological link to retrieve.
   * @parm TopologicalLink_T topoLink: Subnetwork topological link returned.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when topoLinkName does not reference a subnetwork topological
   *  link object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when topoLinkName references a subnetwork topological link
   *  object that does not exist<br>
   * </dir>
   **/
   void getTopologicalLink(
         in globaldefs::NamingAttributes_T topoLinkName,
         out topologicalLink::TopologicalLink_T topoLink)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This allows an NMS to request a list of the edge termination points for the
   * specified subnetwork, at one or more of the NMS-specified layers, and
   * that are capable of containing CTPs that can be connected
   * at one or more of the NMS-specified
   * connection layer rates.  This operation considers the capability/flexibility of the TPs,
   * not their current states.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   *
   * @parm globaldefs::NamingAttributes subnetName: Name of the subnetwork.
   * @parm transmissionParameters::LayerRateList_T tpLayerRateList: List of TP layer rates
   *  for which the edge points are to be fetched. An edge point must contain at least one of the
   *  layer rates specified to be reported.  If the list is empty then edge points
   *  of all rates are returned.
   * @parm transmissionParameters::LayerRateList_T connectionLayerRateList: List of connection 
   *  layer rates for which the edge points are to be fetched. An edge point must support 
   *  connections for at least one of the
   *  layer rates specified to be reported.  If the list is empty then edge points for all 
   *  connection rates are returned.
   * @parm unsigned long how_many: Maximum number of edge points to return in the first batch.
   * @parm terminationPoint::TerminationPointList tpList: First batch of edge points.
   * @parm terminationPoint::TerminationPointIterator_I tpIt: Iterator to retrieve the remaining
   *  edge points.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when subnetName does not reference a multiLayerSubnetwork object,
   *  or tpLayerRateList or connectionLayerRateList contain undefined values<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when subnetName references an object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
   void getAllEdgePoints(
         in globaldefs::NamingAttributes_T subnetName,
         in transmissionParameters::LayerRateList_T tpLayerRateList,
         in transmissionParameters::LayerRateList_T connectionLayerRateList,
         in unsigned long how_many,
         out terminationPoint::TerminationPointList_T tpList,
         out terminationPoint::TerminationPointIterator_I tpIt) 
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation has exactly the same behaviour as 
   * <a href=_multiLayerSubnetwork.MultiLayerSubnetworkMgr_I.html#multiLayerSubnetwork::MultiLayerSubnetworkMgr_I::getAllEdgePoints>getAllEdgePoints</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   *
   * @parm globaldefs::NamingAttributes subnetName: Name of the subnetwork.
   * @parm transmissionParameters::LayerRateList_T tpLayerRateList: List of TP layer rates
   *  for which the edge points are to be fetched. An edge point must contain at least one of the
   *  layer rates specified to be reported.  If the list is empty then edge points
   *  of all rates are returned.
   * @parm transmissionParameters::LayerRateList_T connectionLayerRateList: List of connection 
   *  layer rates for which the edge points are to be fetched. An edge point must support 
   *  connections for at least one of the
   *  layer rates specified to be reported.  If the list is empty then edge points for all 
   *  connection rates are returned.
   * @parm unsigned long how_many: Maximum number of edge points to return in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of edge point names.
   * @parm globaldefs::NamingAttributesIterator_I tpIt: Iterator to retrieve the remaining
   * edge point names.
   * @raises globaldefs::ProcessingFailureException
   * As for <a href=_multiLayerSubnetwork.MultiLayerSubnetworkMgr_I.html#multiLayerSubnetwork::MultiLayerSubnetworkMgr_I::getAllEdgePoints>getAllEdgePoints</a>.
   * </dir>
   **/
   void getAllEdgePointNames(
         in globaldefs::NamingAttributes_T subnetName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in transmissionParameters::LayerRateList_T connectionLayerRateList,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
        raises(globaldefs::ProcessingFailureException);


  /** 
   * <p>This service returns a list of PSR (UPSR or SNCP) associated termination points 
   * for the TP whose name is passed as a parameter.</p> 
   *
   * <p>To create an SNC in a TOPO_OPEN_PSR for instance, the NMS needs to have two zEnd
   * CTPs which are in the same SONET or SDH timeslot. The service allows the NMS 
   * to query the associated CTP of a given CTP or associated PTP given a PTP.
   * The timeslot of the TPs will be the same in the
   * case of a TOPO_OPEN_PSR subnetwork, but the names of the
   * two TPs will be different.
   * This operation is symmetric on the associated TPs.
   * Given a working TP, the associated TP will be the protecting TP.</p>
   *
   * <p>When this service is invoked with a TP that is not an edge point, the returned
   * TPs will be on the same Managed Element.</p>
   *    
   * <p>See <a href=_terminationPoint.html#terminationPoint::TPProtectionAssociation_T>
   * TPProtectionAssociation_T</a> for more information.</p>
   *
   * @parm globaldefs::NamingAttributes tpName: The name of the TP for which to retrieve
   * associated TPs.
   * @parm terminationPoint::TerminationPointList_T tpList: The PSR associated TPs.  If there 
   * are no PSR associated TPs, then an empty list is returned.  
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference a CTP or PTP.<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a CTP or PTP object
   *  that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void getAssociatedTP(
         in globaldefs::NamingAttributes_T tpName,
         out terminationPoint::TerminationPointList_T tpList)
        raises(globaldefs::ProcessingFailureException);


  /** 
   * <p>This method allows the NMS to query the TP pool-CTP associations.</p>
   *
   * <p>If a TPPool name is supplied, the method will return the names of all the CTPs
   * that have been grouped
   * to the supplied TPPool.
   * If a CTP name is supplied, the method will return the names of any associated TPPools.
   * An empty list is
   * returned if no associated TP pools exist for the input CTP, or if no CTPs have been grouped
   * to the input TP pool.</p>
   *  
   * @parm globaldefs::NamingAttributes tpName: The name of the TP pool or CTP for which to 
   * retrieve the association.
   * @parm unsigned long how_many: Maximum number of "contained" CTP names or 
   *  "containing" TP pool names to return in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of "contained" CTP names or 
   *  "containing" TP pool names.
   * @parm globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve the remaining
   *  "contained" CTP names or "containing" TP pool names.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference a CTP or TPPool object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a CTP to TP pool object
   *  that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void getTPGroupingRelationships(
         in globaldefs::NamingAttributes_T tpName,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
         raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This allows an NMS to request a list of the SNCs for the
   * specified Subnetwork at the specified connectionRates.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   *
   * @parm globaldefs::NamingAttributes_T subnetName: Name of the subnetwork.
   * @parm transmissionParameters::LayerRateList_T connectionRateList:
   * List of rates of the SNCs to be reported.
   * If an empty list is specified, then all SNCs of all rates are to be reported.
   * @parm unsigned long how_many: Maximum number of SNCs to be reported in the first batch.
   * @parm subnetworkConnection::SubnetworkConnectionList_T sncList: First batch of SNCs.
   * @parm subnetworkConnection::SNCIterator_I sncIt: Iterator to retrieve the
   *  remaining SNCs.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when subnetName does not reference an multiLayerSubnetwork object
   *  or connectionRateList contains undefined values<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when subnetName references object which does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached<br>
   * </dir>
   **/
   void getAllSubnetworkConnections(
         in globaldefs::NamingAttributes_T subnetName,
         in transmissionParameters::LayerRateList_T connectionRateList,
         in unsigned long how_many,
         out subnetworkConnection::SubnetworkConnectionList_T sncList,
         out subnetworkConnection::SNCIterator_I sncIt) 
         raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation has exactly the same behaviour as 
   * <a href=_multiLayerSubnetwork.MultiLayerSubnetworkMgr_I.html#multiLayerSubnetwork::MultiLayerSubnetworkMgr_I::getAllSubnetworkConnections>getAllSubnetworkConnections</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   *
   * @parm globaldefs::NamingAttributes_T subnetName: Name of the subnetwork.
   * @parm transmissionParameters::LayerRateList_T connectionRateList:
   * List of rates of the SNC names to be reported.
   * If an empty list is specified, then all SNC names of all rates are to be reported.
   * @parm unsigned long how_many: Maximum number of SNC names to be reported in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of SNC names.
   * @parm globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve the
   *  remaining SNC names.
   * @raises globaldefs::ProcessingFailureException
   * As for <a href=_multiLayerSubnetwork.MultiLayerSubnetworkMgr_I.html#multiLayerSubnetwork::MultiLayerSubnetworkMgr_I::getAllSubnetworkConnections>getAllSubnetworkConnections</a>.
   **/
   void getAllSubnetworkConnectionNames(
         in globaldefs::NamingAttributes_T subnetName,
         in transmissionParameters::LayerRateList_T connectionRateList,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
         raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This allows an NMS to request a list of the SNCs using the
   * specified termination point at the specified connection rates. A TP may be a
   * PTP in which case a full list of SNCs using any of its contained CTPs
   * is required. A TP may be a CTP, in 
   * which case only SNCs using that CTP or any of its contained CTPs are required.
   * Both end CTPs and intermediate CTPs at the same layer are considered.
   * In all cases, only SNCs that also match the specified connection rate filter are returned.</p>
   *
   * <p>All legs of a broadcast system can be retrieved using this operation where
   * the source TP of the broadcast system is used as input to the operation.
   * The output will be the list of individual SNCs that make up the broadcast
   * system.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   *
   * @parm globaldefs::NamingAttributes_T tpName: Termination point for which
   * to report SNCs.
   * @parm transmissionParameters::LayerRateList_T connectionRateList:
   * The list of rates of the SNCs to be reported.
   * If an empty list is specified, then all SNCs of all rates are to be reported.
   * @parm unsigned long how_many: Maximum number of SNCs to report in the first batch.
   * @parm subnetworkConnection::SubnetworkConnectionList_T sncList:  First batch of SNCs.
   * An SNC is
   * only reported if it respects both the tpName and connectionRateList filters.
   * @parm subnetworkConnection::SNCIterator_I sncIt: Iterator to retrieve the remaining SNCs.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised if tpName does not reference a terminationPoint object or
   *  connectionRateList contains undefined values<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references an object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
   void getAllSubnetworkConnectionsWithTP (
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T connectionRateList,
         in unsigned long how_many,
         out subnetworkConnection::SubnetworkConnectionList_T sncList,
         out subnetworkConnection::SNCIterator_I sncIt)
         raises(globaldefs::ProcessingFailureException);

  /**
   * <p>This operation has exactly the same behaviour as 
   * <a href=_multiLayerSubnetwork.MultiLayerSubnetworkMgr_I.html#multiLayerSubnetwork::MultiLayerSubnetworkMgr_I::getAllSubnetworkConnectionsWithTP>getAllSubnetworkConnectionsWithTP</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   *
   * @parm globaldefs::NamingAttributes_T tpName: Termination point for which
   * to report SNCs.
   * @parm transmissionParameters::LayerRateList_T connectionRateList:
   * The list of rates of the SNCs to be reported.
   * If an empty list is specified, then all SNCs of all rates are to be reported.
   * @parm unsigned long how_many: Maximum number of SNCs to report in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of SNC names.
   * @parm globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve the
   *  remaining SNC names.
   * @raises globaldefs::ProcessingFailureException
   * As for <a href=_multiLayerSubnetwork.MultiLayerSubnetworkMgr_I.html#multiLayerSubnetwork::MultiLayerSubnetworkMgr_I::getAllSubnetworkConnectionsWitTP>getAllSubnetworkConnectionsWithTP</a>.
   **/
   void getAllSubnetworkConnectionNamesWithTP (
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T connectionRateList,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
         raises(globaldefs::ProcessingFailureException);

  /**
   * <p>This service returns the route for the SNC whose name is specified 
   * as a parameter.</p>
   *
   * <p>The route information, in the form of crossconnects, should identify the resources
   * allocated to the SNC at the time of the request and the way in which these resources
   * are used. For example, for a resilient SNC that is implemented in the subnetwork using
   * subnetwork connection protection, all details of the route including normal and
   * alternative paths should be provided. If the SNC is using some form of dynamic
   * rerouting then it is clearly acceptable that the route include only the single
   * thread of crossconnections that is supporting the traffic (as there may be many
   * alternative potential paths that could be selected).</p>
   *
   * <p>The NMS specifies if it wants to retrieve only resources in the layer of the
   * SNC (the CCs that belong to the SNC), or higher order CCs also (the CCs of other SNCs
   * that are used to carry the traffic of the queried SNC).  The ability to retrieve
   * higher order CCs is optional.</p>
   *
   * <p>All cross-connections allocated to the SNC must be returned, even if they are not
   * active in the managed elements.  This allows the NMS to query the route that will be
   * used before activating an SNC.</p>
   *
   * @parm globaldefs::NamingAttributes sncName: The name of the SNC.
   * @parm boolean includeHigherOrderCCs: Specifies whether the higher order CCs of other
   *  SNCs used to carry the queried SNC have to be included in addition to the CCs of the 
   *  queried SNC.<br>
   * @parm subnetworkConnection::Route_T route: The route of the SNC.<br>
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if an EMS does not implement the specified
   *  includeHigherOrderCCs value<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when sncName does not reference a subnetworkConnection object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when sncName references an SNC object that does not exist<br>
   * </dir>
   **/
   void getRoute(
         in globaldefs::NamingAttributes_T sncName,
         in boolean includeHigherOrderCCs,
         out subnetworkConnection::Route_T route) 
         raises (globaldefs::ProcessingFailureException);


  /**
   * <p> This operation will return the SubnetworkConnection structure 
   * for the SNC whose name is supplied as a parameter. </p>
   *
   * @parm globaldefs::NamingAttributes sncName: The name of the SNC to retrieve.
   * @parm subnetworkConnection::SubnetworkConnection_T snc: The SNC structure retrieved.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when sncName does not reference a subnetworkConnection object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when sncName references an SNC object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void getSNC(
         in globaldefs::NamingAttributes_T sncName,
         out subnetworkConnection::SubnetworkConnection_T snc)
        raises (globaldefs::ProcessingFailureException);


  /**
   * <p> This operation will return the SubnetworkConnection structures 
   * for the SNCs whose userLabel is supplied as a parameter. </p>
   *
   * <p>This operation does not use an iterator, since the number of SNCs
   * returned is expected to be usually 1.</p>
   *
   * @parm string userLabel: The userLabel of the SNCs to retrieve.
   * @parm subnetworkConnection::SubnetworkConnection_T sncList: The SNCs retrieved.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when sncName does not reference a subnetworkConnection object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when sncName references an SNC object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void getSNCsByUserLabel(
         in string userLabel,
         out subnetworkConnection::SubnetworkConnectionList_T sncList)
        raises (globaldefs::ProcessingFailureException);


  /**
   * <p>The NMS invokes the createSNC service to request the EMS to create an SNC given
   * the parameters passed in the method.</p>
   *
   * <p>Failure : This will throw an exception if it fails.  No SNC object 
   * will be created on the EMS.</p> 
   *
   * <p>Success : SNC is created in the EMS and the SNCState is set to the appropriate state
   * in the parameter theSNC.  The parameter theSNC will contain the attributes of 
   * the created SNC.</p>
   *
   * <p>For more details on how this service affects the state of an SNC see
   * <a href=supportingDocumentation/modesOfOperation.html>SNC Management Modes of Operation</a>
   * and
   * <a href=supportingDocumentation/SNCStateDiagram.pdf>SNC state diagram</a>.</p>
   *
   * <p>If an existing SNC respects all the conditions described in createData, 
   * then the EMS is allowed to return that existing SNC.  It is also allowed for 
   * the EMS to attempt to create a different SNC as explained below.  The rest of the
   * description below applies to the cases where the EMS decides to create a new SNC.</p>
   *
   * <p>If the NMS specifies a routing constraint in the request, then the EMS must respect
   * the specified constraint even if there are pending, partial, or active SNCs using
   * the required parts of the route.</p>
   * 
   * <p>The EMS tries to find a route for the request and if found
   * returns the SubnetworkConnection_T structure back to the NMS with the 
   * members set to the appropriate values.  The EMS should attempt to find a route that
   * does not conflict or share CCs with any other existing SNC, before it resorts to
   * creating a conflicting SNC or an SNC that shares CCs.</p>
   *
   * <p>If the CTPs at the Aend and the Zend are already
   * in use by another SNC, the EMS may still create the SNC
   * or EXCPT_OBJECT_IN_USE or EXCPT_TIMESLOT_IN_USE may be thrown,
   * depending on its mode of operation.</p>
   *
   * <p>If there already exists
   * between the same termination points and with the same directionality and type, 
   * another SNC that is in the partial state, the EMS will still attempt to create
   * the new SNC.
   * If no constraint is specified, the EMS should   
   * attempt to find a different path. If constraints are specified, then the EMS attempts 
   * to create the SNC with an appropriate route.</p>
   *
   * <p>If a route cannot be found, the SNC is <b>not</b> created in the EMS 
   * and the EXCPT_UNABLE_TO_COMPLY exception 
   * is thrown (unless a more precise exception applies), indicating the reason.</p>
   *
   * <p>Depending on the SNC management mode of operation, it is acceptable for an EMS
   * to not implement this service in which case 
   * the EXCPT_NOT_IMPLEMENTED exception is thrown.</p>
   * 
   * <p>VC SNCs are normally created over a VP network. Therefore, the VPI numbers of the VC SNCs
   * specified with createData should match existing terminated and mapped VP CTPs.
   * If a VPI number does not match an existing VP CTP, then the EMS may create
   * the VP CTP as 'TERMINATED and MAPPED' if emsFreedomLevel allows it. 
   * Such a VP CTP is created with no traffic parameters. Note that such
   * automatic creation of resourceless terminated VP CTPs depends on the capability
   * of the EMS and/or the ATM NE to support VC connections directly on ATM links
   * (i.e., with no VP overlay network).</p>
   * 
   * <p>An NMS can request the EMS to create an ATM network routed SNC (VP or VC layer rates);
   * the EMS will then manage the subnetwork connection as a soft PVC. The soft PVC may
   * be completely or partially defined with regards to its source and destination CTPs.
   * The aEnd will, by definition, be the source of the Soft PVC (i.e., the originator
   * of the call) and the zEnd will be the destination (i.e., being called). In order
   * to allow the NMS to manage Soft PVCs that may have only their source CTPs in
   * the subnetwork, the ctpName parameter from TPDataList zEnd will be used to either
   * specify the VPI and/or VCI value of the destination CTP (including EMS, 
   * managedElement, PTP and ATM_NI a.k.a., the full location in the physical ATM NE)
   * or the address of the ATM interface on which the call will terminate and optionally
   * the VPI/VCI values if they are specified/known by the NMS (but not the complete
   * physical location of the VP or VC CTP).<p>
   *
   * <p>Note that all SNC state transitions (including to/from PENDING and PARTIAL)
   * are applicable to ATM VPCs and VCCs. However, the PARTIAL state should
   * only apply to plain PVCs (intermediate CTPs of a Soft PVC are automatically
   * created and deleted by the network elements and they do not usually notify 
   * the EMS).</p>
   *
   * <p>This operation is only used to create subnetwork connections in which CTPs are 
   * all cross-connected.  Trails can be created by the NMS by
   * using setTPData to terminate and map CTPs that are adjacent to the CTPs 
   * at the end of subnetwork connections created by means of createSNC.</p>
   *
   * <p>CreateSNC allows for the creation of either point-to-point
   * connections or legs of point-to-multipoint connections.</p>
   *
   * <p>To add a leg to a broadcast system, the aEnd TP in SNCCreateData_T shall
   * be populated with the common source TP of the broadcast system.
   * Each leg of a broadcast system is a separate SNC and is managed individually,
   * even though they may share cross-connects.
   * </p>
   *
   * <p>To create a broadcast system from a Point to Point SNC, the aEnd of the
   * Point to Point SNC is used as the aEnd TP in TPDataList_T.</p>
   *
   * @parm SNCCreateData_T createData: structure describing the subnetwork connection
   *  to be created.
   * @parm GradesOfImpact_T tolerableImpact: the maximum tolerable impact allowed.
   * @parm EMSFreedomLevel_T emsFreedomLevel: the maximum level of freedom allowed to the EMS
   *  to perform the creation.
   * @parm SubnetworkConnection_T theSNC:
   *  The newly created SNC.  It will have sncState and name set.  The EMS selects the SNC names
   *  so that they are not reused (within a reasonable time frame) for different SNCs.
   * @parm string errorReason: Specifies the creation error(s) if any.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if an EMS does not implement this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when a field of createData is invalid<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when fields of createData refer to an object that does
   *  not exist<br>
   * EXCPT_PROTECTION_EFFORT_NOT_MET - Raised if the NMS requests an SNC
   *  with a static protection level and protection effort that cannot be met by the EMS<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised if the EMS is unable to find an appropriate
   *  route for the SNC<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost and this
   *  prevents creation of the SNC<br>
   * EXCPT_UNSUPPORTED_ROUTING_CONSTRAINTS - Raised if the EMS does not support the 
   *  routing constraints specified<br>
   * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is not met<br>
   * </dir>
   **/
   void createSNC (
         in subnetworkConnection::SNCCreateData_T createData,
         in subnetworkConnection::GradesOfImpact_T tolerableImpact,
         in EMSFreedomLevel_T emsFreedomLevel,
         out subnetworkConnection::SubnetworkConnection_T theSNC, 
         out string errorReason)
         raises (globaldefs::ProcessingFailureException);

  /**
   * <p>This service is used to put an SNC into the ACTIVE state.</p>
   * 
   * <p><i>Success:</i> SNCState in the parameter theSNC is set to SNCS_ACTIVE.  
   * All cross-connects 
   * required for the SNC were activated successfully.
   * The errorReason parameter is set to an empty string.</p>
   *
   * <p><i>Failure:</i> No exception thrown, except in the cases listed below.
   * If the SNC or any of its network resources have changed as a result of this operation,
   * then no exception can be
   * thrown so that theSNC can be passed back to the NMS.
   * The SNCState in resulting theSNC will be either SNCS_PARTIAL or SNCS_PENDING.
   * The state will be SNCS_PARTIAL if not all
   * cross-connects on MEs have been successfully set up.  The state will be 
   * SNCS_PENDING if the EMS mode of operation prevents the activation of the SNC.
   * The errorReason parameter is set accordingly.</p>
   *
   * <p>For more details on how this service affects the state of an SNC see
   * <a href=supportingDocumentation/modesOfOperation.html>SNC Management Modes of Operation</a>
   * and
   * <a href=supportingDocumentation/SNCStateDiagram.pdf>SNC state diagram</a>.</p>
   *
   * <p> During activation of an SNC, the TPs of the SNC are configured, and the necessary 
   * cross-connects are established
   * for the SNC. An SNC can be activated while in any state.</p>
   *
   * <p>In case of an ATM SNC (VP or VC), multiple termination points (VP CTP or VC CTP) 
   * can be created as a result of an activateSNC operation. These CTPs are all created
   * in compliance with the egress and ingress traffic parameters provided in the 
   * tpsToModify structure. For example, a non terminated VP SNC created over 3 
   * managed elements will result, upon activation, in the usage of 6 VP CTPs
   * and 3 VP cross-connections.</p>
   *
   * <p>Note that the activateSNC operation can be called repeatedly and eventually
   * should succeed
   * (except in conflict cases where the SNC remains in SNCS_PENDING or SNCS_PARTIAL).
   * Should the missing cross-connects be activated in the MEs via 
   * a craft interface, for example, prior to communications to those MEs
   * being re-established, the activateSNC command ultimately should 
   * succeed when communication to the MEs is re-established 
   * (even though all cross-connects already exist).</p>
   * 
   * <p>The EMS will apply the transmissionParams specified 
   * in the tpsToModify parameter (same behaviour as
   * <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::setTPData>setTPData</a>).
   * They may be applied before or after the creation of the CCs, as appropriate.
   * Existing TP transmission parameters for which no changes
   * were requested in tpsToModify will be left unchanged.
   * However, the alarm reporting on the CTPs and the containing TPs
   * may be turned on by the EMS
   * as part of this request, unless otherwise specified via the transmission parameter
   * "AlarmReporting".  A similar behaviour is also allowed for the serviceState parameter,
   * which may be set to IN_SERVICE for the CTPs and the containing TPs.
   * See <a href=supportingDocumentation/layeredParameters.html>transmissionParameters</a>.
   * </p>
   * 
   * <p>If a given entry in the list of transmission parameters specified in
   * the TPData_T can not be successfully applied to the TP, for any reason, 
   * then the errorReason
   * field is appended with an appropriate reason text.
   * Applying transmission parameters is best-effort
   * and the resulting values of the transmission parameters
   * are provided in the updated tpsToModify parameter.</p>
   *
   * <p>An already active SNC
   * can be activated again; the EMS is allowed to not send the 
   * commands to the ME a second time for the cross connect establishment however
   * the commands may be sent for the transmission parameters.
   * While in SNCS_PARTIAL state, it is possible to activate an SNC again, this 
   * corresponds to a retry. </p>
   *
   * @parm NamingAttributes_T sncName: the name of the subnetwork connection to be deactivated.
   * @parm GradesOfImpact_T tolerableImpact: the maximum tolerable impact allowed.
   * @parm EMSFreedomLevel_T emsFreedomLevel: The maximum level of freedom allowed to the EMS
   * to perform the activation.<br>
   * @parm TPDataList_T tpsToModify: a list of TPs and parameters to apply, updated to 
   *  provide the resulting parameters.
   * @parm SubnetworkConnection theSNC: The subnetwork connection after the operation.
   * @parm string errorReason: Specifies the activation error(s) if any.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if an EMS does not implement this service; this is only
   *  allowed if the EMS does not support the PENDING state and if the PARTIAL state is
   *  unreachable<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when sncName does not refer to an SNC object, or any field
   *  in tpsToModify is invalid<br>
   * EXCPT_OBJECT_IN_USE - Raised if the SNC can not be activated because of CC or CTP conflicts
   *  with other SNCs<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised if sncName or tpsToModify reference an SNC/TP object
   *  that does not exist<br>
   * EXCPT_TIMESLOT_IN_USE - Raised if the SNC can not be activated because of timeslot conflicts
   *  with other SNCs<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised if the SNC is in pending state and is in conflict
   *  with another active or partial SNC.  If the EMS can not distinguish the
   *  EXCPT_OBJECT_IN_USE and the EXCPT_TIMESLOT_IN_USE, it is allowed to throw
   *  EXCPT_UNABLE_TO_COMPLY<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost and this
   *  prevents any change to the SNC<br>
   * </dir>
   **/
   void activateSNC(
         in    globaldefs::NamingAttributes_T               sncName,
         in    subnetworkConnection::GradesOfImpact_T       tolerableImpact,
         in    EMSFreedomLevel_T                            emsFreedomLevel,
         inout subnetworkConnection::TPDataList_T           tpsToModify,
         out   subnetworkConnection::SubnetworkConnection_T theSNC,
         out   string                                       errorReason)
     raises (globaldefs::ProcessingFailureException);


  /**
   * <p>This operation provides a way to create and activate a
   * subnetwork connection in one command.</p>
   *
   * <p>It conceptually behaves like a call to createSNC followed by a call to activateSNC.
   * Therefore, if the pending state is supported, it is possible for the SNC to be created
   * but activation to be rejected, and the resulting SNC will be in pending state.
   * If the pending state is not supported, then this is not possible and the SNC will not
   * be created if activation is rejected.
   * All success/failure conditions
   * that apply to the two base operations also apply to the combined
   * operation.  
   * If the SNC or any of its network resources have changed as a result of this operation,
   * then no exception can be
   * thrown so that theSNC can be passed back to the NMS.
   * Therefore, the exceptions that apply to activateSNC may not apply to the combined
   * operation: if the creation was successful but the activation is rejected (only possible
   * if the pending state is supported),
   * no exception shall be thrown and the resulting SNC shall be provided
   * in the out parameter theSNC.</p>
   *
   * <p>For more details on how this service affects the state of an SNC see
   * <a href=supportingDocumentation/modesOfOperation.html>SNC Management Modes of Operation</a>
   * and
   * <a href=supportingDocumentation/SNCStateDiagram.pdf>SNC state diagram</a>.</p>
   *
   * @parm SNCCreateData createData: structure describing the SNC to be created and activated.
   * @parm GradesOfImpact_T tolerableImpact: the maximum tolerable impact allowed.
   * @parm EMSFreedomLevel_T emsFreedomLevel: the maximum level of freedom allowed to the EMS
   * to perform the creation and activation.
   * @parm TPDataList_T tpsToModify: a list of TPs and parameters to apply, updated to 
   *  provide the resulting parameters.
   * @parm SubnetworkConnection theSNC: the resulting SNC.  
   *  It will have sncState and name set.  
   *  The EMS selects the SNC names
   *  so that they are not reused (within a reasonable time frame) for different SNCs.
   * @parm string errorReason: Specifies the creation and/or activation error(s) if any.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when a field of createData is invalid<br>
   * EXCPT_OBJECT_IN_USE - Raised if the SNC can not be created and activated because of
   *  CC or CTP conflicts with other SNCs<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when fields of createData reference objects that
   *  do not exist<br>
   * EXCPT_TIMESLOT_IN_USE - Raised if the SNC can not be created and activated because of
   *  timeslot conflicts with other SNCs<br>
   * EXCPT_PROTECTION_EFFORT_NOT_MET - Raised if the NMS requests an SNC with a static
   *  protection level and protection effort that cannot be met by the EMS<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised if the SNC is in conflict
   *  with another active or partial SNC and can not be created.
   *  If the EMS can not distinguish
   *  the EXCPT_OBJECT_IN_USE and the EXCPT_TIMESLOT_IN_USE, it is allowed to throw
   *  EXCPT_UNABLE_TO_COMPLY<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost and this
   *  prevents creation of the SNC<br>
   * EXCPT_UNSUPPORTED_ROUTING_CONSTRAINTS - Raised if the EMS does not support the 
   *  routing constraints specified<br>
   * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is not met<br>
   * </dir>
   **/
   void createAndActivateSNC(
         in    subnetworkConnection::SNCCreateData_T        createData,
         in    subnetworkConnection::GradesOfImpact_T       tolerableImpact,
         in    EMSFreedomLevel_T                            emsFreedomLevel,
         inout subnetworkConnection::TPDataList_T           tpsToModify,
         out   subnetworkConnection::SubnetworkConnection_T theSNC,
         out   string                                       errorReason)
     raises (globaldefs::ProcessingFailureException);


  /**
   * <p>Deactivating an SNC implies deletion in the ME of all 
   * the non-shared cross-connects that belong to this SNC. The ports are left 
   * in the same state
   * and are not put out of service.</p>
   *
   * <p>Failure - No exception thrown (except for cases described below).
   * If the SNC or any of its network resources have changed as a result of this operation,
   * then no exception can be
   * thrown so that theSNC can be passed back to the NMS.
   * The SNCState will be either SNCS_PARTIAL 
   * if the command partially completed or SNCS_ACTIVE if no cross-connects were 
   * deleted.  The errorReason will be detailed accordingly.</p>
   *
   * <p>Success - SNC is deactivated in the EMS and the SNCState is 
   * set to SNCS_PENDING in the out parameter theSNC. The parameter theSNC will contain the
   * attributes of the deactivated SNC. 
   * The errorReason parameter may be set to an empty string.</p>
   *
   * <p>For more details on how this service affects the state of an SNC see
   * <a href=supportingDocumentation/modesOfOperation.html>SNC Management Modes of Operation</a>
   * and
   * <a href=supportingDocumentation/SNCStateDiagram.pdf>SNC state diagram</a>.</p>
   *
   * <p>The EMS will apply the transmissionParams specified 
   * in the tpsToModify parameter (same behaviour as
   * <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::setTPData>setTPData</a>).
   * They may be applied before or after the creation of the CCs, as appropriate.
   * See <a href=supportingDocumentation/layeredParameters.html>transmissionParameters</a>.</p>
   * 
   * <p>If a given entry in the list of transmission parameters specified in
   * tpsToModify can not be successfully applied to the TP, for any reason, 
   * then the errorReason
   * field is appended with an appropriate reason text.
   * Applying transmission parameters is best-effort
   * and the resulting values of the transmission parameters
   * are provided in the updated tpsToModify parameter.</p>
   *
   * <p> Existing TP transmission parameters for which no changes
   * were requested in transmissionParams will be left unchanged. 
   * However, the alarm reporting on the CTPs and the containing TPs
   * may be turned off by the EMS
   * as part of this request, unless otherwise specified via the transmission parameter
   * "AlarmReporting".</p>
   * 
   * <p>An already deactivated SNC
   * can be deactivated again with success (the EMS is allowed to not send the
   * commands to the ME a second time however).
   * While in SNCS_PARTIAL state, it is possible to deactivate an 
   * SNC again, this 
   * corresponds to a retry.</p>
   *
   * <p>In case of a VP or VC SNC, this operation implies deletion in the ME of
   * all the non-shared VP or VC CTPs and VP or VC cross-connections involved in the SNC.
   * Note that in the case of a VC SNC deactivation, only the VC CTP and VC
   * cross-connections are normally deleted. VP CTPs must be explicitly
   * deleted using deactivateSNC on the VP SNC, except when emsFreedomLevel allows it. 
   * In that case, the VP CTP can be 
   * deleted along with the VC SNC if the VP CTP no longer contains any VC CTPs.</p>
   *
   * @parm NamingAttributes_T sncName: the name of the subnetwork connection to be deactivated.
   * @parm GradesOfImpact_T tolerableImpact: the maximum tolerable impact allowed.
   *  Indicates the amount of traffic disruption that the NMS user is willing
   *  to tolerate as a result of the deactivation request.
   * @parm EMSFreedomLevel_T emsFreedomLevel: the maximum level of freedom allowed to the EMS
   *  to perform the deactivation.
   * @parm TPDataList_T tpsToModify: a list of TPs and parameters to apply, updated to 
   *  provide the resulting parameters.
   * @parm SubnetworkConnection_T theSNC: the deactivated subnetwork connection.
   * @parm string errorReason: Specifies the deactivation error(s) if any.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if an EMS does not implement this service.<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when sncName does not refer to an SNC object, or any field
   *  in tpsToModify is invalid<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when sncName or tpsToModify reference an object that
   *  does not exist<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised if the SNC is fixed and can not be deactivated.<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost and this
   *  prevents the deactivation of the SNC<br>
   * </dir>
   **/
   void deactivateSNC(
         in    globaldefs::NamingAttributes_T               sncName,
         in    subnetworkConnection::GradesOfImpact_T       tolerableImpact,
         in    EMSFreedomLevel_T                            emsFreedomLevel,
         inout subnetworkConnection::TPDataList_T           tpsToModify,
         out   subnetworkConnection::SubnetworkConnection_T theSNC,
         out   string                                       errorReason)
        raises (globaldefs::ProcessingFailureException);

 
  /**
   *<p>This service allows an NMS to request the deletion of a 
   * SubnetworkConnection on a specified subnetwork.</p>
   *
   * <p>To delete a leg from a broadcast system, the subnetworkConnection 
   * that represents the leg is used as input to the deleteSNC operation.</p>
   *
   * <p>The SNC must not be in the active or partial state.</p>
   *
   * <p>Failure - An exception will be thrown if the operation fails.  The SNC object 
   * will not be deleted on the EMS.  The errorReason field of the exception
   * will contain the reason for the failure.</p>
   *
   * <p>Success - The SNC object is deleted on the EMS.</p>
   *
   * <p>For more details on how this service affects the state of an SNC see
   * <a href=supportingDocumentation/modesOfOperation.html>SNC Management Modes of Operation</a>
   * and
   * <a href=supportingDocumentation/SNCStateDiagram.pdf>SNC state diagram</a>.</p>
   *
   * @parm NamingAttributes_T sncName: the name of the subnetwork connection to be deleted.
   * @parm EMSFreedomLevel_T emsFreedomLevel: the maximum level of freedom allowed to the EMS
   *  to perform the deletion.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if an EMS does not implement this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when sncName does not refer to an SNC object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when sncName references an object that does not exist<br>
   * EXCPT_NOT_IN_VALID_STATE - Raised if the SNC is in the partial or active state<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost and this
   *  prevents the deletion of the SNC<br>
   * </dir>
   **/
   void deleteSNC(
         in  globaldefs::NamingAttributes_T sncName,
         in  EMSFreedomLevel_T emsFreedomLevel)
        raises (globaldefs::ProcessingFailureException);


  /**
   * <p>This operation provides a way to deactivate and then delete a 
   * subnetwork connection in one operation.</p>
   *
   * <p>It conceptually behaves like a call to deactivateSNC followed by a call to deleteSNC.
   * All success/failure conditions 
   * that apply to the two base operations also apply to the combined
   * operation.  
   * If the SNC or any of its network resources have changed as a result of this operation,
   * then no exception can be
   * thrown so that theSNC can be passed back to the NMS.
   * Therefore, the exceptions that apply to deleteSNC may not apply to the combined
   * operation: if the deactivation changed the SNC but the deletion is rejected,
   * no exception should be thrown and the resulting SNC should be provided
   * in the out parameter theSNC.</p>
   *
   * <p>The parameter theSNC
   * will identify the SNC after the combined operation.
   * If the operation is entirely successful,
   * sncState will be SNCS_NONEXISTENT.
   * In that case, this object does not exist on the EMS and the NMS should only look at 
   * sncState.  This work around is so that the NMS can have a 
   * combined operation. </p>
   *
   * <p>For more details on how this service affects the state of an SNC see
   * <a href=supportingDocumentation/modesOfOperation.html>SNC Management Modes of Operation</a>
   * and
   * <a href=supportingDocumentation/SNCStateDiagram.pdf>SNC state diagram</a>.</p>
   *
   * @parm NamingAttributes_T sncName: the name of the subnetwork connection to be deactivated
   *  and deleted.
   * @parm GradesOfImpact_T tolerableImpact:
   *  indicates the amount of traffic disruption that the NMS user is willing
   *  to tolerate as a result of the deactivation and deletion request.
   * @parm EMSFreedomLevel_T emsFreedomLevel: the maximum level of freedom allowed to the EMS
   *  to perform the deactivation and deletion.
   * @parm TPDataList_T tpsToModify: a list of TPs and parameters to apply, updated to 
   *  provide the resulting parameters.
   * @parm SubnetworkConnection theSNC: the deactivated and deleted subnetwork connection.
   * @parm string errorReason: Specifies the deactivation and/or deletion error(s) if any.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when sncName does not refer to an SNC object, or any field
   *  in tpsToModify is invalid<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when sncName or tpsToModify reference an object that
   *  does not exist<br>
   * EXCPT_UNABLE_TO_COMPLY - Raised if the SNC is fixed and can not be deactivated.<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost and this
   *  prevents the deactivation of the SNC<br>
   * </dir>
   **/
   void deactivateAndDeleteSNC(
         in    globaldefs::NamingAttributes_T               sncName,
         in    subnetworkConnection::GradesOfImpact_T       tolerableImpact,
         in    EMSFreedomLevel_T                            emsFreedomLevel,
         inout subnetworkConnection::TPDataList_T           tpsToModify,
         out   subnetworkConnection::SubnetworkConnection_T theSNC,
         out   string                                       errorReason)
        raises (globaldefs::ProcessingFailureException);


  /**
   * <p>The NMS uses this operation to check if it is possible to
   * create and maybe activate an SNC as specified in the input parameters.</p>
   *
   * <p>The test should check for the existence of hardware that will support
   * the requested SNC.  If the considerResources parameter is false, the check
   * must be independent of the current specific resource usage in the subnetwork
   * (as in createSNC).  If the
   * considerResources parameter is true, the check must consider the
   * current specific resource usage in the subnetwork (as in activateSNC);
   * in that case, the rules of the EMS' mode of operation apply to the check (see
   * <a href=supportingDocumentation/modesOfOperation.html>SNC Management Modes of 
   * Operation</a>).</p>
   *
   * @parm SNCCreateData_T createData: data about the potential SNC.
   * @parm TPDataList_T tpsToModify: a list of TPs and parameters that would be applied
   *  to the potential SNC.
   * @parm boolean considerResources: indicates whether or not resource allocation
   *  must be considered.
   * @parm boolean valid: indicates if this is a valid SNC.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service; the EMS
   *  may not support this operation at all or may not support all values for considerResources<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised if sncData is not well formed<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost and this 
   *  prevents checking the validity of the SNC<br>
   * EXCPT_UNSUPPORTED_ROUTING_CONSTRAINTS - Raised if the EMS does not support the 
   *  routing constraints specified.
   * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is not met<br>
   * </dir>
   **/
   void checkValidSNC(
         in subnetworkConnection::SNCCreateData_T createData,
         in subnetworkConnection::TPDataList_T tpsToModify,
         in boolean considerResources,
         out boolean valid)
         raises (globaldefs::ProcessingFailureException);


  /**
   * <p>This service returns all TP Pools within a Subnetwork contained in an EMS.
   * The TP Pool is a TP used to logically group TPs. The TP Pool does not affect TP
   * containment. TP containment remains from the Network Element view.
   * Given a TP Pool, the NMS could then determine all the TPs that are associated with
   * the TP Pool, for
   * the purpose of logical partitioning or grouping.
   * See <a href=_multiLayerSubnetwork.MultiLayerSubnetworkMgr_I.html#multiLayerSubnetwork::MultiLayerSubnetworkMgr_I::getTPGroupingRelationships>getTPGroupingRelationships</a>.
   * 
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm globaldefs::NamingAttributes_T subnetworkName: Name of the subnetwork for which to
   * retrieve TP pools.
   * @parm  unsigned long how_many: Maximum number of TP pools to return in the first batch.
   * @parm  terminationPoint::TerminationPointList tpList: First batch of TP pools.
   * @parm  terminationPoint::TerminationPointIterator_I tpIt: Iterator to retrieve the remaining
   * TP pools.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when subnetworkName does not reference a multiLayerSubnetwork
   *  object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when subnetworkName references an object that does not
   *  exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
   void getAllTPPools(
         in globaldefs::NamingAttributes_T subnetworkName,
         in unsigned long how_many,
         out terminationPoint::TerminationPointList_T tpList,
         out terminationPoint::TerminationPointIterator_I tpIt) 
         raises(globaldefs::ProcessingFailureException);


/**
   * <p>This operation has exactly the same behaviour as 
   * <a href=_multiLayerSubnetwork.MultiLayerSubnetworkMgr_I.html#multiLayerSubnetwork::MultiLayerSubnetworkMgr_I::getAllTPPools>getAllTPPools</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   *
   * @parm globaldefs::NamingAttributes_T subnetworkName: Name of the subnetwork.
   * @parm unsigned long how_many: Maximum number of TP pool names to return in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of TP pools.
   * @parm globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve the remaining TP pools.
   * @raises globaldefs::ProcessingFailureException
   * As for <a href=_multiLayerSubnetwork.MultiLayerSubnetworkMgr_I.html#multiLayerSubnetwork::MultiLayerSubnetworkMgr_I::getAllTPPools>getAllTPPools</a>.
   **/
   void getAllTPPoolNames(
         in globaldefs::NamingAttributes_T subnetworkName,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
         raises(globaldefs::ProcessingFailureException);

    };

};
  
#endif

