#ifndef         protection_idl
#define         protection_idl

// *************************************
// *                                   *
// * protection.idl                    *
// *                                   *
// *************************************

//Include list
#include "globaldefs.idl"
#include "transmissionParameters.idl"
#include "common.idl"

#pragma prefix "mtnm.tmforum.org"

  /** 
   * <a href=supportingDocumentation/overview.html>Overview of NML-EML interface</a>
   *
   * <p>This module contains the definition of the protection structure
   * of the NML-EML interface.
   * It also contains the definition of the protection manager.</p>
   *
   * <h5> Version 2.0. </h5>
   **/

module protection
{
  /**
   * <p>The protection scheme state identifies the state in which the
   * protection scheme is in.</p>
   **/
  enum ProtectionSchemeState_T
  {
   PSS_UNKNOWN,
   PSS_AUTOMATIC,
   PSS_FORCED_OR_LOCKED_OUT
  };


  /**
   * <p>The protection type identifies whether a protection switch
   * is an MS protection switch or an SNCP protection switch.</p>
   **/
  enum ProtectionType_T
  {
   PT_MSP_APS,
   PT_SNCP
  };


  /**
   * <p>The switch reason reflects the reason why a
   * switch occurred.<br>
   * SR_NA is used upon retrieval of switch data for non-revertive groups, if a more precise
   * value is not available.<br>
   * SR_RESTORED is used for revertive groups to indicate a return to the normal state.<br>
   * SR_SIGNAL_MISMATCH is used in the case the signal is ok, but is identified as coming
   * from an incorrect source: TRAIL_TRACE_IDENTIFIER_MISMATCH, Signal Label Mismatch, etc.<br>
   * SR_AUTOMATIC_SWITCH is used during protection switch notification, or during retrieval of
   * switch data if a protection switch is currently active, when the exact switch reason
   * is unknown.<br>
   * SR_MANUAL indicates a switch that was requested by the operator
   * and includes forced switches.
   * </p>
   **/
  enum SwitchReason_T
  {
   SR_NA,
   SR_RESTORED,
   SR_SIGNAL_FAIL,
   SR_SIGNAL_MISMATCH,
   SR_SIGNAL_DEGRADE,
   SR_AUTOMATIC_SWITCH,
   SR_MANUAL
  };


  /**
   * <p> This type identifies the possible protection switch commands.
   * See ITU-T Recommendation G.841 for definitions.</p>
   **/
  enum ProtectionCommand_T 
  {
    PC_CLEAR,
    PC_LOCKOUT,
    PC_FORCED_SWITCH,
    PC_MANUAL_SWITCH,
    PC_EXERCISER
  };


  /**
   * <p>The protection group type identifies the type of the
   * protection Group.</p>
   **/
  enum ProtectionGroupType_T
   {
    PGT_MSP_1_PLUS_1,
    PGT_MSP_1_FOR_N,
    PGT_2_FIBER_BLSR,
    PGT_4_FIBER_BLSR
   };


  /**
   * <p>Reversion mode is used to indicate whether, after repair of a
   * failed resource, an additional switch should be
   * made to revert to the preferred resource.
   * Revertive modes may require a wait to restore (WTR) time
   * setting.</p>
   **/
  enum ReversionMode_T
  {
   RM_UNKNOWN,
   RM_NON_REVERTIVE,       // i.e. non revertive 
   RM_REVERTIVE // when the failed resource is repaired,
                // it reverts to the preferred resource.
  };


  /**
   * <p>The struct ProtectionGroup_T represents a protection group,
   * which is used to model MS layer protection.</p>
   *
   * <p>See <a href=supportingDocumentation/protectionSwitch.pdf>Protection Switch</a>
   * for more information.</p>
   *
   * globaldefs::NamingAttributes_T <b>name</b>:
   * <dir>The name represents the name of the
   * Protection Group which is assigned by the EMS upon creation.
   * The EMS is responsible for guaranteeing the uniqueness of the name
   * within the context of the ManagedElement.
   * It is a readonly attribute.</dir>
   *
   * string <b>userLabel</b>:
   * <dir>The userLabel is provisionable by the NMS and would typically represent
   * the ring-id of a ring. This attribute can be set
   * by NMS through the Common_I interface service
   * <a href=_common.Common_I.html#common::Common_I::setUserLabel>setUserLabel</a>. 
   * It is a read/write attribute.</dir>
   *
   * string <b>nativeEMSName</b>:
   * <dir>The native name of the protection group is the AID of the
   * protection group itself. In case of the 4-Fiber BLSR (MSSPRING) group, the managed 
   * element usually has only one group, whereas it is represented as three groups in this
   * interface. Therefore the native name of the 4-Fiber group will be
   * the AID of the 4-Fiber group. The native name of the component APS (MSP)
   * groups is set to some useful name chosen by the EMS. Its
   * aim is to provide a "nomenclature bridge" to aid relating information
   * presented on NMS displays to EMS displays (via GUI cut through).
   * This is never set to a null string.</dir>
   *
   * string <b>owner</b>:
   * <dir>The owner is provisionable by the NMS. This attribute can be set
   * by NMS through the Common_I interface service
   * <a href=_common.Common_I.html#common::Common_I::setOwner>setOwner</a>. 
   * It is a read/write attribute.</dir>
   *
   * ProtectionGroupType_T <b>protectionGroupType</b>:
   * <dir>Defines the type of scheme this group represents (e.g. 2f,4f blsr etc).
   * It is a readonly attribute.</dir>
   *
   * ProtectionSchemeState_T <b>protectionSchemeState</b>:
   * <dir>Identifies the current protection scheme state.
   * It is a readonly attribute.</dir>
   *
   * ReversionMode_T <b>reversionMode</b>:
   * <dir>Defines whether the protection scheme is revertive or not.
   * It is a readonly attribute.</dir>
   *
   * transmissionParameters::LayerRate_T <b>rate</b>:
   * <dir>Line rate of the PTPs of the protection group.
   * It is a readonly attribute.</dir>
   *
   * globaldefs::NamingAttributesList_T <b>pgpTPList</b>:
   * <dir>This is the list of TPs that belong in the protection group.
   * The list of TPs is partially ordered. The protecting TP always
   * trails its worker TPs. The East TPs are always contiguous in the list, as well
   * as West TPs.
   * </dir>
   *
   * globaldefs::NVSList_T <b>pgpParameters</b>:
   * <dir>The pgpParameters contains a name value list for the known parameters
   * of the protection group.  Non-applicable parameters and parameters for which
   * the value is unknown to the EMS may be left out.<br>
   * <TABLE BORDER=2 COLS=3 WIDTH="80%">
   * <TR>
   * <TD>ProtectionGroupType </TD><TD>Name</TD><TD>Value</TD>
   * </TR>
   * <TR>
   * <TD>1+1 MSP<br>2F BLSR<br>4F BLSR<br>1:N MSP</TD><TD>"SwitchMode"</TD><TD>
   * "SingleEnded"<br>
   * "DualEnded"<br>
   * "G841_NonStandard"<br>
   * "Unknown"
   * </TD>
   * </TR>
   * <TR>
   * <TD>2F BLSR<br>4F BLSR</TD><TD>"SPRINGProtocol"</TD><TD>
   * "Standard"<br>
   * "TransOceanic"<br>
   * </TD>
   * </TR>
   * <TR>
   * <TD>2F BLSR<br>4F BLSR</TD><TD>"SPRINGNodeId"</TD><TD>
   * The SPRINGNodeId is used to identify the managedElement during
   * creation of SNCs. This is needed for BLSRs to identify the
   * ingress and the egress nodes so that they know where to
   * loop around in case of failure.
   * "0".."15" (may be any other string that matches the SPRINGNodeId transmission
   * parameter values), "Unknown"
   * </TD>
   * </TR>
   * <TR>
   * <TD>2F BLSR<br>4F BLSR<br> 1+1 MSP<br> 1:N MSP </TD>
   * <TD>"wtrTime"</TD><TD>
   *  Wait To Restore time, in seconds.  "-1" may be used to indicate an unknown value
   *  or when this parameter is not applicable<br>
   * </TD>
   * </TR>
   * <TR>
   * <TD>2F BLSR<br>4F BLSR<br> </TD>
   * <TD>"SwitchPosition"</TD><TD>
   *  "IDLE","PASS_THROUGH","SWITCH" <br>
   * </TD>
   * </TR>
   * <TR>
   * <TD>2F BLSR<br> 1:N MSP </TD>
   * <TD>"nonPre-EmptibleTraffic"</TD><TD>
   *  "ALLOWED","NOT_ALLOWED" <br>
   * </TD>
   * </TR>
   * <TR>
   * <TD>2F BLSR<br>4F BLSR<br> 1+1 MSP<br> 1:N MSP </TD>
   * <TD>"HoldOffTime"</TD><TD>
   *  Time duration for which the alarm condition must persist before the switch takes place.
   *  "Unknown", "Infinite", or in milliseconds.<br>
   * </TD>
   * </TR>
   * <TR>
   * <TD>2F BLSR<br>4F BLSR<br> 1+1 MSP<br> 1:N MSP </TD>
   * <TD>"LODNumSwitches"</TD><TD>
   *  LODNumSwitches and LODDuration are used together to specify when Lock Out should occur.
   *  if the specified number of switches occur within the specified duration, the result is 
   *  Lock Out for that group. <br>
   * </TD>
   * </TR>
   * <TR>
   * <TD>2F BLSR<br>4F BLSR<br> 1+1 MSP<br> 1:N MSP </TD>
   * <TD>"LODDuration"</TD><TD>
   *  LODNumSwitches and LODDuration are used together to specify when Lock Out should occur.
   *  if the specified number of switches occur within the specified duration, the result is 
   *  Lock Out for that group.
   *  Value is in seconds.<br>
   * </TD>
   * </TR>
   * </TABLE>
   * It is a readonly attribute.</dir>
   *
   * globaldefs::NVSList_T <b>additionalInfo</b>
   * <dir>This attribute allows the communication from the EMS to the NMS of additional 
   * information which is not explicitly modelled.
   * This may be an empty list.</dir>
   **/
  struct ProtectionGroup_T
  {
   globaldefs::NamingAttributes_T name;
   string userLabel;
   string nativeEMSName;
   string owner;
   ProtectionGroupType_T protectionGroupType;
   ProtectionSchemeState_T protectionSchemeState;
   ReversionMode_T reversionMode;
   transmissionParameters::LayerRate_T rate;
   globaldefs::NamingAttributesList_T pgpTPList;
   globaldefs::NVSList_T pgpParameters;
   globaldefs::NVSList_T additionalInfo;
  };


  /**
   * <p>Sequence of ProtectionGroup_T.</p>
   **/
  typedef sequence <ProtectionGroup_T> ProtectionGroupList_T;


  /**
   * <p>This structure is used
   * to respond to queries regarding the current protection switch status of a
   * protection group or an SNC.</p>
   *
   * <p>See <a href=supportingDocumentation/protectionSwitch.pdf>Protection Switch</a>
   * for more information.</p>
   *
   * ProtectionType_T <b>protectionType</b>:
   * <dir>The type of protection.</dir>
   *
   * SwitchReason_T <b>switchReason</b>:
   * <dir>The reason the last switch occurred.</dir>
   *
   * transmissionParameters::LayerRate_T <b>layerRate</b>:
   * <dir>The layer which this switch is relevant to.</dir>
   *
   * globaldefs::NamingAttributes_T <b>groupName</b>:
   * <dir>Identifies the protectionGroup for which protection switch status is being reported.
   * NULL if protectionType is SNCP.</dir>
   * 
   * globaldefs::NamingAttributes_T <b>protectedTP</b>:
   * <dir>
   * This is the TP that is protected.<br>
   * For an SNCP, this is always the reliable TP.<br>
   * For a retrieval of a 2F BLSR, each TP is protected,
   * and two SwitchData_T are returned.<br>
   * For a retrieval of a 4FMSSPR, each worker TP is protected,
   * and two SwitchData_T are returned.<br>
   * For a retrieval of a 1:N MSP, each worker TP is protected,
   * and N SwitchData_T are returned.<br>
   * For a revertive 1+1 MSP, this is always the worker TP.<br>
   * For a retrieval of a non-revertive 1+1 MSP switch, this is the active TP.
   * </dir>
   * 
   * globaldefs::NamingAttributes_T <b>switchToTP</b>:
   * <dir>Identifies the TP which is being switched to.<br>
   * This identifies the 
   * TP that is the active source after the switch, or currently active if
   * no protection switch is currently active.</dir>
   *
   * globaldefs::NVSList_T <b>additionalInfo</b>
   * <dir>This attribute allows the communication from the EMS to the NMS of additional 
   * information which is not explicitly modelled.
   * This may be an empty list.</dir>
   **/
  struct SwitchData_T
  { 
   ProtectionType_T protectionType; 
   SwitchReason_T switchReason; 
   transmissionParameters::LayerRate_T layerRate; 
   globaldefs::NamingAttributes_T groupName;
   globaldefs::NamingAttributes_T protectedTP; 
   globaldefs::NamingAttributes_T switchToTP; 
   globaldefs::NVSList_T additionalInfo;
  };


  /**
   * <p>Sequence of SwitchData_T.</p>
   **/
  typedef sequence<SwitchData_T> SwitchDataList_T;


  /**
   * <p>The protectionManager is used as a handle to gain access to the
   * protection functionalities of the NML-EML interface. In this
   * release, only retrieval functionalities of the protection (of both the MS (line) level
   * and SNC level) are supported.</p>
   *
   * <p>A handle to an instance of this interface is gained via the
   * <a href=_emsSession.EmsSession_I.html#emsSession::EmsSession_I::getManager>
   * getManager</a> operation in Manager.</p>
   **/


  /**
   * <p>In order to allow the NMS to deal with a large number of objects,
   * iterators are used.</p>
   * 
   * <p>See <a href=supportingDocumentation/iterators.html>iterator
   * overview</a> for information on how iterators are used in this
   * interface.</p>
   **/
  interface ProtectionGroupIterator_I
  {
   boolean next_n(in unsigned long          how_many,
                  out ProtectionGroupList_T pgpList)
     raises(globaldefs::ProcessingFailureException);
		
   unsigned long getLength()
     raises(globaldefs::ProcessingFailureException);
		
   void destroy()
     raises(globaldefs::ProcessingFailureException);
   };


  interface ProtectionMgr_I: common::Common_I
  {
  /**
   * <p>This operation is used by the client to discover all the 
   * protection groups currently in operation for the managed
   * element.</p>
   *
   * @parm  globaldefs::NamingAttributes_T meName:
   *        the name of the managed element for which the request is made.
   * @parm  unsigned long how_many: Maximum number of protection groups 
   *        to report in the first batch.
   * @parm  ProtectionGroupList_T pgList: First batch of protection groups.
   * @parm  ProtectionGroupIterator_I pgIt: Iterator used to access the remaining PGs, if any.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when meName does not reference a managedElement object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when meName references object which does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void getAllProtectionGroups(
         in globaldefs::NamingAttributes_T meName,
         in unsigned long how_many,
         out ProtectionGroupList_T pgList,
         out ProtectionGroupIterator_I pgpIt)
         raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation is used to get the current status of a 
   * protectionGroup. This service is needed so that even if a filter
   * is established, the NMS can query the status of a protection 
   * group.</p>
   *
   * @parm globaldefs::NamingAttributes_T protectionGroupName:
   *       the name of the protection Group that the client is
   *       interested in.
   * @parm protection::ProtectionGroup_T protectionGroup: the returned protection group.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when protectionGroupName does not reference a protectionGroup<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when meName references object which does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void getProtectionGroup(
         in  globaldefs::NamingAttributes_T pgName,
         out protection::ProtectionGroup_T  protectionGroup)
         raises (globaldefs::ProcessingFailureException);


  /**
   * <p>This operation gets the list of names of CTPs that are configured to carry
   * Non-preemptible Unprotected extra Traffic.  The result is independent of the current
   * switch status.</p>
   * 
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   *
   * @parm globaldefs::NamingAttributes_T groupName:
   *          Name of the protection group.
   * @parm  unsigned long how_many:
   *       Maximum number of CTPs to be returned in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList:
   *       The first batch of CTPs that have NUT turned on.
   * @parm globaldefs::NamingAttributesIterator_I nameIt:
   *       The iterator used to retrieve the remaining CTPs that have NUT turned on.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when pgName does not reference a protectionGroup object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references object which does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators
   *  that the EMS can support has been reached.
   * </dir>
   **/
   void getAllNUTTPNames(
         in globaldefs::NamingAttributes_T pgName,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
         raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation gets the list of names of CTPs that can carry preemptible extra
   * traffic.  The result is independent of the current
   * switch status.</p>
   * 
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   *
   * @parm globaldefs::NamingAttributes_T groupName:
   *          Name of the protection group.
   * @parm  unsigned long how_many:
   *       Maximum number of CTPs to be returned in the first batch.
   * @parm globaldefs::NamingAttributesList_T     tpNameList:
   *       The first batch of CTPs that can carry preemptible extra traffic.
   * @parm globaldefs::NamingAttributesIterator_I tpit:
   *       The iterator used to retrieve the remaining CTPs that can carry preemptible
   *       extra traffic.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when pgName does not reference a protectionGroup object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references object which does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators
   *  that the EMS can support has been reached.
   * </dir>
   **/
   void getAllPreemptibleTPNames(
         in globaldefs::NamingAttributes_T pgName,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
         raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation gets the list of CTPs that can carry protected
   * traffic.  The result is independent of the current
   * switch status.</p>
   * 
   * @parm globaldefs::NamingAttributes_T pgName:
   *          Name of the protection group.
   * @parm  unsigned long how_many:
   *       Maximum number of CTPs to be returned in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList:
   *       The first batch of CTPs that can carry protected traffic.
   * @parm globaldefs::NamingAttributesIterator_I nameIt:
   *       The iterator used to retrieve the remaining CTPs that can carry protected traffic.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when pgName does not reference a protectionGroup object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when pgName references object which does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
   void getAllProtectedTPNames(
         in globaldefs::NamingAttributes_T pgName,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This service is used by the NMS to get the latest switch status
   * on a SNC or a MSP group. 
   *
   * <p>When used on the reliable CTP of an SNC, a single struct is returned and the
   * group name is NULL. The switchToTP indicates the presently active
   * source of the traffic to the protectedTP.
   *
   * <p> When used on a 1+1 MSP, a single struct is provided with the 
   * relevant data.
   *
   * <p> When used on a 1:N MSP, a struct per worker TP is presented with
   * protectedTP being the worker TP Name and the switchToTP identifying
   * the present source of the traffic.
   *
   * <p> When used on a 2F BLSR, two structs are returned, one per TP. 
   * In a stable state, the protectedTP and the switchToTP are the same TP. 
   * In a switched state, the switchToTP is the same for both protectedTPs.
   *
   * <p> When used on a 4F BLSR, two structs are returned,
   * each one identifying a span with the protectedTP being the worker TP 
   * and the switchToTP identifying the present source of the ring traffic
   * for that span.
   *
   * <p>See <a href=supportingDocumentation/protectionSwitch.pdf>Protection Switch</a>
   * for more information.</p>
   *
   * @parm   globaldefs::NamingAttributes_T reliableSinkCtpOrGroupName:
   *         This is the CTP that is the output of a service selector in case
   *         of the SNC or the group name for which the switch data is being
   *         requested.
   * @parm   protection::SwitchDataList_T: The current protection switch status
   * of the CTP or PG provided.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when reliableSinkCtpName does not reference a CTP object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when reliableSinkCtpName references object which does
   *  not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void retrieveSwitchData(
         in globaldefs::NamingAttributes_T reliableSinkCtpOrGroupName,
         out protection::SwitchDataList_T switchData)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p> This service is used to execute a protection switch. The protection
   * switch may be performed via a protection switch command, on a protection 
   * group or on a CTP involved in an 
   * SNCP. The NMS requests the EMS to move the traffic received from the fromTP
   * to the toTP.  The same command is used to clear all existing commands.</p>
   * 
   * <p>For 4-fiber SONET/SDH SPRINGS, the span switch is performed on the PGT_MSP_1_FOR_N         
   * protection group, and the ring switch on the PGT_4_FIBER_BLSR group.</p>
   * 
   * <p>See 
   * <a href=supportingDocumentation/protectionSwitch.pdf>Protection Switch</a>
   * for more information.</p>
   *
   * @parm   ProtectionCommand_T protectionCommand: The command to be performed
   * @parm   globaldefs::NamingAttributes_T reliableSinkCtpOrGroupName:
   *         This is the CTP that is the output of a service selector in case
   *         of the SNC or the group name for which the switch data is being
   *         requested.
   * @parm   globaldefs::NamingAttributes_T fromTp: The present source of
   *         the traffic
   * @parm   globaldefs::NamingAttributes_T toTp:   The requested source of
   *         the traffic after the command.
   * @parm   protection::SwitchData_T switchData: The protection switch status
   *         of the toTp provided after the execution of the command.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised when an EMS is unable to support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when reliableSinkCtpOrGroupName, fromTp, or toTp
   *  reference objects of the correct type, but that are invalid in the context of this
   *  operation<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when reliableSinkCtpOrGroupName references  
   *  a CTP or PG object that does not exist, or when fromTp or toTp references a CTP
   *  object that does not exist <br>
   * EXCPT_UNABLE_TO_COMPLY - Raised if the EMS is unable to perform the operation<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to the managed element is lost<br>
   **/
   void performProtectionCommand(
         in  ProtectionCommand_T protectionCommand,
         in  globaldefs::NamingAttributes_T reliableSinkCtpOrGroupName,
         in  globaldefs::NamingAttributes_T fromTp,
         in  globaldefs::NamingAttributes_T toTp,
         out protection::SwitchData_T switchData)
     raises(globaldefs::ProcessingFailureException);

   };
};       // end of module

#endif

