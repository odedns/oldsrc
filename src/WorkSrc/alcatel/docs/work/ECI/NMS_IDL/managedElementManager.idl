#ifndef managedElementManager_idl
#define managedElementManager_idl

// ********************************
// *                              *
// * managedElementManager.idl    *
// *                              *
// ********************************

//Include list
#include "globaldefs.idl"
#include "common.idl"
#include "managedElement.idl"
#include "transmissionParameters.idl"
#include "terminationPoint.idl"
#include "notifications.idl"
#include "subnetworkConnection.idl"

#pragma prefix "mtnm.tmforum.org"

  /** 
   * <a href=supportingDocumentation/overview.html>Overview of NML-EML interface</a>
   *
   * <p>This module contains the definition of the managed element manager
   * of the NML-EML interface.</p>
   *
   * <h5> Version 2.0. </h5>
   **/


module managedElementManager
{
 

  /**
   * <p>The managedElementManager is used to gain access to operations
   * which deal with managed elements and termination points.</p>
   *
   * <p>A handle to an instance of this interface is gained via the
   * <a href=_emsSession.EmsSession_I.html#emsSession::EmsSession_I::getManager>
   * getManager</a> operation in Manager.</p>
   **/

  interface ManagedElementMgr_I : common::Common_I
    {

  /**
   * <p>This allows an NMS to request details of all of the Managed Elements that
   * are under the control of this ManagedElementMgr_I.</p>
   * 
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm  unsigned long how_many: Maximum number of MEs to report in the first batch.
   * @parm  ManagedElementList_T meList: First batch of MEs.
   * @parm  managedElement::ManagedElementIterator_I meIt: Iterator to retrieve the remaining MEs.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.</dir>
   **/
      void getAllManagedElements(
            in unsigned long how_many,
            out managedElement::ManagedElementList_T meList,
            out managedElement::ManagedElementIterator_I meIt) 
               raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation has exactly the same behaviour as 
   * <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::getAllManagedElements>getAllManagedElements</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   * 
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm  unsigned long how_many: Maximum number of ME names to return in the first batch.
   * @parm  globaldefs::NamingAttributesList_T nameList: First batch of ME names.
   * @parm  globaldefs::NamingAttributesListIterator_I nameIt: Iterator to retrieve remaining
   * ME names.
   * @raises globaldefs::ProcessingFailureException
   * As for <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::getAllManagedElements>getAllManagedElements</a>
   **/
   void getAllManagedElementNames(
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
         raises(globaldefs::ProcessingFailureException);

  /** 
   * <p>This service returns the list of subnetwork names that the  
   * Managed Element supplied as an input parameter belongs to.<p>
   * @parm globaldefs::NamingAttributes managedElementName: The name of the managed element
   * for which to retrieve the containing subnetwork names. 
   * @parm globaldefs::NamingAttributesList_T subnetNames: The names of the subnetworks
   * this NE belongs to.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when managedElementName does not reference a managed
   *  element object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME object
   *  that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void getContainingSubnetworkNames(
         in globaldefs::NamingAttributes_T managedElementName,
         out globaldefs::NamingAttributesList_T subnetNames)
         raises (globaldefs::ProcessingFailureException);

  /**
   * <p>This allows an NMS to request all of the PTPs on the specified  
   * Managed Element, that contain one or more of the NMS-specified PTP layer rates, 
   * and that are capable of supporting one or more of the NMS-specified
   * connection layer rates.
   * If there are no PTPs that match the layer constraints, an empty 
   * list is returned. A PTP will be returned regardless
   * of connectivity to other managed elements and regardless of position
   * in the subnetwork (both edgepoints of the subnetwork and the PTPs
   * that are internal to the subnetwork are reported).</p>
   * 
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm globaldefs::NamingAttributes_T managedElementName: The name of the 
   * Managed Element for which to retrieve PTPs.
   * @parm transmissionParameters::LayerRateList_T tpLayerRateList: List of PTP layer rates
   * for which the PTPs are to be fetched. A PTP must contain at least one of the
   * layer rates specified to be reported.  If the list is empty then all PTPs (of all rates)
   * are returned.
   * @parm transmissionParameters::LayerRateList_T connectionLayerRateList: List of connection 
   * layer rates for which the PTPs are to be fetched. A PTP must support connections for at 
   * least one of the
   * layer rates specified to be reported.  If the list is empty then all PTPs (for all 
   * connection rates) are returned.
   * @parm  unsigned long how_many: Maximum number of PTPs to report in the first batch.
   * @parm  terminationPoint::TerminationPointList_T tpList: First batch of PTPs.
   * @parm  terminationPoint::TerminationPointIterator_I tpIt: Iterator to retrieve remaining PTPs.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when managedElementName does not reference a managed element
   *  object, or tpLayerRateList or connectionLayerRateList contain undefined rates<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME object 
   *  that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
   void getAllPTPs(
         in globaldefs::NamingAttributes_T managedElementName,
         in transmissionParameters::LayerRateList_T tpLayerRateList,
         in transmissionParameters::LayerRateList_T connectionLayerRateList,
         in unsigned long how_many,
         out terminationPoint::TerminationPointList_T tpList,
         out terminationPoint::TerminationPointIterator_I tpIt) 
         raises(globaldefs::ProcessingFailureException);

  /**
   * <p>This operation has exactly the same behaviour as 
   * <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::getAllPTPs>getAllPTPs</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * @parm globaldefs::NamingAttributes_T managedElementName: The name of the 
   * Managed Element.
   * @parm transmissionParameters::LayerRateList_T tpLayerRateList: List of PTP layer rates
   *  for which the PTPs are to be fetched. A PTP must contain at least one of the
   *  layer rates specified to be reported.  If the list is empty then PTPs of all rates
   *  are returned.
   * @parm transmissionParameters::LayerRateList_T connectionLayerRateList: List of connection 
   *  layer rates for which the PTPs are to be fetched. A PTP must support connections for at 
   *  least one of the
   *  layer rates specified to be reported.  If the list is empty then PTPs for all 
   *  connection rates are returned.
   * @parm in unsigned long how_many: Maximum number of PTPs to return in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of PTPs.
   * @parm globaldefs::NamingAttributesIterator_I nameIt: Iterator to retrieve the remaining PTPs.
   * @raises globaldefs::ProcessingFailureException: 
   * As for <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::getAllPTPs>getAllPTPs</a>.
   **/
   void getAllPTPNames(
         in globaldefs::NamingAttributes_T managedElementName, 
         in transmissionParameters::LayerRateList_T tpLayerRateList,
         in transmissionParameters::LayerRateList_T connectionLayerRateList,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
         raises(globaldefs::ProcessingFailureException);


  /** 
   * <p>This service returns the termination point structure for the given TP name. 
   * The termination point structure contains transmission
   * parameters.  The transmission parameters returned will be the parameters
   * in place on the actual termination point on the NE.  If there are no
   * transmission parameters or the TP does not actually exist on the NE,
   * then transmissionParams will be empty. The field transmissionParams
   * will also be empty for "potential" ATM VP/VC CTPs.</p>
   * @parm globaldefs::NamingAttributes tpName: Name of the TP to retrieve.
   * @parm terminationPoint::TerminationPoint_T tp: The retrieved TP.
   * @raises globaldefs::ProcessingFailureException:<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference a termination point object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a TP object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void getTP(
         in globaldefs::NamingAttributes_T tpName,
         out terminationPoint::TerminationPoint_T tp) 
         raises (globaldefs::ProcessingFailureException);


  /** 
   * <p>This service returns the Managed Element for the given managed element name.</p>
   * @parm globaldefs::NamingAttributes managedElementName: Name of the ME to retrieve.
   * @parm managedElement::ManagedElement_T me: The retrieved ME.
   * @raises globaldefs::ProcessingFailureException:<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when managedElementName does not reference a
   *  managed element object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME object
   *  that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to the managed element is lost<br>
   * </dir>
   **/
   void getManagedElement(
         in globaldefs::NamingAttributes_T managedElementName,
         out managedElement::ManagedElement_T me) 
         raises (globaldefs::ProcessingFailureException);


  /**
   * <p>This allows an NMS to request all of the CTPs that it is potentially capable of 
   * supporting in all possible mapping configurations, at the specified rates 
   * and that are contained by the
   * specified termination point.</p>
   *
   * <p>This service returns all potential contained CTPs for a given TP. The TP may be
   * a PTP or a CTP. If the layerRateList is empty then 
   * contained CTPs at all flexible and/or static LayerRates are 
   * returned.</p>
   *
   * <p>For an OC3 PTP that has the potential of mapping to 
   * VT1.5 the response would contain 3 STS1 CTPs and 84 VT1.5 CTPs;
   * on a T1 PTP, the contained TPs would be one T1 CTP; for
   * an STS1 CTP the response would contain 28 VT1.5 CTPs.  
   * In the case where an OC3 PTP supports mapping 
   * to T1s and VT1.5,
   * then the contained list for the OC3 PTP
   * could be 1 STS3c, 3 STS1, 84 VT1.5 and 84 T1 CTPs;  
   * if a VT1.5 CTP is provided, 1 T1 CTP is returned;
   * if a T1 CTP is provided, the result is an empty list.</p>
   *
   * <p>Whenever a protection group is involved, the behaviour of
   * this service is described below:</p>
   *
   * <TABLE BORDER=2 COLS=2 WIDTH="80%">
   * <TR>
   * <TD>Scenario</TD><TD>Query On Worker TPs </TD><TD>Query On Protection TPs</TD>
   * </TR>
   * <TR>
   * <TD>Before the Protection Group is created</TD>
   * <TD>returns list of all CTPs </TD>
   * <TD>returns list of all CTPs</TD>
   * </TR>
   * <TR>
   * <TD>After ProtectionGroup is created, if extra (preemptible/non-pre-emptible) traffic is allowed.</TD>
   * <TD>returns list of all CTPs </TD>
   * <TD>returns list of all CTPs</TD>
   *</TR>
   * <TR>
   * <TD>After ProtectionGroup is created, if extra (preemptible/non-pre-emptible) traffic is not allowed </TD>
   * <TD>returns list of CTPs that allow protected traffic</TD>
   * <TD>returns an empty list (regardless of the switch status)</TD>
   * </TR>
   * </TABLE>
   * 
   * <p>In case the protection group is created after a query is made, 
   * no object delete notification is 
   * made, the NMS is expected to query the ports in the protection group 
   * to find the list of contained CTPs.</p>
   *
   * <p>When an NMS is interacting with an EMS that supports ATM, this operation
   * needs to be used with caution. The reason for this is that, in ATM, there
   * can be a prohibitively large number of potential VP and VC CTPs returned
   * by this operation. For retrieving ATM CTPs, the getContainedInUseTPs()
   * operation should be considered.</p>
   *
   * <p>If DWDM, SONET and/or SDH is combined with ATM, it is advisable that this
   * operation be used with the appropriate DWDM, SONET and/or SDH layer rates 
   * entered into the layerRateList. Otherwise, ATM CTPs will be returned and
   * the resulting list of contained TPs could get prohibitive.</p>
   * 
   * <p>For details on how TPs should be modelled, see
   * <a href=supportingDocumentation/layers.pdf>layering</a>.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm globaldefs::NamingAttributes_T tpName: The name of the PTP or CTP for which to 
   *  get contained CTPs. 
   * @parm transmissionParameters::LayerRateList_T layerRateList: The list of the rates the
   *  contained CTPs to report. An 
   *  empty list indicates to the EMS to report all contained CTPs (of all rates).
   * @parm unsigned long how_many: Maximum number of contained CTPs to report in the first batch.
   * @parm TerminationPointList_T tpList: First batch of contained CTPs.
   * @parm TerminationPointIterator_I tpIt: Iterator to retrieve the remaining contained CTPs.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference a PTP or CTP object
   *  or layerRateList contains undefined rates<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a PTP or CTP object
   *  that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
   void getContainedPotentialTPs(
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in unsigned long how_many,
         out terminationPoint::TerminationPointList_T tpList, 
         out terminationPoint::TerminationPointIterator_I tpIt)
         raises(globaldefs::ProcessingFailureException);



  /** 
   * <p>This operation has exactly the same behaviour as 
   * <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::getContainedPotentialTPs>getContainedPotentialTPs</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm globaldefs::NamingAttributes_T tpName: Name of the PTP or CTP for which to get
   *  contained CTPs.
   * @parm transmissionParameters::LayerRateList_T layerRateList: the list of the rates of
   *  the contained CTPs to be reported. An 
   *  empty list indicates to the EMS to get all contained CTPs (of all rates).
   * @parm  unsigned long how_many: Maximum number of contained CTPs to return in the first batch.
   * @parm  globaldefs::NamingAttributesList_T nameList: First batch of contained CTPs.
   * @parm  globaldefs::NamingAttributesListIterator_I nameIt: Iterator to retrieve the remaining
   *  contained CTPs.
   * @raises globaldefs::ProcessingFailureException:
   * As for <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::getContainedPotentialTPs>getContainedPotentialTPs</a>.
   **/
   void getContainedPotentialTPNames(
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
         raises(globaldefs::ProcessingFailureException);


  /** 
   * <p>This service is used to retrieve the "in use" CTPs that are contained within
   * a specific PTP or CTP, at specific layer rates. 
   * An "in use" CTP is defined as a CTP that is used by an SNC
   * in any state (including pending) or a CTP that is terminated and mapped.
   * This operation will be used when there are a large number of potential CTPs
   * (e.g., in ATM).</p>
   *
   * <p>Example of usage with respect to ATM:<dir>
   * To retrieve all actual ATM Network Interfaces associated with a PTP,
   * this operation will be invoked using the PTP name as the tpName and
   * LR_ATM_NI as the only layer rate in the layerRateList. The VPI and
   * VCI ranges that are specified in the returned ATM Network Interface
   * transmissionParams (i.e., Max_VPI_Bits and Max_VCI_Bits) can then be
   * used to determine the potential VPI/VCI range. A subsequent invocation of
   * this operation using an ATM Network Interface CTP as input can be used to
   * determine which VPIs/VCIs are actually in use (with LR_ATM_VP and LR_ATM_VC
   * included in the connectionRateList).</dir></p>
   *
   * <p>Example of usage with respect to SONET/SDH:<dir>
   * Consider an STM4 PTP with layerRate: LR_Optical_OC12_and_STM4.
   * Assume that the set of CTPs returned by operation getContainedPotentialTPs()
   * contains one CTP with layerRate LR_STS3c_and_AU4_VC4 that is terminating
   * an SNC (layerRate LR_STS3c_and_AU4_VC4), and another CTP with layerRate
   * LR_STS3c_and_AU4_VC4 that is terminated and mapped (attribute
   * tpMappingMode is set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING).
   * The CTP with layerRate LR_STS3c_and_AU4_VC4 that is terminated and mapped
   * contains one CTP with layerRate LR_VT2_and_TU12_VC12
   * that is involved in an SNC. None of the other contained CTPs have attribute
   * tpMappingMode set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING, or are
   * involved in an SNC.<br>
   * Operation getContainedInUseTPs then returns three CTPs:<ul>
   * <li>The CTP with layerRate LR_STS3c_and_AU4_VC4 that is terminating an SNC.</li>
   * <li>The CTP with layerRate LR_STS3c_and_AU4_VC4 that has attribute
   * tpMappingMode set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING.</li>
   * <li>The CTP with layerRate LR_VT2_and_TU12_VC12 that is terminating an SNC.</li>
   * </ul></dir></p>
   * 
   * <p>For details on how TPs should be modelled, see
   * <a href=supportingDocumentation/layers.pdf>layering</a>.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm globaldefs::NamingAttributes_T tpName: The name of the PTP or CTP for which to get 
   *  contained actual CTPs.
   * @parm transmissionParameters::LayerRateList_T layerRateList: The list of rates of the
   *  contained actual CTPS to be returned.
   *  An empty list indicates to the EMS to get all contained actual CTPs (for all rates).
   * @parm unsigned long how_many: The maximum number of CTPs to be returned in the first batch.
   * @parm TerminationPointList_T tpList: First batch of contained in use CTPs.
   * @parm TerminationPointIterator_I tpIt: Iterator to retrieve the remaining
   *  contained in use CTPs.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference a PTP or CTP object
   *  or layerRateList contains undefined rates<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a PTP or CTP object
   *  that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
   void getContainedInUseTPs(
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in unsigned long how_many,
         out terminationPoint::TerminationPointList_T tpList, 
         out terminationPoint::TerminationPointIterator_I tpIt)
         raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This operation has exactly the same behaviour as 
   * <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::getContainedInUseTPs>getContainedInUseTPs</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm globaldefs::NamingAttributes_T tpName: The name of the TP for which to get contained 
   *  in use TPs.
   * @parm transmissionParameters::LayerRateList_T layerRateList: The list of rates of the 
   *  contained in use CTPs to be returned. An 
   *  empty list indicates to the EMS to get all contained in use CTPs (of all rates).
   * @parm unsigned long how_many: Maximum number of CTP names to be returned in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of CTP names.
   * @parm globaldefs::NamingAttributesListIterator_I nameIt: Iterator to retrieve the remaining
   *  CTP names.
   * @raises globaldefs::ProcessingFailureException:
   * As for <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::getContainedInUseTPs>getContainedInUseTPs</a>.
   **/
   void getContainedInUseTPNames(
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in  unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
         raises(globaldefs::ProcessingFailureException);


  /** 
   * <p>This service is used to retrieve the "current" CTPs that are contained within
   * a specific PTP or CTP, at specific layer rates. 
   * A "current" CTP is defined as a CTP that is either cross-connectable or cross-connected, 
   * in the current mapping configuration. </p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm globaldefs::NamingAttributes_T tpName: The name of the PTP or CTP for which to get 
   *  current contained CTPs.
   * @parm transmissionParameters::LayerRateList_T layerRateList: The list of rates of the
   *  current contained CTPS to be returned.
   *  An empty list indicates to the EMS to get all current contained CTPs (of all rates).
   * @parm unsigned long how_many: The maximum number of CTPs to be returned in the first batch.
   * @parm TerminationPointList_T tpList: First batch of contained current CTPs.
   * @parm TerminationPointIterator_I tpIt: Iterator to retrieve the remaining
   *  contained current CTPs.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference a PTP or CTP object
   *  or layerRateList contains undefined rates<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a PTP or CTP object
   *  that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
   void getContainedCurrentTPs(
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in unsigned long how_many,
         out terminationPoint::TerminationPointList_T tpList, 
         out terminationPoint::TerminationPointIterator_I tpIt)
         raises(globaldefs::ProcessingFailureException);


/**
   * <p>This operation has exactly the same behaviour as 
   * <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::getContainedCurrentTPs>getContainedCurrentTPs</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm globaldefs::NamingAttributes_T tpName: The name of the PTP or CTP for which to get 
   *  current contained CTPs.
   * @parm transmissionParameters::LayerRateList_T layerRateList: The list of rates of the
   *  current contained CTPS to be returned.
   *  An empty list indicates to the EMS to get all current contained CTPs (of all rates).
   * @parm unsigned long how_many: Maximum number of CTP names to be returned in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of CTP names.
   * @parm globaldefs::NamingAttributesListIterator_I nameIt: Iterator to retrieve the remaining
   *  CTP names.
   * @raises globaldefs::ProcessingFailureException:
   * As for <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::getContainedCurrentTPs>getContainedCurrentTPs</a>.
   **/
   void getContainedCurrentTPNames(
         in globaldefs::NamingAttributes_T tpName,
         in transmissionParameters::LayerRateList_T layerRateList,
         in  unsigned long how_many,
         out globaldefs::NamingAttributesList_T nameList,
         out globaldefs::NamingAttributesIterator_I nameIt)
         raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This service returns a list of the containing TPs given a CTP. 
   * Using the UPSR OC3 example used in getContainedPotentialTPs, getContainingTPs
   * on the working T1 CTP will return a working STS1 CTP and a working OC3 
   * PTP.
   * If the OC3 was in APS, then getContainingTPs on the T1 CTP would return
   * an STS1 CTP, an OC3 working PTP and an OC3 protect PTP. 
   * 
   * <p>For details on how TPs should be modelled, see
   * <a href=supportingDocumentation/layers.pdf>layering</a>.</p>
   *
   * @parm globaldefs::NamingAttributes tpName: Name of the CTP for which containing
   * CTPs and PTPs are to be reported.
   * @parm terminationPoint::TerminationPointList_T tpList: List of the containing
   * CTPs and PTPs.
   * @raises globaldefs::ProcessingFailureException:<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when tpName does not reference a CTP object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when tpName references a CTP object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void getContainingTPs(
         in globaldefs::NamingAttributes_T tpName,
         out terminationPoint::TerminationPointList_T tpList)
         raises (globaldefs::ProcessingFailureException);


  /**
   * <p>This operation has exactly the same behaviour as 
   * <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::getContainingTPs>getContainingTPs</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * @parm globaldefs::NamingAttributes_T tpName: Name of the PTP or CTP for which to get
   * the names of the containing TPs.
   * @parm globaldefs::NamingAttributesList_T tpNameList: List of the names of the containing TPs.
   * @raises globaldefs::ProcessingFailureException:
   * As for <a href=_managedElementManager.ManagedElementMgr_I.html#managedElementManager::ManagedElementMgr_I::getContainingTPs>getContainingTPs</a>.
   **/
   void getContainingTPNames(
         in globaldefs::NamingAttributes_T tpName,
         out globaldefs::NamingAttributesList_T tpNameList)
         raises (globaldefs::ProcessingFailureException);


  /**
   * <p>This allows an NMS to request all of the active alarms and TCAs 
   * for the specified managed element.
   * Alarms that are not reported by the ME to the EMS should not be reported by this operation.
   * Some alarms may be
   * filtered out (excluded) by specifying their probable causes or severities.
   * </p>
   *
   * <p>The result of this operation is independent of the filtering set up by the NMS 
   * for the notification service.</p>
   *
   * @parm globaldefs::NamingAttributes meName: The name of the 
   * Managed Element for which to retrieve alarms and TCAs.
   * @parm notifications::ProbableCauseList_T excludeProbCauseList: List of probable causes
   *  to exclude from the output event list.
   * @parm notifications::PerceivedSeverityList_T excludeSeverityList: List of severities
   *  to exclude from the output event list.
   * @parm unsigned long how_many: Maximum number of events to report in the first batch.
   * @parm  notifications::EventList_T eventList: First batch of events.
   * @parm  notifications::EventIterator_I eventIt: Iterator to retrieve the remaining events.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when meName does not reference a managed element object or
   *  excludeProbCauseList contains undefined values<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when meName references an ME object that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void getAllActiveAlarms(
         in globaldefs::NamingAttributes_T meName,
         in notifications::ProbableCauseList_T excludeProbCauseList,
         in notifications::PerceivedSeverityList_T excludeSeverityList,
         in unsigned long how_many,
         out notifications::EventList_T eventList,
         out notifications::EventIterator_I eventIt) 
	     raises(globaldefs::ProcessingFailureException);

  /** 
   * <p>This service allows the NMS to set parameters on a specified 
   * Termination Point.</p>
   *
   * <p>This operation is best effort. The results of the operation are returned
   * so that the NMS is aware of what modifications succeeded.</p>
   *
   * <p>If the source TP of a broadcast system is used as input, then
   * the entire multipoint system will be affected based on the new
   * parameter values for the source TP.</p>
   *
   * <p>The tpMappingMode may be set with this operation. When the mode is
   * set to TM_TERMINATED_AND_AVAILABLE_FOR_MAPPING, the EMS will terminate the
   * specified CTP. In this case the EMS must create the specified CTP on the NE
   * if it does not actually exist. 
   * Setting the tpMappingMode of an ATM VP or VC CTP can only be done if
   * the CTP has been created. Note that the tpMappingMode can be set
   * only on the ingress and egress CTPs of an ATM SNC since they are the only
   * ones which may not be cross-connected.</p>
   *
   * <p>No change to tpMappingMode or trafficDescriptors will take place if
   * there is any active cross connect (NE cross connect)
   * using the CTP passed in parameter.</p>
   *
   * <p>The transmissionParams is a "delta" list that needs to be
   * applied to the specified TP, i.e. only a subset of the
   * parameters may be specified in the list, in which case only those
   * should be applied in the NE.</p>
   *
   * @parm subnetworkConnection::TPData_T tpInfo: Details of modifications required.
   * @parm terminationPoint::TerminationPoint_T modifiedTP: Result of modification.
   * @raises globaldefs::ProcessingFailureException:<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised if the TP referred to in tpInfo does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
   void setTPData(
         in subnetworkConnection::TPData_T tpInfo,
         out terminationPoint::TerminationPoint_T modifiedTP)
        raises(globaldefs::ProcessingFailureException);


  /**
   * <p>This allows an NMS to request a list of the cross-connects for the specified managed element 
   * at the specified layer rates.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,   
   * this operation uses an iterator. See   
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>   
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm globaldefs::NamingAttributes_T managedElementName: Name of the 
   * Managed Element for which to retrieve CCs.
   * @parm transmissionParameters::LayerRateList_T connectionRateList: List of 
   * rates for which to retrieve CCs. This must not be an empty list. In this case an 
   * INVALID_INPUT exception is thrown.
   * @parm in unsigned long how_many: Maximum number of CCs to report in the first batch.
   * @parm subnetworkConnection::CrossConnectList_T ccList: First batch of CCs.
   * @parm subnetworkConnection::CCIterator_I ccIt: Iterator to retrieve remaining CCs.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised if connectionRateList is empty or contains
   *  invalid rates, or if managedElementName does not reference a managed element.<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when managedElementName references an ME object
   * that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
   void getAllCrossConnections(
         in globaldefs::NamingAttributes_T managedElementName,
         in transmissionParameters::LayerRateList_T connectionRateList,
         in unsigned long how_many,
         out subnetworkConnection::CrossConnectList_T ccList,
         out subnetworkConnection::CCIterator_I ccIt)
         raises(globaldefs::ProcessingFailureException);

    };

};

#endif

