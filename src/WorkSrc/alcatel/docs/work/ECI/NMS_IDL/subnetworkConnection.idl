#ifndef subnetworkConnection_idl
#define subnetworkConnection_idl

// ********************************
// *                              *
// * subnetworkConnection.idl     *
// *                              *
// ********************************

//Include list
#include "globaldefs.idl"
#include "transmissionParameters.idl"
#include "terminationPoint.idl"

#pragma prefix "mtnm.tmforum.org"

  /** 
   * <a href=supportingDocumentation/overview.html>Overview of NML-EML interface</a>
   *
   * <p>This module contains the definition of the subnetworkConnection structure
   * of the NML-EML interface.</p>
   * <p>For a detailed description of the use of this struct see 
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.</p)
   * <br>
   *
   * <h5> Version 2.0. </h5>
   **/


module subnetworkConnection
{
  /**
   * <p>The static protection level is a statement of the internal resiliency of the SNC
   * (internal to
   * the subnetwork). The more resilient an SNC is, the more bandwidth 
   * it will consume.<br>
   * The protection level does not have any bearing on the externally visible
   * shape and traffic flows of the SNC (in non-failure cases).<br>
   * For a detailed description of the use of this attribute, see 
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.</p>
   **/
   enum StaticProtectionLevel_T
   {
      PREEMPTIBLE,
      UNPROTECTED,
      PARTIALLY_PROTECTED,
      FULLY_PROTECTED,
      HIGHLY_PROTECTED
   };


/**
   * <p>The protection effort is a statement of the requirement
   * of the static protection level.  
   * For example if EFFORT_SAME_OR_WORSE is specified for a 3-ended
   * FULLY_PROTECTED connection, a 3-ended PARTIALLY_PROTECTED connection is acceptable, 
   * but a 2-ended connection (ST_SIMPLE) is not acceptable i.e. ProtectionEffort_T 
   * does not have any bearing on the externaly visible shape of the SNC.</p>
   *
   * <p>EFFORT_WHATEVER indicates that the specified static protection level is preferred,
   * but that any other level is acceptable.</p>
   *
   * <p>For a detailed description of the use of this attribute see 
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.</p>
   **/
   enum ProtectionEffort_T
   {
     EFFORT_WHATEVER,
     EFFORT_SAME_OR_BETTER,
     EFFORT_SAME_OR_WORSE,
     EFFORT_SAME
   };


  /**
   * <p>The SNCState enum is used to represent the various states that
   * an SNC may take.</p>
   *
   * <p>The following states may be supported by the EMS, depending on the SNC
   * management mode of operation used by the EMS.
   * See <a href=supportingDocumentation/modesOfOperation.html>SNC Management 
   * Modes Of Operation</a> for details.<br>
   * <ul>
   * <li> SNCS_PENDING: the SNC has been created by an NMS and has not been
   *   activated by any NMS; or the SNC has been successfully deactivated by an NMS.
   *   That state has no relationship with the network state of the cross-connects of
   *   the SNC.
   *   It is allowable for an EMS to not support the SNCS_PENDING state and to 
   *   reject any operation that attempts to put an SNC into SNCS_PENDING state.</li>
   * <li> SNCS_ACTIVE: the SNC is not in pending state, a route has been assigned to
   *   the SNC and all cross-connects for the SNC are active in the network.</li>
   * <li> SNCS_PARTIAL: the SNC is not in pending state, and either a route has not been
   *   assigned to the SNC, or not all of the
   *   cross-connects of the SNC are active in the network.  This may or may not
   *   include activated SNCs for which there are currently no active cross-connects
   *   in the network, depending on the SNC management mode of operation.
   *   It is possible that, in some EMSes, this state be unreachable.</li>
   * <li> SNCS_NONEXISTENT: this is not an SNC state per se, as it applies to 
   *   "non-existent SNCs".  It is used in the interface to report SNCs that have 
   *   been deleted.
   * </li></ul></p>
   *
   * <p>See 
   * <a href=supportingDocumentation/SNCStateDiagram.pdf>SNCState state diagram</a>
   * for details on valid transitions.</p>
   **/
   enum SNCState_T
   {
     SNCS_NONEXISTENT,
     SNCS_PENDING,
     SNCS_ACTIVE,
     SNCS_PARTIAL
   };


  /**
   * <p>Grades of maximum tolerable disruption to traffic as a result of the
   * operation that this parameter is describing. The following relates 
   * to design intent:<dir>GOI_HITLESS,<br>
   * GOI_MINOR_IMPACT <= 50ms,<br>
   * GOI_MAJOR_IMPACT > 50ms.</dir></p>
   **/
   enum GradesOfImpact_T
   {
    GOI_HITLESS,
    GOI_MINOR_IMPACT,
    GOI_MAJOR_IMPACT
   };


  /** 
   * <p>The TPData struct contains termination point data that is settable by the NMS.</p>
   *
   * globaldefs::NamingAttributes_T <b>tpName</b>:
   * <dir>The name of the termination point to which this data applies.</dir>
   *
   * TerminationMode_T <b>tpMappingMode</b>:
   * <dir>The mapping mode to put the TP in.</dir>
   *
   * transmissionParameters::LayeredParameterList_T <b>transmissionParams</b>:
   * <dir>When used as output to the NMS, this is the transmission parameters of the TP.
   * When used as input to the EMS, this
   * is a "delta" list that needs to be applied to the specified TP.  Only
   * a subset of the parameters may be specified in the list, and
   * only those should be applied in the NE. 
   * If the list is empty then this means do nothing. To remove a parameter from the
   * list, "-" should be specified in the value part of the structure.
   * When a BLSR connection is created, the SPRING_NodeId parameter should be provided
   * for the aEnd and zEnd CTPs.</dir>
   *
   * globaldefs::NamingAttributes_T <b>ingressTrafficDescriptorName</b>:
   * <dir>The ingressTrafficDescriptorName of the TP (to be set).</dir>
   *
   * globaldefs::NamingAttributes_T <b>egressTrafficDescriptorName</b>:
   * <dir>The egressTrafficDescriptorName of the TP (to be set).</dir>
   **/
   struct TPData_T
   {
    globaldefs::NamingAttributes_T tpName;
    terminationPoint::TerminationMode_T tpMappingMode;
    transmissionParameters::LayeredParameterList_T transmissionParams;
    globaldefs::NamingAttributes_T ingressTrafficDescriptorName;
    globaldefs::NamingAttributes_T egressTrafficDescriptorName;
   };

  /**
   * <p>Sequence of TPData_T.</p>
   **/
  typedef sequence<TPData_T> TPDataList_T;

  /**
   * <p>The SNC Type describes the connection based on the signal 
   * flows.</p>
   *
   * <p>For a detailed description of the use of this attribute see 
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.</p>
   *
   * <p>In case of an ATM SNC (VP or VC), ST_SIMPLE is used to specify a 'plain'
   * (hard or regular) PVC.</p>
   **/
   enum SNCType_T
   {
     ST_SIMPLE,
     ST_ADD_DROP_A,
     ST_ADD_DROP_Z,
     ST_INTERCONNECT,
     ST_DOUBLE_INTERCONNECT,
     ST_DOUBLE_ADD_DROP,
     ST_OPEN_ADD_DROP,
     ST_EXPLICIT
   };


  /**
   * <p>The Reroute_T type indicates if the EMS/MEs are allowed and/or required
   * to reroute this SNC if there 
   * is a failure on this SNC, periodically to optimize the routes, of for any other reason.
   * It is an EMS/ME implementation whether this is done using network routing protocols
   * or if the EMS/MEs detect the failure and take appropriate action to attempt to fix 
   * the SNC.</p>
   *
   * <p>The RR_NO value means that the EMS/MEs are not allowed to reroute the SNC.
   * The RR_YES value means that the EMS/MEs are allowed to reroute the SNC and required 
   * to attempt to reroute it upon failure.
   * The RR_NA value is used when the NMS does not want to specify the exact EMS behaviour.
   * In this case it is left up to the EMS to decide whether rerouting will be provided.
   * It is also used if the EMS/MEs are allowed to reroute the SNC but not required 
   * to attempt to reroute it upon failure.</p>
   **/
   enum Reroute_T
   {
      RR_NA,
      RR_NO,
      RR_YES
   };


  /**
   * Network routed, indicates if the route must be or is computed and
   * implemented at the network level. 
   * NR_YES indicates that the
   * route must be / is computed at the network.
   * NR_NO indicates that the route must not be / is not
   * computed at the network. 
   * NR_NA indicates that the route can be computed
   * anywhere.
   **/

   enum NetworkRouted_T
   {
      NR_NA,
      NR_NO,
      NR_YES
   };


  /** 
   * The route change goes through different stages during a
   * reroute of a SubnetworkConnection. These stages are a part
   * of the ROUTE_CHANGE notification.
   * These are:
   * <ol>
   * <li> "RerouteStarted" </li>
   * <li> "RerouteCompleted" </li>
   * <li> "RerouteFailed" </li>
   * </ol>
   **/

   typedef string RerouteChangeEvent_T;
 

  /**
   * <p>A subnetwork connection represents a connection between CTPs.</p>
   *
   * globaldefs::NamingAttributes_T <b>name</b>:
   * <dir>The name represents the name of the
   * SubnetworkConnection which is assigned by the EMS upon creation.
   * The EMS is responsible for guaranteeing the uniqueness of the name
   * within the context of the MultiLayerSubnetworkMgr_I.
   * It is a readonly attribute.</dir>
   *
   * string <b>userLabel</b>:
   * <dir>The user label of the subnetwork connection is NMS data
   * (typically end-to-end trail data). This could be used by the EMS 
   * to display to the user (to associate SNCs/cross-connects to the NMS data),
   * but this is not a requirement on the EMS to display on its GUI.
   * This attribute can be set
   * by the NMS through the Common_I interface service
   * <a href=_common.Common_I.html#common::Common_I::setUserLabel>setUserLabel</a>
   * or through the createSNC and createAndActivateSNC operations. 
   * It is a read/write attribute.</dir>
   *
   * string <b>nativeEMSName</b>:
   * <dir>The name represents how the SNC is referred to on EMS displays. Its
   * aim is to provide a "nomenclature bridge" to aid relating information
   * presented on NMS displays to EMS displays (via GUI cut through).
   * The native name is defaulted to a NULL string. However, this could
   * be used by the EMS for its implementation dependent purpose.</dir>
   *
   * string <b>owner</b>:
   * <dir>
   * The owner is provisionable by the NMS. This attribute can be set
   * by NMS through the Common_I interface service
   * <a href=_common.Common_I.html#common::Common_I::setOwner>setOwner</a>
   * or through the createSNC and createAndActivateSNC operations. 
   * It is a read/write attribute.</dir>
   *
   * SNCState_T <b>sncState</b>:
   * <dir>The EMS may operate in one of four modes, summarized below.  See
   * <a href=supportingDocumentation/SNCModes.html>SNC Management 
   * Modes Of Operation</a>.<br>
   * <ol> 
   * <li>  No pending no sharing </li>
   *   <ul> 
   *   <li> The pending state is not supported.  Conflicting SNCs are rejected
   *    on creation.  Sharing of CCs amongst SNCs is not allowed, except for
   *    broadcast SNCs.
   *   </li>
   * </ul>
   * <li>  No pending with sharing </li>
   *   <ul> 
   *   <li> The pending state is not supported.  Conflicting SNCs are rejected
   *    on creation.  However, sharing of CCs amongst SNCs is allowed.
   *   </li>
   * </ul>
   * <li>  Pending no sharing </li>
   *   <ul> 
   *   <li> The pending state is supported.  Conflicting SNCs and SNCs that share CCs
   *    are accepted on creation, however their activation is rejected.
   *    Sharing of CCs amongst SNCs is not allowed for partial and active SNCs, 
   *    except for broadcast SNCs.
   *   </li>
   * </ul>
   * <li>  Pending with sharing </li>
   *   <ul> 
   *   <li> The pending state is supported.  Conflicting SNCs are accepted
   *    on creation, however their activation is rejected.  
   *    Sharing of CCs amongst SNCs is allowed.
   *   </li>
   * </ul>
   * </ol>
   * See <a href=supportingDocumentation/modesOfOperation.html>SNC Management 
   * Modes Of Operation</a> for details.<br>
   * The sncState is an attribute managed by the EMS.<br>
   * The EMS manages the state transition of this attribute.<br>
   * The EMS will assess the cross-connections in the network that
   * support the SNC and will appropriately adjust the value of SNCState to 
   * reflect the actual state of the SNC in the network.
   * </dir>
   *
   * globaldefs ::ConnectionDirection_T <b>direction</b>:
   * <dir>Specifies the direction of the
   * subnetwork connection.
   * It is a readonly attribute.</dir>
   *
   * transmissionParameters::LayerRate_T <b>rate</b>:
   * <dir>The rate of the SubnetworkConnection is obtained by reading
   * this attribute. The EMS sets this attribute at creation of the SNC.
   * The EMS is allowed to choose a Layer Rate equivalent to that of 
   * one of the TPs. The EMS is
   * expected to reflect any equivalent layer rate in any connection 
   * retrievals (i.e. the connection rate of the SNC retrieved from the 
   * EMS does not have to be the same as that requested by the NMS so long
   * as it is an equivalent rate).</dir>
   *
   * <dir>For a detailed description of the use of this attribute see 
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.
   * This is a readonly attribute.</dir>
   *
   * StaticProtectionLevel_T <b>staticProtectionLevel</b>:
   * <dir>The static protection level of the SNC.  
   * For a detailed description of the use of this attribute, see 
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.
   * This is a readonly attribute.</dir>
   *
   * SNCType_T <b>sncType</b>:
   * <dir>The type of the SNC.  For a detailed description of the use of this attribute, see 
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.
   * This is a readonly attribute.</dir>
   *
   * TPDataList_T <b>aEnd</b>:
   * <dir>The list of Aend termination points where this SNC terminates.
   * For a detailed description of the use of this attribute, see 
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.
   * This is a readonly attribute.</dir>
   *
   * TPDataList_T <b>zEnd</b>:
   * <dir>The list of Zend termination points where this SNC terminates.
   * For a detailed description of the use of this attribute, see 
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.
   * This is a readonly attribute.</dir>
   *
   * Reroute_T <b>rerouteAllowed</b>:
   * <dir>This attribute specifies if the EMS is allowed/required to reroute this SNC.</dir>
   *
   * NetworkRouted_T <b>networkRouted</b>:
   * <dir>This attribute specifies if the route for this SNC is computed by the network.</dir>
   *
   * globaldefs::NVSList_T <b>additionalInfo</b>:
   * <dir>This attribute allows the communication from the EMS to the NMS of additional 
   * information which is not explicitly modelled.
   * It is a readonly attribute.</dir>
   * <br>
   **/
   struct SubnetworkConnection_T
   {
   globaldefs::NamingAttributes_T name;
   string userLabel;
   string nativeEMSName;
   string owner;
   SNCState_T sncState;    
   globaldefs::ConnectionDirection_T direction;
   transmissionParameters::LayerRate_T rate;
   StaticProtectionLevel_T staticProtectionLevel;
   SNCType_T sncType;
   TPDataList_T aEnd;    
   TPDataList_T zEnd;    
   Reroute_T rerouteAllowed;
   NetworkRouted_T networkRouted;
   globaldefs::NVSList_T additionalInfo;
  };


  /**
   * <p>Sequence of SubnetworkConnection_T.</p>
   **/
   typedef sequence<SubnetworkConnection_T> SubnetworkConnectionList_T;


  /**
   * <p>A crossConnect represents a connection within a single managed element.
   * This structure is primarily used in the specification of routes.</p>
   *
   * boolean <b>active</b>:
   * <dir>Indicates if the cross-connect is active in the ME.  Refer to
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a> for details.</dir>
   *
   * globaldefs::ConnectionDirection_T <b>direction</b>:
   * <dir>Directionality of the cross connection.</dir>
   *
   * SNCType_T <b>ccType</b>:
   * <dir>Type of connection as specified in
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.</dir>
   *
   * globaldefs::NamingAttributesList_T <b>aEndNameList</b>:
   * <dir>Names of CTPs at the aEnd of the cross connection.</dir>
   *
   * globaldefs::NamingAttributesList_T <b>zEndNameList</b>:
   * <dir>Names of CTPs at the zEnd of the cross connection.</dir>
   *
   * globaldefs::NVSList_T <b>additionalInfo</b>:
   * <dir>This attribute allows the communication from the EMS to the NMS of additional 
   * information which is not explicitly modelled.
   * It is a readonly attribute.</dir>
   **/
  struct CrossConnect_T
  {
   boolean active;
   globaldefs::ConnectionDirection_T direction; 
   SNCType_T ccType;
   globaldefs::NamingAttributesList_T aEndNameList;
   globaldefs::NamingAttributesList_T zEndNameList;
   globaldefs::NVSList_T additionalInfo;
  };


  /**
   * <p>A route for an SNC is defined as a partially ordered list of cross-connects.</p>
   *
   * <p>This structure can deal with any arbitrarily complex protection paths
   * made up from connection types described in
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.</p>
   * 
   * <p>The cross-connects are listed from the NE 
   * on which the SNC starts (first entry) to the NE on which the SNC ends
   * (last entry) and the aEndNameList and zEndNameList will name CTPs of the
   * same or equivalent layerRate only. There is no mandatory order in
   * the cross-connects listed in between the first one and the last one.</p>
   **/
   typedef sequence<CrossConnect_T> Route_T;


  /**
   * <p>Arbitrary sequence of cross-connects.</p>
   **/
   typedef sequence<CrossConnect_T> CrossConnectList_T;


  /**
   * <p>An inclusion/exclusion constraint for an SNC is defined as a list of resources.
   * A resource is defined as an ME, CTP, PTP, or SNC.</p>
   */
   typedef globaldefs::NamingAttributes_T Resource_T;


  /**
   * <p>Set of Resources_T, used as an inclusion/exclusion constraint for SNC creation.</p>
   *
   * <p>There is no mandatory order for the resources listed.</p>
   */
   typedef sequence<Resource_T> ResourceList_T;


  /**
   * <p>In order to allow the NMS to deal with a large number of objects,
   * iterators are used.</p>
   * <p>See <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   **/

   interface CCIterator_I 
    {
	boolean  next_n(in  unsigned long    how_many,
			out CrossConnectList_T ccList)
		 raises (globaldefs::ProcessingFailureException);

	unsigned long getLength()
		 raises (globaldefs::ProcessingFailureException);

	void     destroy()
		 raises (globaldefs::ProcessingFailureException);
    };


  /**
   * <p>The read-create attributes required for the creation of a
   * subnetworkConnection on the EMS are packaged together in an SNCCreateData
   * structure which the NMS will pass to the EMS at SNC creation time.  These 
   * are the read-create attributes of the SNC.</p>
   *
   * string <b>userLabel</b>:
   * <dir>userLabel may be specified by the NMS. May be empty.</dir>
   *
   * boolean <b>forceUniqueness</b>:
   * <dir>Specifies whether uniqueness of the userLabel is required amongst SNCs of 
   *  the EMS.  The operation will fail if userLabel is already in use.</dir>
   *
   * string <b>owner</b>:
   * <dir>owner may be specified by the NMS. May be empty.</dir>
   *
   * Globaldefs::ConnectionDirection_T <b>direction</b>:
   * <dir>The connection directionality must be specified by the NMS.</dir>
   *
   * StaticProtectionLevel_T <b>staticProtectionLevel</b>:
   * <dir>The NMS must specify the requested staticProtectionLevel as specified in
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.</dir>
   *
   * ProtectionEffort_T <b>protectionEffort</b>:
   * <dir>The NMS must specify the protectionEffort as specified in
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.</dir>
   *
   * Reroute_T <b>rerouteAllowed</b>:
   * <dir>This attribute specifies if the EMS is allowed/required to reroute this SNC.
   * There is no requirement for the reroutes
   * to respect the constraints specified in the creation request
   * (ccInclusions, neTpInclusions, fullRoute, neTpSncExclusions).</dir>
   *
   * NetworkRouted_T <b>networkRouted</b>:
   * <dir>This attribute specifies if the network is allowed/required to route this SNC.</dir>
   *
   * SNCType_T <b>sncType</b>:
   * <dir>The NMS must specify the sncType as specified in
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.</dir>
   *
   * transmissionParameters::LayerRate_T <b>layerRate</b>:
   * <dir>Identifies the layer at which the SNC is to be made.</dir>
   *
   * CrossConnectList_T <b>ccInclusions</b>:
   * <dir>Specifies a list of cross-connects that must be used by the SNC.
   * The list must be empty if no cross-connect constraints are required.  If the EMS
   * cannot fully satisfy the constraints, then the request will be rejected.</dir>
   *
   * ResourceList_T <b>neTpInclusions</b>
   * <dir>Specifies a list of MEs, PTPs, and/or CTPs that must be used by the SNC.
   * The list must be empty if no ME/PTP/CTP constraints are required.  If the EMS
   * cannot fully satisfy the constraints, then the request will be rejected.</dir>
   *
   * boolean <b>fullRoute</b>
   * <dir>Specifies if the ccInclusions and neTpInclusions constraints describe
   * the full route of the SNC (as opposed to only a partial constraint).
   * When no inclusions constraints are specified, false must be used.</dir>
   *
   * ResourceList_T <b>neTpSncExclusions</b>
   * <dir>Specifies a list of MEs, PTPs, CTPs, and/or SNCs to be excluded.
   * The SNC to be created must not use any of the NEs, PTPs, and CTPs specified,
   * nor any resource used by the SNCs specified.
   * Specifying both inclusion and exclusion constraints is not supported,
   * therefore this list must be empty if ccInclusions or neTpInclusions is non empty.
   * </dir>
   *
   * NamingAttributesList_T <b>aEnd</b>:
   * <dir>The NMS must specify the aEnd as specified in
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.
   * Is also used to indicate the Source TP when adding a leg to an existing
   * broadcast system.</dir>
   *
   * NamingAttributesList_T <b>zEnd</b>:
   * <dir>The NMS must specify the zEnd as specified in
   * <a href=supportingDocumentation/snctypes.pdf>SNC Types</a>.
   * Is also used to indicate the Sink TP when adding a leg to an existing
   * broadcast system.
   * If the NMS supplies an invalid 
   * combination of TPs in aEnd and zEnd, then the EMS will throw an 
   * INVALID_INPUT exception.
   * Aend and Zend TPs have to be on the same subnetwork.</dir>
   *
   * globaldefs::NVSList_T <b>additionalCreationInfo</b>:
   * <dir>Some additional creation information may be specified by the NMS.
   * For example, for a system which cannot use the routing constraints 
   * for a BLSR case it may supply the pairs:
   * <ul><li>"BLSRDirection" taking values "EAST", "WEST" and "NA"</li>
   * <li>"Timeslot" taking values "1".."nnnnn".</li></ul>
   * This could also be used to carry the "PotentialFutureSetupIndicator" of the aEnd
   * in the case where it has an impact on the creation of the SNC.
   * The list may be empty.</dir>
   * <br>
   **/  
   struct SNCCreateData_T
   {
    string userLabel;
    boolean forceUniqueness;
    string owner;
    globaldefs::ConnectionDirection_T direction;
    StaticProtectionLevel_T staticProtectionLevel;
    ProtectionEffort_T protectionEffort;
    Reroute_T rerouteAllowed;
    NetworkRouted_T networkRouted;
    SNCType_T sncType;
    transmissionParameters::LayerRate_T layerRate;
    CrossConnectList_T ccInclusions;
    ResourceList_T neTpInclusions;
    boolean fullRoute;
    ResourceList_T neTpSncExclusions;
    globaldefs::NamingAttributesList_T aEnd;
    globaldefs::NamingAttributesList_T zEnd;
    globaldefs::NVSList_T additionalCreationInfo;
   };


  /**
   * <p>In order to allow the NMS to deal with a large number of objects,
   * iterators are used.</p>
   * <p>See <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   **/

  interface SNCIterator_I 
    {
        boolean  next_n(in unsigned long               how_many,
                        out SubnetworkConnectionList_T sncList)
          raises (globaldefs::ProcessingFailureException);

        unsigned long getLength()
          raises (globaldefs::ProcessingFailureException);

        void destroy()
          raises (globaldefs::ProcessingFailureException);
    };
  // End of Iterator interface
}; 
#endif

