package hoshen.xsm.lightsoft.corba.emsMgr;


/**
* hoshen/xsm/lightsoft/corba/emsMgr/EMSMgr_IOperations.java .
* Generated by the IDL-to-Java compiler (portable), version "3.0"
* from lightsoft/emsMgr.idl
* 13:11:29 GMT+02:00 יום חמישי 28 יוני 2007
*/


/**
   * <p>The EMSMgr_I is used to gain access to operations
   * which deal with the EMS itself.</p>
   *
   * <p>A handle to an instance of this interface is gained via the
   * <a href=_emsSession.EmsSession_I.html#emsSession::EmsSession_I::getManager>
   * getManager</a> operation in Manager.</p>
   **/
public interface EMSMgr_IOperations  extends hoshen.xsm.lightsoft.corba.common.Common_IOperations
{

  /**
   * <p>This allows an NMS to request the EMS information.</p>
   * 
   * @parm  EMS_T emsInfo : The EMS information.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   **/
  void getEMS (hoshen.xsm.lightsoft.corba.emsMgr.EMS_THolder emsInfo) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException;

  /**
   * <p>This allows an NMS to request all of the Subnetworks that
   * are under the control of this EMS.</p>
   * 
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm  unsigned long how_many: Maximum number of subnetworks to return in the first batch.
   * @parm  multiLayerSubnetwork::SubnetworkList_T sList: First batch of subnetworks.
   * @parm  multiLayerSubnetwork::SubnetworkIterator_I sIt: Iterator to retrieve the remaining
   * subnetworks.
   * @raises globaldefs::ProcessingFailureException:<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
  void getAllTopLevelSubnetworks (int how_many, hoshen.xsm.lightsoft.corba.multiLayerSubnetwork.SubnetworkList_THolder sList, hoshen.xsm.lightsoft.corba.multiLayerSubnetwork.SubnetworkIterator_IHolder sIt) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException;

  /**
   * <p>This operation has exactly the same behaviour as 
   * <a href=_EMS.EMS.html#EMS::EMS::getAllTopLevelSubnetworks>getAllTopLevelSubnetworks</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm unsigned long how_many: Maximum number of subnetwork names to return in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of subnetwork names.
   * @parm globaldefs::NamingAttributesListIterator_I nameIt: Iterator to retrieve the remaining
   * subnetwork names.
   * @raises globaldefs::ProcessingFailureException:
   * As for getAllTopLevelSubnetworks.
   **/
  void getAllTopLevelSubnetworkNames (int how_many, hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesList_THolder nameList, hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesIterator_IHolder nameIt) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException;

  /**
   * <p>This allows an NMS to request all of the Topological Links that
   * exist between multiLayerSubnetworks under the control of this EMS.</p>
   * 
   * <p>For details on how topological links should be modelled, see
   * <a href=supportingDocumentation/layers.pdf>layering</a>.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm  unsigned long how_many: Maximum number of topological links
   * to return in the first batch.
   * @parm  topologicalLink::TopologicalLinkList_T topoList: First batch of topological links.
   * @parm  topologicalLink::TopologicalLinkIterator_I topoIt: Iterator to retrieve the remaining
   * topological links.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
  void getAllTopLevelTopologicalLinks (int how_many, hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLinkList_THolder topoList, hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLinkIterator_IHolder topoIt) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException;

  /**
   * <p>This operation has exactly the same behaviour as 
   * getAllTopLevelTopologicalLinks, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm unsigned long how_many: Maximum number of topological link names
   * to return in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of topological link names.
   * @parm globaldefs::NamingAttributesListIterator_I nameIt: Iterator to retrieve the remaining
   * topological link names.
   * @raises globaldefs::ProcessingFailureException:
   * As for getAllTopLevelTopologicalLinks.
   **/
  void getAllTopLevelTopologicalLinkNames (int how_many, hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesList_THolder nameList, hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesIterator_IHolder nameIt) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException;

  /**
   * <p>This service returns a top level topological link given its name.</p>
   * 
   * @parm globaldefs::NamingAttributes topoLinkName: Name of the top level 
   *  topological link to retrieve.
   * @parm TopologicalLink_T topoLink: Top level topological link returned.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when topoLinkName does not reference a top level topological
   *  link object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when topoLinkName references a top level topological link
   *  object that does not exist<br>
   * </dir>
   **/
  void getTopLevelTopologicalLink (hoshen.xsm.lightsoft.corba.globaldefs.NameAndStringValue_T[] topoLinkName, hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLink_THolder topoLink) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException;

  /**
   * <p>This allows an NMS to request all of the active alarms and TCAs that
   * are under the control of this EMS (both those raised by
   * the NEs and those raised by the EMS itself). Some alarms may be
   * filtered out (excluded) by specifying their probable causes or severities.
   * </p>
   * 
   * <p>The result of this operation is independent of the filtering set up by the NMS 
   * for the notification service.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm notifications::ProbableCauseList_T excludeProbCauseList: The list of probable
   * causes to exclude (for which events should not be reported).
   * @parm notifications::PerceivedSeverityList_T excludeSeverityList: List of severities
   *  to exclude from the output event list.
   * @parm unsigned long how_many: Maximum number of alarms and TCAs to report in the first
   *  batch.
   * @parm  notifications::EventList_T eventList: First batch of alarms and TCAs.
   * @parm  notifications::EventIterator_I eventIt: Iterator to retrieve the remaining
   * alarms and TCAs.
   * @raises globaldefs::ProcessingFailureException:<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
  void getAllEMSAndMEActiveAlarms (String[] excludeProbCauseList, hoshen.xsm.lightsoft.corba.notifications.PerceivedSeverity_T[] excludeSeverityList, int how_many, hoshen.xsm.lightsoft.corba.notifications.EventList_THolder eventList, hoshen.xsm.lightsoft.corba.notifications.EventIterator_IHolder eventIt) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException;

  /**
   * <p>This allows an NMS to request all of the active alarms and TCAs that
   * for the EMS itself.  Some alarms may be
   * filtered out (excluded) by specifying their severities.</p>
   * 
   * <p>The result of this operation is independent of the filtering set up by the NMS 
   * for the notification service.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm notifications::PerceivedSeverityList_T excludeSeverityList: List of severities
   *  to exclude from the output event list.
   * @parm unsigned long how_many: Maximum number of alarms and TCAs to report in the first
   *  batch.
   * @parm  notifications::EventList_T eventList: First batch of alarms and TCAs.
   * @parm  notifications::EventIterator_I eventIt: Iterator to retrieve the remaining
   * alarms and TCAs.
   * @raises globaldefs::ProcessingFailureException:<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
  void getAllEMSSystemActiveAlarms (hoshen.xsm.lightsoft.corba.notifications.PerceivedSeverity_T[] excludeSeverityList, int how_many, hoshen.xsm.lightsoft.corba.notifications.EventList_THolder eventList, hoshen.xsm.lightsoft.corba.notifications.EventIterator_IHolder eventIt) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException;
} // interface EMSMgr_IOperations
