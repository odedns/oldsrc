package hoshen.xsm.lightsoft.corba.emsMgr;


/**
* hoshen/xsm/lightsoft/corba/emsMgr/_EMSMgr_IStub.java .
* Generated by the IDL-to-Java compiler (portable), version "3.0"
* from lightsoft/emsMgr.idl
* 13:11:27 GMT+02:00 יום חמישי 28 יוני 2007
*/


/**
   * <p>The EMSMgr_I is used to gain access to operations
   * which deal with the EMS itself.</p>
   *
   * <p>A handle to an instance of this interface is gained via the
   * <a href=_emsSession.EmsSession_I.html#emsSession::EmsSession_I::getManager>
   * getManager</a> operation in Manager.</p>
   **/
public class _EMSMgr_IStub extends org.omg.CORBA_2_3.portable.ObjectImpl implements hoshen.xsm.lightsoft.corba.emsMgr.EMSMgr_I
{
  // Constructors
  // NOTE:  If the default constructor is used, the
  //        object is useless until _set_delegate (...)
  //        is called.
  public _EMSMgr_IStub ()
  {
    super ();
  }

  public _EMSMgr_IStub (org.omg.CORBA.portable.Delegate delegate)
  {
    super ();
    _set_delegate (delegate);
  }


  /**
   * <p>This allows an NMS to request the EMS information.</p>
   * 
   * @parm  EMS_T emsInfo : The EMS information.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   **/
  public void getEMS (hoshen.xsm.lightsoft.corba.emsMgr.EMS_THolder emsInfo) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("getEMS",true);
          _in = _invoke (_out);
          emsInfo.value = hoshen.xsm.lightsoft.corba.emsMgr.EMS_THelper.read (_in);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "getEMS",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
         hoshen.xsm.lightsoft.corba.emsMgr.EMS_THolder _emsInfo = new hoshen.xsm.lightsoft.corba.emsMgr.EMS_THolder();
          ((hoshen.xsm.lightsoft.corba.emsMgr.EMSMgr_IOperations)_so.servant).getEMS( _emsInfo );
         emsInfo.value = _emsInfo.value;
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // getEMS


  /**
   * <p>This allows an NMS to request all of the Subnetworks that
   * are under the control of this EMS.</p>
   * 
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm  unsigned long how_many: Maximum number of subnetworks to return in the first batch.
   * @parm  multiLayerSubnetwork::SubnetworkList_T sList: First batch of subnetworks.
   * @parm  multiLayerSubnetwork::SubnetworkIterator_I sIt: Iterator to retrieve the remaining
   * subnetworks.
   * @raises globaldefs::ProcessingFailureException:<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
  public void getAllTopLevelSubnetworks (int how_many, hoshen.xsm.lightsoft.corba.multiLayerSubnetwork.SubnetworkList_THolder sList, hoshen.xsm.lightsoft.corba.multiLayerSubnetwork.SubnetworkIterator_IHolder sIt) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("getAllTopLevelSubnetworks",true);
          _out.write_ulong (how_many);
          _in = _invoke (_out);
          sList.value = hoshen.xsm.lightsoft.corba.multiLayerSubnetwork.SubnetworkList_THelper.read (_in);
          sIt.value = hoshen.xsm.lightsoft.corba.multiLayerSubnetwork.SubnetworkIterator_IHelper.read (_in);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "getAllTopLevelSubnetworks",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
         hoshen.xsm.lightsoft.corba.multiLayerSubnetwork.SubnetworkList_THolder _sList = new hoshen.xsm.lightsoft.corba.multiLayerSubnetwork.SubnetworkList_THolder();
         hoshen.xsm.lightsoft.corba.multiLayerSubnetwork.SubnetworkIterator_IHolder _sIt = new hoshen.xsm.lightsoft.corba.multiLayerSubnetwork.SubnetworkIterator_IHolder();
          ((hoshen.xsm.lightsoft.corba.emsMgr.EMSMgr_IOperations)_so.servant).getAllTopLevelSubnetworks( how_many,_sList,_sIt );
         sList.value = _sList.value;
         sIt.value = _sIt.value;
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // getAllTopLevelSubnetworks


  /**
   * <p>This operation has exactly the same behaviour as 
   * <a href=_EMS.EMS.html#EMS::EMS::getAllTopLevelSubnetworks>getAllTopLevelSubnetworks</a>, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm unsigned long how_many: Maximum number of subnetwork names to return in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of subnetwork names.
   * @parm globaldefs::NamingAttributesListIterator_I nameIt: Iterator to retrieve the remaining
   * subnetwork names.
   * @raises globaldefs::ProcessingFailureException:
   * As for getAllTopLevelSubnetworks.
   **/
  public void getAllTopLevelSubnetworkNames (int how_many, hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesList_THolder nameList, hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesIterator_IHolder nameIt) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("getAllTopLevelSubnetworkNames",true);
          _out.write_ulong (how_many);
          _in = _invoke (_out);
          nameList.value = hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesList_THelper.read (_in);
          nameIt.value = hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesIterator_IHelper.read (_in);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "getAllTopLevelSubnetworkNames",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
         hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesList_THolder _nameList = new hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesList_THolder();
         hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesIterator_IHolder _nameIt = new hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesIterator_IHolder();
          ((hoshen.xsm.lightsoft.corba.emsMgr.EMSMgr_IOperations)_so.servant).getAllTopLevelSubnetworkNames( how_many,_nameList,_nameIt );
         nameList.value = _nameList.value;
         nameIt.value = _nameIt.value;
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // getAllTopLevelSubnetworkNames


  /**
   * <p>This allows an NMS to request all of the Topological Links that
   * exist between multiLayerSubnetworks under the control of this EMS.</p>
   * 
   * <p>For details on how topological links should be modelled, see
   * <a href=supportingDocumentation/layers.pdf>layering</a>.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm  unsigned long how_many: Maximum number of topological links
   * to return in the first batch.
   * @parm  topologicalLink::TopologicalLinkList_T topoList: First batch of topological links.
   * @parm  topologicalLink::TopologicalLinkIterator_I topoIt: Iterator to retrieve the remaining
   * topological links.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - Raised if EMS cannot support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
  public void getAllTopLevelTopologicalLinks (int how_many, hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLinkList_THolder topoList, hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLinkIterator_IHolder topoIt) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("getAllTopLevelTopologicalLinks",true);
          _out.write_ulong (how_many);
          _in = _invoke (_out);
          topoList.value = hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLinkList_THelper.read (_in);
          topoIt.value = hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLinkIterator_IHelper.read (_in);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "getAllTopLevelTopologicalLinks",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
         hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLinkList_THolder _topoList = new hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLinkList_THolder();
         hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLinkIterator_IHolder _topoIt = new hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLinkIterator_IHolder();
          ((hoshen.xsm.lightsoft.corba.emsMgr.EMSMgr_IOperations)_so.servant).getAllTopLevelTopologicalLinks( how_many,_topoList,_topoIt );
         topoList.value = _topoList.value;
         topoIt.value = _topoIt.value;
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // getAllTopLevelTopologicalLinks


  /**
   * <p>This operation has exactly the same behaviour as 
   * getAllTopLevelTopologicalLinks, but
   * instead of returning the entire object structures, this operation returns their names.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm unsigned long how_many: Maximum number of topological link names
   * to return in the first batch.
   * @parm globaldefs::NamingAttributesList_T nameList: First batch of topological link names.
   * @parm globaldefs::NamingAttributesListIterator_I nameIt: Iterator to retrieve the remaining
   * topological link names.
   * @raises globaldefs::ProcessingFailureException:
   * As for getAllTopLevelTopologicalLinks.
   **/
  public void getAllTopLevelTopologicalLinkNames (int how_many, hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesList_THolder nameList, hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesIterator_IHolder nameIt) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("getAllTopLevelTopologicalLinkNames",true);
          _out.write_ulong (how_many);
          _in = _invoke (_out);
          nameList.value = hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesList_THelper.read (_in);
          nameIt.value = hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesIterator_IHelper.read (_in);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "getAllTopLevelTopologicalLinkNames",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
         hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesList_THolder _nameList = new hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesList_THolder();
         hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesIterator_IHolder _nameIt = new hoshen.xsm.lightsoft.corba.globaldefs.NamingAttributesIterator_IHolder();
          ((hoshen.xsm.lightsoft.corba.emsMgr.EMSMgr_IOperations)_so.servant).getAllTopLevelTopologicalLinkNames( how_many,_nameList,_nameIt );
         nameList.value = _nameList.value;
         nameIt.value = _nameIt.value;
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // getAllTopLevelTopologicalLinkNames


  /**
   * <p>This service returns a top level topological link given its name.</p>
   * 
   * @parm globaldefs::NamingAttributes topoLinkName: Name of the top level 
   *  topological link to retrieve.
   * @parm TopologicalLink_T topoLink: Top level topological link returned.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when topoLinkName does not reference a top level topological
   *  link object<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when topoLinkName references a top level topological link
   *  object that does not exist<br>
   * </dir>
   **/
  public void getTopLevelTopologicalLink (hoshen.xsm.lightsoft.corba.globaldefs.NameAndStringValue_T[] topoLinkName, hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLink_THolder topoLink) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("getTopLevelTopologicalLink",true);
          hoshen.xsm.lightsoft.corba.globaldefs.NVSList_THelper.write (_out, topoLinkName);
          _in = _invoke (_out);
          topoLink.value = hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLink_THelper.read (_in);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "getTopLevelTopologicalLink",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
         hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLink_THolder _topoLink = new hoshen.xsm.lightsoft.corba.topologicalLink.TopologicalLink_THolder();
          ((hoshen.xsm.lightsoft.corba.emsMgr.EMSMgr_IOperations)_so.servant).getTopLevelTopologicalLink( topoLinkName,_topoLink );
         topoLink.value = _topoLink.value;
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // getTopLevelTopologicalLink


  /**
   * <p>This allows an NMS to request all of the active alarms and TCAs that
   * are under the control of this EMS (both those raised by
   * the NEs and those raised by the EMS itself). Some alarms may be
   * filtered out (excluded) by specifying their probable causes or severities.
   * </p>
   * 
   * <p>The result of this operation is independent of the filtering set up by the NMS 
   * for the notification service.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm notifications::ProbableCauseList_T excludeProbCauseList: The list of probable
   * causes to exclude (for which events should not be reported).
   * @parm notifications::PerceivedSeverityList_T excludeSeverityList: List of severities
   *  to exclude from the output event list.
   * @parm unsigned long how_many: Maximum number of alarms and TCAs to report in the first
   *  batch.
   * @parm  notifications::EventList_T eventList: First batch of alarms and TCAs.
   * @parm  notifications::EventIterator_I eventIt: Iterator to retrieve the remaining
   * alarms and TCAs.
   * @raises globaldefs::ProcessingFailureException:<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
  public void getAllEMSAndMEActiveAlarms (String[] excludeProbCauseList, hoshen.xsm.lightsoft.corba.notifications.PerceivedSeverity_T[] excludeSeverityList, int how_many, hoshen.xsm.lightsoft.corba.notifications.EventList_THolder eventList, hoshen.xsm.lightsoft.corba.notifications.EventIterator_IHolder eventIt) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("getAllEMSAndMEActiveAlarms",true);
          hoshen.xsm.lightsoft.corba.notifications.ProbableCauseList_THelper.write (_out, excludeProbCauseList);
          hoshen.xsm.lightsoft.corba.notifications.PerceivedSeverityList_THelper.write (_out, excludeSeverityList);
          _out.write_ulong (how_many);
          _in = _invoke (_out);
          eventList.value = hoshen.xsm.lightsoft.corba.notifications.EventList_THelper.read (_in);
          eventIt.value = hoshen.xsm.lightsoft.corba.notifications.EventIterator_IHelper.read (_in);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "getAllEMSAndMEActiveAlarms",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
         hoshen.xsm.lightsoft.corba.notifications.EventList_THolder _eventList = new hoshen.xsm.lightsoft.corba.notifications.EventList_THolder();
         hoshen.xsm.lightsoft.corba.notifications.EventIterator_IHolder _eventIt = new hoshen.xsm.lightsoft.corba.notifications.EventIterator_IHolder();
          ((hoshen.xsm.lightsoft.corba.emsMgr.EMSMgr_IOperations)_so.servant).getAllEMSAndMEActiveAlarms( excludeProbCauseList,excludeSeverityList,how_many,_eventList,_eventIt );
         eventList.value = _eventList.value;
         eventIt.value = _eventIt.value;
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // getAllEMSAndMEActiveAlarms


  /**
   * <p>This allows an NMS to request all of the active alarms and TCAs that
   * for the EMS itself.  Some alarms may be
   * filtered out (excluded) by specifying their severities.</p>
   * 
   * <p>The result of this operation is independent of the filtering set up by the NMS 
   * for the notification service.</p>
   *
   * <p>In order to allow the NMS to deal with a large number of objects,
   * this operation uses an iterator. See
   * <a href=supportingDocumentation/iterators.html>iterator overview</a>
   * for information on how iterators are used in this interface.</p>
   * 
   * @parm notifications::PerceivedSeverityList_T excludeSeverityList: List of severities
   *  to exclude from the output event list.
   * @parm unsigned long how_many: Maximum number of alarms and TCAs to report in the first
   *  batch.
   * @parm  notifications::EventList_T eventList: First batch of alarms and TCAs.
   * @parm  notifications::EventIterator_I eventIt: Iterator to retrieve the remaining
   * alarms and TCAs.
   * @raises globaldefs::ProcessingFailureException:<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_TOO_MANY_OPEN_ITERATORS - Raised when maximum number of iterators that the EMS
   *  can support has been reached.
   * </dir>
   **/
  public void getAllEMSSystemActiveAlarms (hoshen.xsm.lightsoft.corba.notifications.PerceivedSeverity_T[] excludeSeverityList, int how_many, hoshen.xsm.lightsoft.corba.notifications.EventList_THolder eventList, hoshen.xsm.lightsoft.corba.notifications.EventIterator_IHolder eventIt) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("getAllEMSSystemActiveAlarms",true);
          hoshen.xsm.lightsoft.corba.notifications.PerceivedSeverityList_THelper.write (_out, excludeSeverityList);
          _out.write_ulong (how_many);
          _in = _invoke (_out);
          eventList.value = hoshen.xsm.lightsoft.corba.notifications.EventList_THelper.read (_in);
          eventIt.value = hoshen.xsm.lightsoft.corba.notifications.EventIterator_IHelper.read (_in);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "getAllEMSSystemActiveAlarms",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
         hoshen.xsm.lightsoft.corba.notifications.EventList_THolder _eventList = new hoshen.xsm.lightsoft.corba.notifications.EventList_THolder();
         hoshen.xsm.lightsoft.corba.notifications.EventIterator_IHolder _eventIt = new hoshen.xsm.lightsoft.corba.notifications.EventIterator_IHolder();
          ((hoshen.xsm.lightsoft.corba.emsMgr.EMSMgr_IOperations)_so.servant).getAllEMSSystemActiveAlarms( excludeSeverityList,how_many,_eventList,_eventIt );
         eventList.value = _eventList.value;
         eventIt.value = _eventIt.value;
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // getAllEMSSystemActiveAlarms


  /**
   * <p>The nativeEMSName is owned by the EMS.  It represents how an EMS user addresses an object
   * on the EMS GUI.  The EMS may or may not support changing this value.</p>
   *
   * <p>When an object is created by the EMS, the EMS selects the nativeEMSName for the object.</p>
   *
   * <p>When an object is created by an NMS, the NMS specifies the userLabel for the object.  
   * If the EMS supports setting of nativeEMSNames, the nativeEMSName should be set to the same
   * value as the userLabel.  If the EMS does not support setting of nativeEMSNames, or if the
   * nativeEMSName has constraints that the
   * userLabel does not satisfy, the EMS selects the nativeEMSName for the object.</p>
   *
   * <p>After an object has been created, the nativeEMSName may be changed by the NMS, if the
   * EMS supports this functionality, using the setNativeEMSName operation.</p>
   *
   * @parm globaldefs::NamingAttributes_T objectName
   * @parm string nativeEMSName
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references object which does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost
   * </dir>
   **/
  public void setNativeEMSName (hoshen.xsm.lightsoft.corba.globaldefs.NameAndStringValue_T[] objectName, String nativeEMSName) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("setNativeEMSName",true);
          hoshen.xsm.lightsoft.corba.globaldefs.NVSList_THelper.write (_out, objectName);
          _out.write_string (nativeEMSName);
          _in = _invoke (_out);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "setNativeEMSName",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
          ((hoshen.xsm.lightsoft.corba.common.Common_IOperations)_so.servant).setNativeEMSName( objectName,nativeEMSName );
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // setNativeEMSName


  /**
   * <p>The userLabel is owned by the NMSes.  It is a string assigned by an NMS to an object.
   * The difference between the userLabel and the NamingAttributes name
   * is that the userLabel is an attribute of the objects that 
   * may be "set" by the NMS through well defined interfaces (setUserLabel).</p>
   *
   * <p>When an object is created by an NMS, the NMS specifies the userLabel for the object.</p>
   *
   * <p>When an object is created by the EMS, the EMS sets the userLabel to the nativeEMSName.</p>
   *
   * <p>Once an object is created, the userLabel may only be changed by an NMS through the 
   * setUserLabel operation.</p>
   *
   * @parm globaldefs::NamingAttributes_T objectName: Name of the object for which to change the
   *  userLabel.
   * @parm string userLabel: New user label to assign to the object
   * @parm boolean enforceUniqueness: Specifies whether or not userLabel should be checked for
   *  uniqueness amongst objects of the same class within the EMS.  If true, then the operation
   *  will fail if userLabel is already in use.
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references object which does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * EXCPT_USERLABEL_IN_USE - Raised when the userLabel uniqueness constraint is not met<br>
   * </dir>
   **/
  public void setUserLabel (hoshen.xsm.lightsoft.corba.globaldefs.NameAndStringValue_T[] objectName, String userLabel, boolean enforceUniqueness) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("setUserLabel",true);
          hoshen.xsm.lightsoft.corba.globaldefs.NVSList_THelper.write (_out, objectName);
          _out.write_string (userLabel);
          _out.write_boolean (enforceUniqueness);
          _in = _invoke (_out);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "setUserLabel",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
          ((hoshen.xsm.lightsoft.corba.common.Common_IOperations)_so.servant).setUserLabel( objectName,userLabel,enforceUniqueness );
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // setUserLabel


  /** 
   * <p>This service sets the owner attribute of the specified object.</p>
   *
   * @parm globaldefs::NamingAttributes_T objectName
   * @parm string owner
   * @raises globaldefs::ProcessingFailureException<dir>
   * EXCPT_NOT_IMPLEMENTED - If EMS does not support this service<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_INVALID_INPUT - Raised when objectName is incorrectly formed<br>
   * EXCPT_ENTITY_NOT_FOUND - Raised when objectName references an object
   *  that does not exist<br>
   * EXCPT_NE_COMM_LOSS - Raised when communications to managedElement is lost<br>
   * </dir>
   **/
  public void setOwner (hoshen.xsm.lightsoft.corba.globaldefs.NameAndStringValue_T[] objectName, String owner) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("setOwner",true);
          hoshen.xsm.lightsoft.corba.globaldefs.NVSList_THelper.write (_out, objectName);
          _out.write_string (owner);
          _in = _invoke (_out);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "setOwner",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
          ((hoshen.xsm.lightsoft.corba.common.Common_IOperations)_so.servant).setOwner( objectName,owner );
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // setOwner


  /** 
   * <p>This service retrieves the capabilities of the manager.
   * All non-specified capabilities are assumed to be unsupported.</p>
   *
   * @parm CapabilityList_T capabilities
   * @raises globaldefs::ProcessingFailureException:<dir>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure.
   * </dir>
   **/
  public void getCapabilities (hoshen.xsm.lightsoft.corba.common.CapabilityList_THolder capabilities) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("getCapabilities",true);
          _in = _invoke (_out);
          capabilities.value = hoshen.xsm.lightsoft.corba.common.CapabilityList_THelper.read (_in);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "getCapabilities",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
         hoshen.xsm.lightsoft.corba.common.CapabilityList_THolder _capabilities = new hoshen.xsm.lightsoft.corba.common.CapabilityList_THolder();
          ((hoshen.xsm.lightsoft.corba.common.Common_IOperations)_so.servant).getCapabilities( _capabilities );
         capabilities.value = _capabilities.value;
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // getCapabilities

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:mtnm.tmforum.org/emsMgr/EMSMgr_I:1.0", 
    "IDL:mtnm.tmforum.org/common/Common_I:1.0"};

  public String[] _ids ()
  {
    return (String[])__ids.clone ();
  }

  final public static java.lang.Class _opsClass =
    hoshen.xsm.lightsoft.corba.emsMgr.EMSMgr_IOperations.class;

  private void readObject (java.io.ObjectInputStream s)
  {
     try 
     {
       String str = s.readUTF ();
       org.omg.CORBA.Object obj = org.omg.CORBA.ORB.init ((String[])null, null).string_to_object (str);
       org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl) obj)._get_delegate ();
       _set_delegate (delegate);
     } catch (java.io.IOException e) {}
  }

  private void writeObject (java.io.ObjectOutputStream s)
  {
     try 
     {
       String str = org.omg.CORBA.ORB.init ((String[])null, null).object_to_string (this);
       s.writeUTF (str);
     } catch (java.io.IOException e) {}
  }
} // class _EMSMgr_IStub
