package hoshen.xsm.lightsoft.corba.emsSession;


/**
* hoshen/xsm/lightsoft/corba/emsSession/_EmsSession_IStub.java .
* Generated by the IDL-to-Java compiler (portable), version "3.0"
* from lightsoft/emsSession.idl
* 13:11:31 GMT+02:00 יום חמישי 28 יוני 2007
*/


/** 
     * <p>A handle to an instance of this interface is gained via the
     * <a href=_emsSessionFactory.EmsSessionFactory_I.html#emsSessionFactory::EmsSessionFactory_I::getEmsSession>
     * getemsSession</a> operation in EmsSessionFactory_I.</p>
     */
public class _EmsSession_IStub extends org.omg.CORBA_2_3.portable.ObjectImpl implements hoshen.xsm.lightsoft.corba.emsSession.EmsSession_I
{
  // Constructors
  // NOTE:  If the default constructor is used, the
  //        object is useless until _set_delegate (...)
  //        is called.
  public _EmsSession_IStub ()
  {
    super ();
  }

  public _EmsSession_IStub (org.omg.CORBA.portable.Delegate delegate)
  {
    super ();
    _set_delegate (delegate);
  }


  /**
   * <p>This allows an NMS to request the manager interfaces that the EMS implements</p>
   * @parm supportedManagerList: list of manager names supported
   *  in the form <i>managerName</i>
   *  where <i>managerName</i> is one of the following defined manager strings
   * <ol>
   * <li> "EMS" (mandatory)
   * <li> "ManagedElement" (mandatory)
   * <li> "MultiLayerSubnetwork" (mandatory)
   * <li> "TrafficDescriptor"
   * <li> "PerformanceManagement"
   * <li> "Protection"
   * <li> "EquipmentInventory"
   * <li> "Maintenance"
   * <li> "GuiCutThrough" (mandatory)
   * </ol>
   * Additional managerName strings can be defined without changing this IDL.
   * @raises globaldefs::ProcessingFailureException<dir> 
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_ACCESS_DENIED  - Raised in case of security violation</dir>
   **/
  public void getSupportedManagers (hoshen.xsm.lightsoft.corba.emsSession.EmsSession_IPackage.managerNames_THolder supportedManagerList) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("getSupportedManagers",true);
          _in = _invoke (_out);
          supportedManagerList.value = hoshen.xsm.lightsoft.corba.emsSession.EmsSession_IPackage.managerNames_THelper.read (_in);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "getSupportedManagers",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
         hoshen.xsm.lightsoft.corba.emsSession.EmsSession_IPackage.managerNames_THolder _supportedManagerList = new hoshen.xsm.lightsoft.corba.emsSession.EmsSession_IPackage.managerNames_THolder();
          ((hoshen.xsm.lightsoft.corba.emsSession.EmsSession_IOperations)_so.servant).getSupportedManagers( _supportedManagerList );
         supportedManagerList.value = _supportedManagerList.value;
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // getSupportedManagers


  /**
   * <p>This allows an NMS to gain access to the specified manager interface.</p>
   *
   * @parm managerName: The class or type of manager object that the client wants
   * (see getSupportedManagers).
   * @parm managerInterface: The actual object returned will implement the 
   * specified manager interface.  However it is returned as a 
   * Common_I object so that this operation can be generic.  The client should 
   * narrow the returned object to the correct object type.
   * 
   * <p>Attempting to gain access to the following manager interfaces
   * may <u>not</u> raise EXCPT_NOT_IMPLEMENTED:<br>
   * EMS<br>
   * ManagedElement<br>
   * MultiLayerSubnetwork<br>
   * GuiCutThrough</p>
   *
   * @raises globaldefs::ProcessingFailureException<dir> 
   * EXCPT_NOT_IMPLEMENTED - Raised if the EMS does not support the manager<br>
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_ACCESS_DENIED  - Raised in case of security violation</dir>
   **/
  public void getManager (String managerName, hoshen.xsm.lightsoft.corba.common.Common_IHolder managerInterface) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("getManager",true);
          _out.write_string (managerName);
          _in = _invoke (_out);
          managerInterface.value = hoshen.xsm.lightsoft.corba.common.Common_IHelper.read (_in);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "getManager",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
         hoshen.xsm.lightsoft.corba.common.Common_IHolder _managerInterface = new hoshen.xsm.lightsoft.corba.common.Common_IHolder();
          ((hoshen.xsm.lightsoft.corba.emsSession.EmsSession_IOperations)_so.servant).getManager( managerName,_managerInterface );
         managerInterface.value = _managerInterface.value;
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // getManager


  /**
   * <p>This allows an NMS to gain access to the event channel to receive notifications.</p>
   *
   * @parm EventChannel eventChannel: The event channel to be used by the NMS.
   * 
   * @raises globaldefs::ProcessingFailureException<dir> 
   * EXCPT_INTERNAL_ERROR - Raised in case of non-specific EMS internal failure<br>
   * EXCPT_ACCESS_DENIED  - Raised in case of security violation</dir>
   **/
  public void getEventChannel (hoshen.xsm.lightsoft.corba.CosNotifyChannelAdmin.EventChannelHolder eventChannel) throws hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureException
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("getEventChannel",true);
          _in = _invoke (_out);
          eventChannel.value = hoshen.xsm.lightsoft.corba.CosNotifyChannelAdmin.EventChannelHelper.read (_in);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
           if ( _id.equals ( hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.id() ) )
            throw hoshen.xsm.lightsoft.corba.globaldefs.ProcessingFailureExceptionHelper.read( _in );
           else throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "getEventChannel",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
         hoshen.xsm.lightsoft.corba.CosNotifyChannelAdmin.EventChannelHolder _eventChannel = new hoshen.xsm.lightsoft.corba.CosNotifyChannelAdmin.EventChannelHolder();
          ((hoshen.xsm.lightsoft.corba.emsSession.EmsSession_IOperations)_so.servant).getEventChannel( _eventChannel );
         eventChannel.value = _eventChannel.value;
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // getEventChannel


  /**
   * <p>This attribute contains a reference to the Session_I on the other side (NMS/EMS)
   * to which the object is associated.
   * This attribute can be checked to make sure the NmsSession_I/EmsSession_I association is
   * still valid (in particular in case of communication failures).</p>
   **/
  public hoshen.xsm.lightsoft.corba.session.Session_I associatedSession ()
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("_get_associatedSession",true);
          _in = _invoke (_out);
          hoshen.xsm.lightsoft.corba.session.Session_I __result = hoshen.xsm.lightsoft.corba.session.Session_IHelper.read (_in);
          return __result;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
          throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "_get_associatedSession",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
          hoshen.xsm.lightsoft.corba.session.Session_I __result = ((hoshen.xsm.lightsoft.corba.session.Session_IOperations)_so.servant).associatedSession(  );
          return __result;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // associatedSession


  /**
   * <p> Allows for the detection of loss of communication.
   * It is implementation specific to differenciate intermittent 
   * problems from loss of connection.</p>
   **/
  public void ping ()
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("ping",true);
          _in = _invoke (_out);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
          throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "ping",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
          ((hoshen.xsm.lightsoft.corba.session.Session_IOperations)_so.servant).ping(  );
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // ping


  /**
   * <p> Allows for a controlled disconnect between parties.
   * All resources allocated for the session are deleted by operation.</p>
   **/
  public void endSession ()
  {
    while(true) {
      if ( !this._is_local() ) {
        org.omg.CORBA.portable.InputStream _in = null;
        try {
          org.omg.CORBA.portable.OutputStream _out = _request ("endSession",false);
          _in = _invoke (_out);
          return;
        } catch (org.omg.CORBA.portable.ApplicationException _ex) {
          _in = _ex.getInputStream ();
          String _id = _ex.getId ();
          throw new org.omg.CORBA.UNKNOWN( "Unexpected User Exception: " + _id );
        } catch (org.omg.CORBA.portable.RemarshalException _rm) {
          continue;
        } catch (org.omg.CORBA.portable.UnknownException _ue) {
          Throwable _oe = _ue.originalEx;
          if (_oe instanceof Error)
              throw (Error)_oe;
          else if (_oe instanceof RuntimeException)
              throw (RuntimeException)_oe;
          else
              throw _ue;
        } finally { _releaseReply (_in); }
      }
      else {
        org.omg.CORBA.portable.ServantObject _so =
          _servant_preinvoke( "endSession",_opsClass );
        if ( _so == null ) { 
          continue;
        }
        try {
          ((hoshen.xsm.lightsoft.corba.session.Session_IOperations)_so.servant).endSession(  );
          return;
        } finally { _servant_postinvoke( _so ); }
      }
    }
  } // endSession

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:mtnm.tmforum.org/emsSession/EmsSession_I:1.0", 
    "IDL:mtnm.tmforum.org/session/Session_I:1.0"};

  public String[] _ids ()
  {
    return (String[])__ids.clone ();
  }

  final public static java.lang.Class _opsClass =
    hoshen.xsm.lightsoft.corba.emsSession.EmsSession_IOperations.class;

  private void readObject (java.io.ObjectInputStream s)
  {
     try 
     {
       String str = s.readUTF ();
       org.omg.CORBA.Object obj = org.omg.CORBA.ORB.init ((String[])null, null).string_to_object (str);
       org.omg.CORBA.portable.Delegate delegate = ((org.omg.CORBA.portable.ObjectImpl) obj)._get_delegate ();
       _set_delegate (delegate);
     } catch (java.io.IOException e) {}
  }

  private void writeObject (java.io.ObjectOutputStream s)
  {
     try 
     {
       String str = org.omg.CORBA.ORB.init ((String[])null, null).object_to_string (this);
       s.writeUTF (str);
     } catch (java.io.IOException e) {}
  }
} // class _EmsSession_IStub
